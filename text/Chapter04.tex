% ==================================================================================================

\chapter{Types for flat coeffects}
\label{ch:flat}

In the previous chapter, we outlined a number of systems that capture how computations
access the environment in which they are executed. We identified two kinds of systems --
\emph{flat systems} capturing whole-context properties and \emph{structural systems} capturing
per-variable properties. As we show in Section~\ref{sec:further-unified}, the systems can be
further unified using a single abstraction, but such abstraction is \emph{less powerful} -- \ie~its
generality hides useful properties that we can see when we consider the systems separately. For
this reason, we discuss \emph{flat coeffects} (Chapter~\ref{ch:flat} and Chapter~\ref{ch:semantics})
and \emph{structural coeffects} (Chapter~\ref{ch:structural}) separately.

In this chapter, we develop a \emph{flat coeffect calculus} that provides a type system for
tracking per-context properties of context-aware programming languages. The \emph{coeffect
calculus} captures the shared properties of such languages. It is parameterized by a \emph{flat
coeffect algebra} and can be instantiated to track implicit parameters, liveness and number of
required past values in dataflow languages.
To capture contextual properties in full generality, the flat coeffect calculus permits multiple
valid typing derivations for a given term. To resolve the ambiguity arising from such generality,
each concrete context-aware language is also equipped with an algorithm for choosing a unique
typing derivation. This allows us to explore the language design landscape, while still follow
the usual scoping rules for languages with established approaches (e.g.~implicit parameters in
Haskell).

In the next chapter, we give operational meaning for concrete coeffect
languages based on the flat coeffect calculus and we discuss their safety.

\paragraph{Chapter structure and contributions}
\begin{itemize}
\item We present a \emph{flat coeffect calculus} as a type system that is parameterized by a
  \emph{flat coeffect algebra} (Section~\ref{sec:flat-calculus}). We show that the system can be
  instantiated to obtain three of the systems discussed in Section~\ref{sec:applications-flat},
  namely implicit parameters, liveness and dataflow.

\item The coeffect calculus permits multiple typing derivations due to the ambiguity inherent
  in contextual lambda abstraction. Each concrete context-aware language based on the
  coeffect calculus must specify how such ambiguities are to be resolved. We give the procedure for
  choosing unique typing derivation for our three examples (Section~\ref{sec:flat-unique}).

\item We discuss equational properties of the calculus, covering type-pre\-ser\-vation for call-by-name
  and call-by-value reduction (Section~\ref{sec:flat-syntax}). We also extend the calculus
  with subtyping and pairs (Section~\ref{sec:flat-exts}).
\end{itemize}

% ==================================================================================================
%
%    ###
%     #  #    # ##### #####   ####  #####  #    #  ####  ##### #  ####  #    #
%     #  ##   #   #   #    # #    # #    # #    # #    #   #   # #    # ##   #
%     #  # #  #   #   #    # #    # #    # #    # #        #   # #    # # #  #
%     #  #  # #   #   #####  #    # #    # #    # #        #   # #    # #  # #
%     #  #   ##   #   #   #  #    # #    # #    # #    #   #   # #    # #   ##
%    ### #    #   #   #    #  ####  #####   ####   ####    #   #  ####  #    #
%
% ==================================================================================================

\section{Introduction}
\label{sec:flat-intro}

In the previous chapter, we looked at three examples of systems that track whole-context
properties. The type systems for whole-context liveness (Section~\ref{sec:applications-flat-live})
and whole-context dataflow (Section~\ref{sec:applications-flat-dataflow}) have a similar
structure in two ways. First, lambda abstraction duplicates their \emph{context demands}. Given a
body with context demands $\cclrd{r}$, the declaration site context \emph{as well as} the function
arrow are annotated with $\cclrd{r}$. Second, the context demands in the type systems are combined
using two different operators (representing sequential and pointwise operations).

The system for tracking implicit parameters (Section~\ref{sec:applications-flat-impl})
differs. In lambda abstraction, it partitions the context demands between the
declaration site and the call site. Furthermore, the operator that combines context demands
is $\cup$ for both sequential and pointwise composition.

Despite the differences, the systems fit the same framework. This becomes apparent when
we consider the categorical structure (Section~\ref{sec:flat-semantics}). Rather than starting
from the categorical semantics, we first explain how the systems can be unified syntactically
(Section~\ref{sec:flat-calculus-lambda}) and then provide the semantics as an additional
justification.

The development in this chapter can be seen as a counterpart to the well-known development of
\emph{effect systems} \cite{effects-gifford}. Chapter~\ref{ch:semantics} then links \emph{coeffects}
with \emph{comonads} in the same way in which effect systems have been linked with monads
\cite{monad-notions}. The syntax and type system of the flat coeffect calculus follows
a similar style as effect systems \cite{effects-polymorphic,effects-talpin-et-al}, but differs
in the structure of lambda abstraction as discussed briefly here and in Section~\ref{sec:applications-structure-lam}
(the relationship with monads is further discussed in Section~\ref{sec:semantics-related}).


%---------------------------------------------------------------------------------------------------

\subsection{A unified treatment of lambda abstraction}
\label{sec:flat-calculus-lambda}

Recall the lambda abstraction rules for the implicit parameters coeffect system (annotating
contexts with sets of required parameters) and the dataflow system (annotating contexts with the
number of past required values):
%
\begin{equation*}
\tyrule{param}
  {\coctx{\Gamma, x\!:\!\tau_1}{\cclrd{r} \cup \cclrd{s}} \vdash e : \tau_2}
  {\coctx{\Gamma}{\cclrd{r}} \vdash \lambda x.e : \tau_1 \xrightarrow{\cclrd{s}} \tau_2 }
\;
\tyrule{df1}
  {\coctx{\Gamma, x\!:\!\tau_1}{\cclrd{n}} \vdash e : \tau_2}
  {\coctx{\Gamma}{\cclrd{n}} \vdash \lambda x.e : \tau_1 \xrightarrow{\cclrd{n}} \tau_2 }
\end{equation*}
%
In order to capture both systems using a single calculus, we need a way of rewriting the
(\emph{df1}) rule such that the annotation in the assumption is in the form $\cclrd{n \circ m}$
for some operation $\cclrd{\circ}$. For the dataflow system, this can be achieved by using
the $\cclrd{\emph{min}}$ function:
%
\begin{equation*}
\tyrule{df2}
  {\coctx{\Gamma, x\!:\!\tau_1}{\cclrd{\textnormal{min}(n, m)}} \vdash e : \tau_2}
  {\coctx{\Gamma}{\cclrd{n}} \vdash \lambda x.e : \tau_1 \xrightarrow{\cclrd{m}} \tau_2 }
\end{equation*}
%
The rule (\emph{df1}) is admissible in a system that includes the (\emph{df2}) rule. That is,
a typing derivation using (\emph{df1}) is also valid when using (\emph{df2}). Furthermore,
if we include sub-typing rule (on annotations of functions) and subcoeffecting rule (on
annotations of contexts), then the reverse is also true -- because
$\cclrd{\textit{min}(n, m)} \leq \cclrd{m}$ and $\cclrd{\textit{min}(n, m)} \leq \cclrd{n}$.
In other words (\emph{df2}) permits an implicit subcoeffecting (and sub-typing) that is not
possible when using the (\emph{df1}) rule, but it has a structure that can be unified
with (\emph{param}).


% ==================================================================================================
%
%     #####
%    #     #   ##   #       ####  #    # #      #    #  ####
%    #        #  #  #      #    # #    # #      #    # #
%    #       #    # #      #      #    # #      #    #  ####
%    #       ###### #      #      #    # #      #    #      #
%    #     # #    # #      #    # #    # #      #    # #    #
%     #####  #    # ######  ####   ####  ######  ####   ####
%
% ==================================================================================================

\section{Flat coeffect calculus}
\label{sec:flat-calculus}

This section describes the \emph{flat coeffect calculus}. A small programming language based on the
$\lambda$-calculus with a type system that statically tracks context demands. The calculus can
capture different notions of context. The structure of context demands is provided by a
\emph{flat coeffect algebra} (defined in the next section) which is an abstract algebraic structure
that can be instantiated to model concrete context demands (sets of implicit parameters, number
of past values as integers or other information). Annotations that specify context demands are
written as $\cclrd{r}, \cclrd{s}, \cclrd{t}$.

We enrich types and typing judgements with coeffect annotations $\cclrd{r}, \cclrd{s}, \cclrd{t}$;
typing judgements are written as $\coctx{\Gamma}{\cclrd{r}}\vdash e:\tau$. The expressions of
the calculus are those of the $\lambda$-calculus with \emph{let} binding. We also include a type
\ident{num} as an example of a concrete base type with numerical constants written as $n$:
%
\begin{equation*}
\begin{array}{rcl}
e &::=& x \sep n \sep \lambda x:\tau.e \sep e_1~e_2 \sep \kvd{let}~x = e_1~\kvd{in}~e_2\\
\tau &::=& \ident{num} \sep \tau_1 \xrightarrow{\cclrd{r}} \tau_2
\end{array}
\end{equation*}
%
Note that the lambda abstraction in the syntax is written in the Church-style and requires a type
annotation. This will be used in Section~\ref{sec:flat-unique} where we discuss how to find a
unique typing derivation for context-aware computations. Using Church-style lambda abstraction,
we can directly focus on the more interesting problem of finding unique \emph{coeffect annotations}
rather than solving the problem of type reconstruction.

We discuss subtyping and pairs in Section~\ref{sec:flat-exts}. The type $\tau_1 \xrightarrow{\cclrd{r}} \tau_2$
represents a function from $\tau_1$ to $\tau_2$ that requires additional context $\cclrd{r}$.
It can be viewed as a pure function that takes $\tau_1$ \emph{with} or \emph{wrapped in} a
context $\cclrd{r}$.

In the categorically-inspired translation in the next chapter, the function
$\tau_1 \xrightarrow{\cclrd{r}} \tau_2$ is translated into a function
$C^{\cclrd{r}} \tau_1 \rightarrow \tau_2$. However, the type constructor $C^{\cclrd{r}}$
does not itself exist as a syntactic value in the coeffect calculus. This is because we use
comonads to define the \emph{semantics} rather than \emph{embedding} them into the language as in
the meta-language approaches (the distinction has been discussed in Section~\ref{sec:path-sem-langs}).
The annotations $\cclrd{r}$ are formed by an algebraic structure discussed next.

%---------------------------------------------------------------------------------------------------

\subsection{Flat coeffect algebra}
\label{sec:flat-calculus-algebra}

To make the flat coeffect system general enough, the algebra consists of three operations.
Two of them, $\cseq$ and $\cpar$, represent \emph{sequential} and \emph{pointwise} composition,
which are mainly used in function application. The third operator, $\czip$ is used in lambda
abstraction and represents \emph{splitting} of context demands.

In addition to the three operations, the algebra also requires two special values used to annotate
variable access and constant access and a relation that defines the ordering.

\begin{definition}
A \emph{\cclrd{flat coeffect algebra}} $(\C, \cseq, \cpar, \czip, \cunit, \czero, \cleq)$ is a set
$\C$ together with elements $\cunit, \czero \in \C$, binary relation $\cleq$ and binary operations
$\cseq, \cpar, \czip$ such that $(\C, \cseq, \cunit)$ is a monoid, $(\C, \cpar, \czero)$ is an
idempotent monoid, $(\C, \czip)$ is a band (idempotent semigroup) and $(\C, \cleq)$ is a pre-order.
That is, for all $r,s,t\in \C$:
%
\begin{equation*}
\begin{array}{ccc}
r \;\cseq\; (s \;\cseq\; t) = (r \;\cseq\; s) \;\cseq\; t &&
\cunit \;\cseq\; r = r = r \;\cseq\; \cunit
\\
r \;\cpar\; (s \;\cpar\; t) = (r \;\cpar\; s) \;\cpar\; t &
r\; \cpar\; r = r~~~~&
\czero \;\cpar\; r = r = r \;\cpar\; \czero
\\
r \;\czip\; (s \;\czip\; t) = (r \;\czip\; s) \;\czip\; t &&
r\; \czip\; r = r \qquad
\\
\textnormal{if}~~r\; \cleq\; s ~~\textnormal{and}~~s\; \cleq\; t~~\textnormal{then}~~r\; \cleq\; t &&
t\; \cleq\; t \\[0.5em]
\end{array}
\end{equation*}
%
In addition, the following distributivity axioms hold:
\begin{align*}
\quad (\cclrd{r}\, \cpar\, \cclrd{s}) \;\cseq\; \cclrd{t} & = (\cclrd{r} \,\cseq\, \cclrd{t}) \;\cpar\; (\cclrd{s}\, \cseq\, \cclrd{t}) \\
\quad \cclrd{t} \;\cseq\; (\cclrd{r}\, \cpar\, \cclrd{s}) & = (\cclrd{t} \,\cseq\, \cclrd{r}) \;\cpar\; (\cclrd{t}\, \cseq\, \cclrd{s})
\end{align*}
\end{definition}

\noindent
In two of the three systems, some of the operators of the flat coeffect algebra coincide, but
in the dataflow system all three are distinct. Similarly, the two special elements
coincide in some, but not all systems. The required axioms are motivated by the aim to capture
common properties of the three examples, without unnecessarily restricting the system:

\begin{itemize}
\item The monoid $(\C, \cseq, \cunit)$ represents \emph{sequential} composition of (semantic)
functions. The monoid axioms are required in order to form a category structure in the
semantics (Section~\ref{sec:flat-semantics}).

\item The idempotent monoid $(\C, \cpar, \czero)$ represents \emph{pointwise} composition,
\ie~the case when the same context is passed to multiple (independent) computations. The monoid
axioms guarantee that usual syntactic transformations on tuples and the unit value
(Section~\ref{sec:flat-exts}) preserve the coeffect. Idempotence holds for all our examples
and allows us to unify the flat and structural systems in Section~\ref{sec:further-unified}.

\item For the $\czip$ operation, we require associativity and idempotence. The idempotence
demand makes it possible to duplicate the given coeffects and place the same demand on both
call site and declaration site. Using the example from Section~\ref{sec:flat-calculus-lambda},
this guarantees that the rule (\emph{df1}) is not a special case, but can always be derived
from (\emph{df2}). In some cases, the operator forms a monoid with the unit being the greatest
element of the set $\C$.
\end{itemize}

\noindent
It is worth noting that, in some of the systems, the operators $\cpar$ and $\czip$ are the least
upper bound and the greatest lower bounds of a lattice. For example, in dataflow computations, they
are \emph{max} and \emph{min} respectively. However, this duality does not hold for implicit parameters
(we discuss the lattice-based formulation of coeffects in Section~\ref{sec:unified-impl-semilattice}.

\paragraph{Ordering.}

The flat coeffect algebra includes a pre-order relation $\cleq$. This will be used to introduce
subcoeffecting and subtyping in Section~\ref{sec:flat-exts-sub}, but we make it a part of the flat
coeffect algebra, as it will be useful for characterization of different kinds of coeffect calculi.
When the idempotent monoid $(\C, \cpar, \czero)$ is also commutative (\ie~forms a
semi-lattice), the $\cleq$ relation can be defined as the ordering of the semi-lattice:
%
\begin{equation*}
\cclrd{r} \;\cleq\; \cclrd{s} \;\Longleftrightarrow\; \cclrd{r} \;\cpar\; \cclrd{s} \;=\; \cclrd{s}
\end{equation*}
%
This definition is consistent with all three examples that motivate flat coeffect calculus, but
it cannot be used with the structural coeffects (Chapter~\ref{ch:structural}), where it fails for
the bounded reuse calculus. For this reason, we choose not to use it for flat coeffect calculus
either.

Furthermore, the $\cunit$ coeffect is often the top or the bottom element of the semi-lattice.
As discussed in Section~\ref{sec:flat-syntax}, when this is the case, we are able to prove certain
syntactic properties of the calculus.

%---------------------------------------------------------------------------------------------------

\begin{figure}[t]
\begin{equation*}
\tyrule{var}
  {~}
  {\coctx{\Gamma}{\cunit} \vdash x : \tau }\quad(x : \tau \in \Gamma)
\end{equation*}
\begin{equation*}
\tyrule{const}
  {~}
  {\coctx{\Gamma}{\czero} \vdash n : \ident{num} }
\end{equation*}
\begin{equation*}
\tyrule{app}
  {\coctx{\Gamma}{\cclrd{r}} \vdash e_1 : \tau_1 \xrightarrow{\cclrd{t}} \tau_2 &
   \coctx{\Gamma}{\cclrd{s}} \vdash e_2 : \tau_1 }
  {\coctx{\Gamma}{\cclrd{r} \;\cpar\; (\cclrd{s} \,\cseq\, \cclrd{t})} \vdash e_1~e_2 : \tau_2}
\end{equation*}
\begin{equation*}
\tyrule{abs}
  {\coctx{\Gamma, x\!:\!\tau_1}{\cclrd{r}\;\czip\;\cclrd{s}} \vdash e : \tau_2}
  {\coctx{\Gamma}{\cclrd{r}} \vdash \lambda x\!:\!\tau_1.e : \tau_1 \xrightarrow{\cclrd{s}} \tau_2 }
\end{equation*}
\begin{equation*}
\tyrule{let}
  { \coctx{\Gamma}{\cclrd{r}} \vdash e_1 : \tau_1 &
    \coctx{\Gamma, x\!:\!\tau_1}{\cclrd{s}} \vdash e_2 : \tau_2}
  {\coctx{\Gamma}{\cclrd{s} \;\cpar\; (\cclrd{s} \,\cseq\, \cclrd{r})} \vdash \kvd{let}~x=e_1~\kvd{in}~e_2 : \tau_2 }
\end{equation*}
%
\begin{equation*}
\tyrule{sub}
  {\coctx{\Gamma}{\cclrd{r'}} \vdash e : \tau }
  {\coctx{\Gamma}{\cclrd{r}} \vdash e : \tau }\quad(\cclrd{r'} \cleq \cclrd{r})
\end{equation*}
%

\figcaption{Type system for the flat coeffect calculus}
\label{fig:flat-types}
\end{figure}

%---------------------------------------------------------------------------------------------------

\subsection{Type system}
\label{sec:flat-calculus-types}

The type system for flat coeffect calculus is shown in Figure~\ref{fig:flat-types}. Variables
(\emph{var}) and constants (\emph{const}) are annotated with special values provided by the
coeffect algebra.

The (\emph{abs}) rule is defined as discussed in Section~\ref{sec:flat-calculus-lambda}. The
body is annotated with context demands $\cclrd{r} \,\czip\, \cclrd{s}$, which are then split
between the context-demands on the declaration site $\cclrd{r}$ and context-demands on
the call site $\cclrd{s}$.

In function application (\emph{app}), context demands of both expressions and the
function are combined. As discussed in Chapter~\ref{ch:applications}, sequential composition
is used to combine the context-demands of the argument $\cclrd{s}$ with the context-demands
of the function $\cclrd{t}$. The result $\cclrd{s}\,\cseq\,\cclrd{t}$ is then composed using
pointwise composition with the context demands of the expression that represents the function
$\cclrd{r}$, giving the coeffect $\cclrd{r}\,\cpar\,(\cclrd{s}\cseq\cclrd{t})$.

The type system also includes a rule for let-binding. The rule is \emph{not} equivalent to the
derived rule for $(\lambda x.e_2)~e_1$, but it corresponds to \emph{one} possible typing
derivation. As we show in \ref{sec:flat-exts-let}, the typing used in (\emph{let}) is more
precise than the general rule that can be derived from $(\lambda x.e_2)~e_1$.

To guide understanding of the system, we also show non-syntax-directed (\emph{sub}) rule for
subcoeffecting. The rule states that an expression with context demands $\cclrd{r'}$ can be
treated as an expression with greater context demands $\cclrd{r}$. We return to subcoeffecting,
subtyping and additional constructs such as pairs in Section~\ref{sec:flat-exts}. When
discussing procedure for choosing unique typing in Section~\ref{sec:flat-unique}, we consider
only the syntax-directed part of the system.

%---------------------------------------------------------------------------------------------------
s
\subsection{Understanding flat coeffects}
\label{sec:flat-calculus-understanding}

Before proceeding, let us clarify how the typing judgements should be understood. The coeffect
calculus can be understood in two ways discussed in this and the next chapter. As a type system
(Chapter~\ref{ch:flat}), it provides analysis of context dependence. As a semantics
(Chapter~\ref{ch:semantics}), it specifies how context is propagated. These two readings provide
different ways of interpreting the judgements $\coctx{\Gamma}{\cclrd{r}} \vdash e : \tau$ and the
typing rules used to define it.

\begin{itemize}
\item \textsc{Analysis of context dependence.}
Syntactically, coeffect annotations $\cclrd{r}$ model \emph{context demands}. This means
we can over-approximate them and require more in the type system than is needed at runtime.

Syntactically, the typing rules are best read top-down (from assumptions to the consequent).
In function application, the context demands of multiple assumptions (arising from two
sub-expressions) are \emph{merged}; in lambda abstraction, the demands of a single expression
(the body) are split between the declaration site and the call site.

\item \textsc{Semantics of context passing.}
Semantically, coeffect annotations $\cclrd{r}$ mo\-del \emph{contextual capabilities}. This means
that we can throw away capabilities, if a sub-expression requires fewer than we
currently have.

Semantically, the typing rules should be read bottom-up (from the consequent to assumptions).
In application, the capabilities provided to the term $e_1~e_2$ are \emph{split} between the
two sub-expressions; in abstraction, the capabilities provided by the call site and declaration
site are \emph{merged} and passed to the body.
\end{itemize}

\noindent
For example, using the syntactic reading, the operators $\czip$ and $\cpar$ represent \emph{merging}
and \emph{splitting} of context demands -- in the (\emph{abs}) rule, $\czip$ appears in the assumption
and the combined context demands of the body are split between two positions in the conclusions;
in the (\emph{app}) rule, $\cpar$ appears in the conclusion and combines two context demands
from the assumptions.

The reason for this asymmetry follows from the fact that the context appears in a \emph{negative
position} in the semantic model (Section~\ref{sec:semantics-theory}). It means that we need to be
careful about using the words \emph{split} and \emph{merge}, because they can be read as meaning
exactly the opposite things. To disambiguate, we always use the term \emph{context demands}
when using the syntactic view, especially in the rest of Chapter~\ref{ch:flat}, and
\emph{context capabilities} or just \emph{available context} when using the semantic view,
especially in Chapter~\ref{ch:semantics}.

%---------------------------------------------------------------------------------------------------

\subsection{Examples of flat coeffects}
\label{sec:flat-calculus-examples}

The flat coeffect calculus generalizes the three flat systems discussed in
Section~\ref{sec:applications-flat} of the previous chapter. We can instantiate it to a specific
use just by providing a flat coeffect algebra.

\begin{example}[Implicit parameters]
\label{ex:flat-impl}
Assuming \ident{Id} is a set of implicit parameter names written $\ident{?p}$, the flat coeffect
algebra is formed by $(\mathcal{P}(\ident{Id}), \cup, \cup, \cup, \emptyset, \emptyset, \subseteq)$.
\end{example}

\noindent
For simplicity, assume that all parameters have the same type $\ident{num}$ and so the annotations only
track sets of names. The definition uses a set union for all three operations. Both variables and
constants are are annotated with $\emptyset$ and the ordering is defined by $\subseteq$. The
definition satisfies the flat coeffect algebra axioms because $(S, \cup, \emptyset)$ is an idempotent,
commutative monoid. The language has additional syntax for defining an implicit parameter and for
accessing it, together with associated typing rules:
%
\begin{equation*}
\quad~ e ~::=~ \ldots \sep \ident{?p} \sep \kvd{let}~\ident{?p}~=~e_1~\kvd{in}~e_2
\end{equation*}
\begin{equation*}
\tyrule{param}
  { ~ }
  { \coctx{\Gamma}{\cclrd{ \{ \ident{?p} \} }} \vdash \ident{?p} : \ident{num} }
\end{equation*}
\begin{equation*}
\tyrule{letpar}
  { \coctx{\Gamma}{\cclrd{r}} \vdash e_1 : \tau_1 &
    \coctx{\Gamma}{\cclrd{s}} \vdash e_2 : \tau_2}
  {\coctx{\Gamma}{\cclrd{r} \;\cclrd{\cup\; (\cclrd{s} \setminus \{ \ident{?p}) \}} } \vdash \kvd{let}~\ident{?p}=e_1~\kvd{in}~e_2 : \tau_2 }
\end{equation*}
%
The (\emph{param}) rule specifies that the accessed parameter $\ident{?p}$ needs to be in the set of
required parameters $\cclrd{r}$. As discussed earlier, we use the same type $\ident{num}$ for all
parameters, but it is also possible to define a coeffect calculus that uses mappings from names to
types (care is needed to avoid assigning multiple types to a parameter of the same type).

The (\emph{letpar}) rule is the same as the one discussed in Section~\ref{sec:applications-flat-impl}.
As both of the rules are specific to implicit parameters, we write the operations on coeffects directly
using set operations -- coeffect-specific operations such as set subtraction are not a part of the
unified coeffect algebra.

\begin{example}[Liveness]
Let $\mathcal{L}=\{ \ident{L}, \ident{D} \}$ be a two-point lattice such that $\ident{D} \sqsubseteq \ident{L}$
with join $\sqcup$ and meet $\sqcap$. The flat coeffect algebra for liveness is then formed by
$(\mathcal{L}, \sqcap, \sqcup, \sqcap, \ident{L}, \ident{D}, \sqsubseteq)$.
\end{example}

\noindent
The liveness example is interesting because it does not require any additional syntactic extensions
to the language. It annotates constants and variables with $\ident{D}$ and $\ident{L}$, respectively
and it captures how those annotation propagate through the remaining language constructs.

As in Section~\ref{sec:applications-flat-live}, sequential composition $\cseq$ is modelled by
the meet operation $\sqcap$ and pointwise composition $\cpar$ is modelled by join $\sqcup$.
The two-point lattice is a commutative, idempotent monoid. Distributivity
$(r \sqcup s) \sqcap t = (r \sqcap t) \sqcup (s \sqcap t)$ does not hold for \emph{every}
lattice, but it trivially holds for the two-point lattice used here.

The definition uses join $\sqcup$ for the $\czip$ operator that is used by lambda abstraction.
This means that, when the body is live $\ident{L}$, both declaration site and call site are
marked as live $\ident{L}$. When the body is dead $\ident{D}$, the declaration site and call site
can be marked as dead $\ident{D}$, or as live $\ident{L}$. The latter is less precise, but it
is a valid derivation that could also be obtained via sub-typing.

\begin{example}[Dataflow]
In dataflow, context is annotated with natural numbers and the flat coeffect algebra is formed
by $(\mathbb{N}, +, \mathit{max}, \mathit{min}, 0, 0, \leq)$.
\end{example}

\noindent
As discussed earlier, sequential composition $\cseq$ is represented by $+$ and pointwise
composition $\cpar$ uses $\emph{max}$. For dataflow, we need a third separate operator for
lambda abstraction. Annotating the body with $\emph{min}(\cclrd{r}, \cclrd{s})$ ensures that
both call site and declaration site annotations are equal or greater than the annotation
of the body.

As required by the axioms, $(\mathbb{N}, +, 0)$ and $(\mathbb{N}, \mathit{max}, 0)$ form monoids
and $(\mathbb{N}, \mathit{min})$ forms a band. Note that dataflow is our first example where
$\cseq$ is not idempotent. The distributivity axioms require the following to be the case:
$\mathit{max}(r,s) + t = \mathit{max}(r+t, s+t)$, which is easy to see.

A simple dataflow language includes an additional construct $\kvd{prev}$ for accessing the
previous value in a stream with an additional typing rule that look as follows:
%
\begin{equation*}
\quad~ e ~::=~ \ldots \sep \kvd{next}~e
\end{equation*}
\begin{equation*}
\tyrule{prev}
  { \coctx{\Gamma}{\cclrd{n}} \vdash e : \tau }
  { \coctx{\Gamma}{\cclrd{n+1}} \vdash \kvd{prev}~e : \tau }
\end{equation*}
%
As a further example that was not covered earlier, it is also possible to combine liveness analysis
and dataflow. In the above dataflow calculus, $0$ denotes that we require the current value of some
variable, but no previous values. However, for constants, we do not even need the current value.

\begin{example}[Optimized dataflow]
In optimized dataflow, context is annotated with natural numbers extended with the $\bot$ element,
that is $\mathbb{N}_{\bot} = \{\bot, 0, 1, 2, 3, \ldots \}$ such that $\forall n \in \mathbb{N}. \bot \leq n$.
The flat coeffect algebra is $(\mathbb{N}_{\bot}, +, \mathit{max}, \mathit{min}, 0, \bot, \leq)$
where $m + n$ is $\bot$ whenever $m=\bot$ or $n=\bot$ and \emph{min}, \emph{max} treat $\bot$ as the
least element.
\end{example}

\noindent
Note that $(\mathbb{N}_{\bot}, +, 0)$ is a monoid for the extended definition of $+$; for the
bottom element $0 + \bot = \bot$ and for natural numbers $0 + n = n$. The structure
$(\mathbb{N}, \emph{max}, \bot)$ is also a monoid, because $\bot$ is the least element and so
$\mathit{max}(n, \bot) = n$. Finally,  $(\mathbb{N}, \emph{min})$ is a band (the extended
\emph{min} is still idempotent and associative) and the distributivity axioms also hold
for $\mathbb{N}_{\bot}$.


% ==================================================================================================
%
%       #
%      # #   #    # #####   ####  # #    # # ##### #   #
%     #   #  ##  ## #    # #    # # #    # #   #    # #
%    #     # # ## # #####  #      # #    # #   #     #
%    ####### #    # #    # #  ### # #    # #   #     #
%    #     # #    # #    # #    # # #    # #   #     #
%    #     # #    # #####   ####  #  ####  #   #     #
%
% ==================================================================================================

\section{Choosing a unique typing}
\label{sec:flat-unique}

As discussed in Chapter~\ref{sec:applications}, the lambda abstraction rule for coeffect systems
differs from the rule for effect systems in that it does not delay all context demands.
In case of implicit parameters (Section~\ref{sec:applications-flat-impl}), the demands
can be satisfied either by the call site or by the declaration-site. In case of dataflow and
liveness, the rule discussed in Section~\ref{sec:flat-calculus} reintroduces similar ambiguity
because it allows multiple valid typing derivations.

Furthermore, the semantics of context-aware languages in Chapter~\ref{sec:applications} and
also in Chapter~\ref{ch:semantics} is defined over \emph{typing derivation} and so the meaning
of a program depends on the typing derivation chosen. In this section, we specify how to choose
the desired \emph{unique} typing derivation in each of the coeffect systems we consider.

The most interesting case is that of implicit parameters. For example, consider the following
program written using the coeffect calculus with implicit parameter extensions:
%
\begin{equation*}
\begin{array}{l}
\kvd{let}~f~= (\kvd{let}~\ident{?x}=42~\kvd{in}~(\lambda y.~\ident{?x}))~\kvd{in} \\[-0.2em]
\kvd{let}~\ident{?x}=666~\kvd{in}~f~0 \\[-0.2em]
\end{array}
\end{equation*}

\noindent
There are two possible typings allowed by the typing rules discussed in Section~\ref{sec:flat-calculus-types}
that lead to two possible meanings of the program -- evaluating to $1$ and $2$, respectively:
%
\begin{itemize}
  \item $f : \ident{num} \xrightarrow{\cclrd{\emptyset}} \ident{num}$ -- in this case, the value
    of \ident{?x} is captured from the declaration-site and the program produces $1$.
  \item $f : \ident{num} \xrightarrow{\cclrd{\{ \ident{?x} \}}} \ident{num}$ -- in this case, the
    parameter \ident{?x} is required from the call site and the program produces $2$.
\end{itemize}
%
The coeffect calculus intentionally allows both of the options, acknowledging the fact that the
choice needs to be made for each individual concrete context-aware programming language. In the
above case, one typing derivation represents dynamic binding and the other static binding, but
more subtleties arise when the nested expression uses multiple implicit parameters.

In this section, we discuss the specific choices of typing derivation for implicit parameters,
dataflow and liveness. We use the fact that the coeffect calculus uses Church-style syntax for
lambda abstraction giving a type annotation for the bound variable. This does not affect the
handling of coeffects (those are not defined by the type annotation), but it lets us prove
\emph{uniqueness of typing}; a theorem showing that we define a \emph{unique} way of assigning
coeffects to otherwise well-typed programs.

%---------------------------------------------------------------------------------------------------

\begin{figure}[t]
\begin{equation*}
\tyrule{var}
  {x : \tau \in \Gamma}
  {\coctx{\Gamma;\cclrd{\Delta}}{\cunit} \vdash x : \tau }
\end{equation*}
\begin{equation*}
\tyrule{const}
  {~}
  {\coctx{\Gamma;\cclrd{\Delta}}{\czero} \vdash n : \ident{num} }
\end{equation*}
\begin{equation*}
\tyrule{app}
  {\coctx{\Gamma;\cclrd{\Delta}}{\cclrd{r}} \vdash e_1 : \tau_1 \xrightarrow{\cclrd{t}} \tau_2 &
   \coctx{\Gamma;\cclrd{\Delta}}{\cclrd{s}} \vdash e_2 : \tau_1 }
  {\coctx{\Gamma;\cclrd{\Delta}}{\cclrd{r} \;\cpar\; (\cclrd{s} \,\cseq\, \cclrd{t})} \vdash e_1~e_2 : \tau_2}
\end{equation*}
\begin{equation*}
\tyrule{let}
  { \coctx{\Gamma;\cclrd{\Delta}}{\cclrd{r}} \vdash e_1 : \tau_1 &
    \coctx{\Gamma, x\!:\!\tau_1;\cclrd{\Delta}}{\cclrd{s}} \vdash e_2 : \tau_2}
  {\coctx{\Gamma;\cclrd{\Delta}}{\cclrd{s} \;\cpar\; (\cclrd{s} \,\cseq\, \cclrd{r})} \vdash \kvd{let}~x=e_1~\kvd{in}~e_2 : \tau_2 }
\end{equation*}
\begin{equation*}
\tyrule{param}
  { ~ }
  { \coctx{\Gamma;\cclrd{\Delta}}{\cclrd{ \{ \ident{?p} \} }} \vdash \ident{?p} : \ident{num} }
\end{equation*}
\begin{equation*}
\tyrule{abs}
  {\coctx{\Gamma, x\!:\!\tau_1;\cclrd{\Delta}}{\cclrd{r}} \vdash e : \tau_2}
  {\coctx{\Gamma;\cclrd{\Delta}}{\cclrd{\Delta}} \vdash \lambda x\!:\!\tau_1.e : \tau_1 \xrightarrow{\cclrd{r}\setminus\cclrd{\Delta}} \tau_2 }
\end{equation*}
\begin{equation*}
\tyrule{letpar}
  { \coctx{\Gamma;\cclrd{\Delta}}{\cclrd{r}} \vdash e_1 : \ident{num} &
    \coctx{\Gamma;\cclrd{\Delta \cup \{ \ident{?p} \}}}{\cclrd{s}} \vdash e_2 : \tau}
  {\coctx{\Gamma;\cclrd{\Delta}}{\cclrd{r} \;\cclrd{\cup\; (\cclrd{s} \setminus \{ \ident{?p}) \}} } \vdash \kvd{let}~\ident{?p}=e_1~\kvd{in}~e_2 : \tau }
\end{equation*}

\figcaption{Choosing unique typing for implicit parameters}
\label{fig:flat-resolve-impl}
\end{figure}

%---------------------------------------------------------------------------------------------------

\subsection{Implicit parameters}
\label{sec:flat-unique-impl}

For implicit parameters we choose to follow the behaviour implemented by Haskell~\cite{app-implicit-parameters}
where function abstraction captures all parameters that are statically available at the declaration-site
and places all other demands on the call site. For the example above, this means
that the body of $f$ captures the value of \ident{?p} available from the declaration-site
and $f$ will be typed as a function requiring no parameters (coeffect $\cclrd{\emptyset}$). The
program thus evaluates to a numerical value $42$.

To express this behaviour formally, we extend the coeffect type system to additionally track
implicit parameters that are currently in static scope. The typing judgement becomes:
%
\begin{equation*}
\coctx{\Gamma;\cclrd{\Delta}}{\cclrd{r}} \vdash e : \tau
\end{equation*}
%
Here, $\cclrd{\Delta}$ is a set of implicit parameters that are in scope at the declaration-site.
The modified typing rules are shown in Figure~\ref{fig:flat-resolve-impl}. The rules (\emph{var}),
(\emph{const}), (\emph{app}) and (\emph{let}) are modified to use the new typing judgement, but they
simply propagate the information tracked by $\cclrd{\Delta}$ to all assumptions. The (\emph{param})
rule also remains unchanged -- the implicit parameter access is still tracked by the coeffect
$\cclrd{r}$ meaning that we still allow a form of dynamic binding (the parameter does not have
to be in static scope).

The most interesting rule is (\emph{abs}). The body of a function requires implicit parameters
tracked by $\cclrd{r}$ and the parameters currently in (static) scope are $\cclrd{\Delta}$.
The coeffect on the declaration site becomes $\cclrd{\Delta}$ (capture all available parameters)
and the latent coeffect attached to the function becomes $\cclrd{r\setminus\Delta}$ (require any
remaining parameters from the call site). Finally, in the (\emph{letpar}) rule, we add the newly
bound implicit parameter \ident{?p} to the static scope in the sub-expression $e_2$.

\paragraph{Properties.}
If a program written in a coeffect language with implicit parameters is well-typed in a type
system presented in Figure~\ref{fig:flat-resolve-impl} then this identifies the unique preferred
derivation for the program. We use this unique typing derivation to give the semantics of coeffect
language with implicit parameters in Chapter~\ref{ch:semantics} and we also implement this algorithm
as discussed in Chapter~\ref{ch:impl}.

The type system is more restrictive than the fully general one and it reject certain programs that
could be typed using the more general system. This is expected -- we are restricting the fully
general coeffect calculus to match the typing and semantics of implicit parameters as known from
Haskell.

In order to prove the uniqueness of typing theorem (Theorem~\ref{thm:flat-impl-unique}), we follow
the standard approach \cite{syntactic-tapl} and first give the inversion lemma (Lemma~\ref{thm:flat-impl-invert}).

\begin{lemma}[Inversion lemma for implicit parameters]
\label{thm:flat-impl-invert}
For the type system defined in Figure~\ref{fig:flat-resolve-impl}:
%
\begin{enumerate}
\raggedright
\item If $\coctx{\Gamma;\cclrd{\Delta}}{\cclrd{c}} \vdash x : \tau$ then $x : \tau \in \Gamma$ and $\cclrd{c} = \cclrd{\emptyset}$.
\item If $\coctx{\Gamma;\cclrd{\Delta}}{\cclrd{c}} \vdash n : \tau$ then $\tau = \ident{num}$ and $\cclrd{c} = \cclrd{\emptyset}$.
\item If $\coctx{\Gamma;\cclrd{\Delta}}{\cclrd{c}} \vdash e_1~e_2 : \tau_2$
 then there is some $\tau_1,\cclrd{r},\cclrd{s}$ and $\cclrd{t}$ such that
 $\coctx{\Gamma;\cclrd{\Delta}}{\cclrd{r}} \vdash e_1 : \tau_1 \xrightarrow{\cclrd{t}} \tau_2$ and
 $\coctx{\Gamma;\cclrd{\Delta}}{\cclrd{s}} \vdash e_2 : \tau_1$ and also
 $\cclrd{c} = \cclrd{r \cup s \cup t}$.
\item If $\coctx{\Gamma;\cclrd{\Delta}}{\cclrd{c}} \vdash \kvd{let}~x=e_1~\kvd{in}~e_2 : \tau_2$
 then there is some $\tau_1, \cclrd{s}$ and $\cclrd{r}$ such that
 $\coctx{\Gamma;\cclrd{\Delta}}{\cclrd{r}} \vdash e_1 : \tau_1$ and
 $\coctx{\Gamma, x\!:\!\tau_1;\cclrd{\Delta}}{\cclrd{s}} \vdash e_2 : \tau_2}$ and also
 $\cclrd{c} = \cclrd{s \cup r}$.
\item If $\coctx{\Gamma;\cclrd{\Delta}}{\cclrd{c}} \vdash \ident{?p} : \ident{num}$ then
 $\ident{?p} \in \cclrd{c}$ and $\cclrd{c} = \cclrd{ \{\ident{?p}\} }$.
\item If $\coctx{\Gamma;\cclrd{\Delta}}{\cclrd{c}} \vdash \lambda x\!:\!\tau_1.e : \tau$ then
  there is some $\tau_2$ such that $\tau = \tau_1 \xrightarrow{\cclrd{s}} \tau_2$
  ${\coctx{\Gamma, x\!:\!\tau_1;\cclrd{\Delta}}{\cclrd{r}} \vdash e : \tau_2}$ and
  $\cclrd{c} = \cclrd{\Delta}$ and also
  $\cclrd{s} = \cclrd{r\setminus\Delta}$.
\item If $\coctx{\Gamma;\cclrd{\Delta}}{\cclrd{c}} \vdash \kvd{let}~\ident{?p}=e_1~\kvd{in}~e_2 : \tau }$ then
  there is some $\cclrd{r}, \cclrd{s}$ such that
  $\coctx{\Gamma;\cclrd{\Delta}}{\cclrd{r}} \vdash e_1 : \ident{num}$ and
  $\coctx{\Gamma;\cclrd{\Delta \cup \{ \ident{?p} \}}}{\cclrd{s}} \vdash e_2 : \tau$ and also
  $\cclrd{c}=\cclrd{r} \;\cclrd{\cup\; (\cclrd{s} \setminus \{ \ident{?p}) \}}$.

\end{enumerate}
\end{lemma}
\begin{proof}
Follows from the individual rules given in Figure~\ref{fig:flat-resolve-impl}.
\end{proof}

\begin{theorem}[Uniqueness of coeffect typing for implicit parameters]
\label{thm:flat-impl-unique}
In the type system for implicit parameters defined in Figure~\ref{fig:flat-resolve-impl}, when
$\coctx{\Gamma;\cclrd{\Delta}}{\cclrd{r}} \vdash e : \tau$ and
$\coctx{\Gamma;\cclrd{\Delta}}{\cclrd{r'}} \vdash e : \tau'$ then $\tau = \tau'$ and $\cclrd{r} = \cclrd{r'}$.
\end{theorem}
\begin{proof}
Suppose that (A) $\coctx{\Gamma;\cclrd{\Delta}}{\cclrd{c}} \vdash e : \tau$ and
(B) $\coctx{\Gamma;\cclrd{\Delta}}{\cclrd{c'}} \vdash e : \tau'$. We show by induction over the typing
derivation of $\coctx{\Gamma;\cclrd{\Delta}}{\cclrd{c}} \vdash e : \tau$ that $\tau = \tau'$ and $\cclrd{c}=\cclrd{c'}$.

\vspace{0.5em}\noindent\hangindent=0.6cm
Case (\emph{abs}): $e = \lambda x\!:\!\tau_1.e_1$ and $\cclrd{c}=\cclrd{\Delta}$.
  $\tau = \tau_1 \xrightarrow{\cclrd{r}\setminus\cclrd{\Delta}} \tau_2$ for some $\cclrd{r}, \tau_2$ and also
  $\coctx{\Gamma, x\!:\!\tau_1;\cclrd{\Delta}}{\cclrd{r}} \vdash e : \tau_2}$.
  By case (6) of Lemma~\ref{thm:flat-impl-invert}, the final rule of the derivation (B) must
  have also been (\emph{abs}) and this derivation has a sub-derivation with a conclusion
  ${\coctx{\Gamma, x\!:\!\tau_1;\cclrd{\Delta}}{\cclrd{r}} \vdash e : \tau_2'}$.
  By the induction hypothesis $\tau_2 = \tau_2'$ and $\cclrd{c}=\cclrd{c'}$ and
  therefore $\tau = \tau'$.

\vspace{0.5em}\noindent\hangindent=0.7cm
Case (\emph{param}): $e = \ident{?p}$, from Lemma~\ref{thm:flat-impl-invert}, $\tau = \tau' = \ident{int}$
  and $\cclrd{c} = \cclrd{c'} = \cclrd{\{ \ident{?p} \}}$.

\vspace{0.5em}\noindent\hangindent=0.7cm
Cases (\emph{var}), (\emph{const}) are direct consequence of Lemma~\ref{thm:flat-impl-invert}.

\vspace{0.5em}\noindent\hangindent=0.7cm
Cases (\emph{app}), (\emph{let}) and (\emph{letpar})
  similarly to (\emph{abs}).
\end{proof}

\noindent
Finally, we note that unique typing derivations obtained using the type system given in
Figure~\ref{fig:flat-resolve-impl} are valid typing derivation under the original flat coeffect
type system in Figure~\ref{fig:flat-types}.

\begin{theorem}[Admisibility of unique typing for implicit parameters]
\label{thm:flat-impl-admis}
  If $\coctx{\Gamma;\cclrd{\Delta}}{\cclrd{r}} \vdash e : \tau$ (using the rules in
  Figure~\ref{fig:flat-resolve-impl}) then also $\coctx{\Gamma}{\cclrd{r}} \vdash e : \tau$
  (using the rules in Figure~\ref{fig:flat-types} and Example~\ref{ex:flat-impl}).
\end{theorem}
\begin{proof}
  Each typing rule in the unique type derivation is a special case of the corresponding
  typing rule in the flat coeffect calculus (ignoring the additional context $\cclrd{\Delta}$); the
  splitting of coeffects in (\emph{abs}) in Figure~\ref{fig:flat-resolve-impl} is a special case
  of splitting two sets using $\cclrd{\cup}$.
\end{proof}

%---------------------------------------------------------------------------------------------------

\subsection{Dataflow and liveness}
\label{sec:flat-unique-ldf}

Resolving the ambiguity for liveness and dataflow computations is easier than for implicit
parameters. It suffices to use a lambda abstraction rule that duplicates the coeffects of the
body:
%
\begin{equation*}
\tyrule{idabs}
  {\coctx{\Gamma, x\!:\!\tau_1}{\cclrd{r}} \vdash e : \tau_2}
  {\coctx{\Gamma}{\cclrd{r}} \vdash \lambda x.e : \tau_1 \xrightarrow{\cclrd{r}} \tau_2 }
\end{equation*}
%
This is the rule that we originally used for liveness and dataflow computations in
Chapter~\ref{ch:applications}. This rule cannot be used with implicit parameters and so
the additional flexibility provided by the $\czip$ operator is needed in the general flat
coeffect calculus.

For liveness and dataflow, the (\emph{idabs}) rule provides the most precise coeffect.
Assume we have a lambda abstraction with a body that has coeffects $\cclrd{r}$. The
ordinary (\emph{abs}) rule requires us to find $\cclrd{s}, \cclrd{t}$ such that
$\cclrd{r}=\cclrd{s}\,\czip\,\cclrd{t}$.

\begin{itemize}
  \item[--] For dataflow, this is $\cclrd{r}=\mathit{min}(\cclrd{s}, \cclrd{t})$. The smallest
    $\cclrd{s}, \cclrd{t}$ such that the equality holds are $\cclrd{s}=\cclrd{t}=\cclrd{r}$.
 \item[--] For liveness, this is $\cclrd{r}=\cclrd{s} \sqcup \cclrd{t}$. When $\cclrd{r}=\ident{L}$,
   the only solution is $\cclrd{s}=\cclrd{t}=\ident{L}$; when $\cclrd{r}=\ident{D}$, the most
   precise solution is $\cclrd{s}=\cclrd{t}=\ident{D}$ because $\ident{D}\sqsubseteq\ident{L}$.
\end{itemize}

The notion of ``more precise'' solution can be defined in terms of subcoeffecting and subtyping.
We return to this topic in Section~\ref{sec:flat-exts-lambda} and we also precisely characterise
for which coeffect system is the (\emph{idabs}) rule preferable over the (\emph{abs}) rule.

\paragraph{Properties.}
If a program written in a coeffect language for liveness or dataflow is well-typed according to
the type system presented in Figure~\ref{fig:flat-types} with the (\emph{abs}) rule replaced by
(\emph{idabs}), then the type system gives a unique derivation. As for implicit parameters, this
defines the semantics of coeffect program (Chapter~\ref{ch:semantics}) and it is used in the
implementation (Chapter~\ref{ch:impl}).

We note that the unique typing derivation is admissible in the original coeffect type system.
For dataflow and liveness, this follows directly from the fact that (\emph{idabs}) is a special
case of the (\emph{abs}) rule and so we do not state this explicitly as in
Theorem~\ref{thm:flat-impl-admis} for implicit parameters.

In order to prove the uniqueness of typing theorem (Theorem~\ref{thm:flat-ldf-unique}), we first
need the inversion lemma (Lemma~\ref{thm:flat-ldf-invert}).

\begin{lemma}[Inversion lemma for liveness and dataflow]
\label{thm:flat-ldf-invert}
For the type system defined in Figure~\ref{fig:flat-types} with the (abs) rule replaced
by (idabs):
%
\begin{enumerate}
\raggedright
\item If $\coctx{\Gamma}{\cclrd{c}} \vdash x : \tau$ then $x : \tau \in \Gamma$ and $\cclrd{c} = \cunit$.
\item If $\coctx{\Gamma}{\cclrd{c}} \vdash n : \tau$ then $\tau = \ident{num}$ and $\cclrd{c} = \czero$.
\item If $\coctx{\Gamma}{\cclrd{c}} \vdash e_1~e_2 : \tau_2$
 then there is some $\tau_1,\cclrd{r},\cclrd{s}$ and $\cclrd{t}$ such that
 $\coctx{\Gamma}{\cclrd{r}} \vdash e_1 : \tau_1 \xrightarrow{\cclrd{t}} \tau_2$ and
 $\coctx{\Gamma}{\cclrd{s}} \vdash e_2 : \tau_1$ and also
 $\cclrd{c} = \cclrd{r} \;\cpar\; (\cclrd{s} \,\cseq\, \cclrd{t})$.
\item If $\coctx{\Gamma}{\cclrd{c}} \vdash \kvd{let}~x=e_1~\kvd{in}~e_2 : \tau_2$
 then there is some $\tau_1, \cclrd{s}$ and $\cclrd{r}$ such that
 $\coctx{\Gamma}{\cclrd{r}} \vdash e_1 : \tau_1$ and
 $\coctx{\Gamma, x\!:\!\tau_1}{\cclrd{s}} \vdash e_2 : \tau_2}$ and also
 $\cclrd{c} = \cclrd{s} \;\cpar\; (\cclrd{s} \,\cseq\, \cclrd{r})$.
\item If $\coctx{\Gamma}{\cclrd{c}} \vdash \lambda x\!:\!\tau_1.e : \tau$ then there is some
  $\tau_2$ such that $\tau = \tau_1 \xrightarrow{\cclrd{c}} \tau_2$ and
  ${\coctx{\Gamma, x\!:\!\tau_1}{\cclrd{c}} \vdash e : \tau_2}$.
\end{enumerate}
\end{lemma}
\begin{proof}
Follows from the individual rules given in Figure~\ref{fig:flat-resolve-impl}.
\end{proof}

\begin{theorem}[Uniqueness of coeffect typing for liveness and dataflow]
\label{thm:flat-ldf-unique}
In the type system for liveness and dataflow defined in Figure~\ref{fig:flat-types} with the (abs)
rule replaced by (idabs), when $\coctx{\Gamma}{\cclrd{r}} \vdash e : \tau$ and
$\coctx{\Gamma}{\cclrd{r'}} \vdash e : \tau'$ then $\tau = \tau'$ and $\cclrd{r} = \cclrd{r'}$.
\end{theorem}
\begin{proof}
Suppose that (A) $\coctx{\Gamma}{\cclrd{c}} \vdash e : \tau$ and
(B) $\coctx{\Gamma}{\cclrd{c'}} \vdash e : \tau'$. We show by induction over the typing
derivation of $\coctx{\Gamma}{\cclrd{c}} \vdash e : \tau$ that $\tau = \tau'$ and $\cclrd{c}=\cclrd{c'}$.

\vspace{0.5em}\noindent\hangindent=0.6cm
Case (\emph{abs}): $e = \lambda x\!:\!\tau_1.e_1$. Then $\tau = \tau_1 \xrightarrow{\cclrd{c}} \tau_2$
  for some $\tau_2$ and $\coctx{\Gamma, x\!:\!\tau_1}{\cclrd{c}} \vdash e : \tau_2}$.
  By case (5) of Lemma~\ref{thm:flat-ldf-invert}, the final rule of the derivation (B) must
  have also been (\emph{abs}) and this derivation has a sub-derivation with a conclusion
  ${\coctx{\Gamma, x\!:\!\tau_1}{\cclrd{c'}} \vdash e : \tau_2'}$.
  By the induction hypothesis $\tau_2 = \tau_2'$ and $\cclrd{c}=\cclrd{c'}$ and therefore
  also $\tau = \tau'$.

\vspace{0.5em}\noindent\hangindent=0.7cm
Cases (\emph{var}), (\emph{const}) are direct consequence of Lemma~\ref{thm:flat-ldf-invert}.

\vspace{0.5em}\noindent\hangindent=0.7cm
Cases (\emph{app}) and (\emph{let}) similarly to (\emph{abs}).
\end{proof}

% ==================================================================================================
%
%    #####
%    #     # #   # #    # #####   ##    ####  ##### #  ####
%    #        # #  ##   #   #    #  #  #    #   #   # #    #
%     #####    #   # #  #   #   #    # #        #   # #
%          #   #   #  # #   #   ###### #        #   # #
%    #     #   #   #   ##   #   #    # #    #   #   # #    #
%     #####    #   #    #   #   #    #  ####    #   #  ####
%
% ==================================================================================================

\section{Syntactic equational theory}
\label{sec:flat-syntax}

Each of the concrete coeffect calculi discussed in this chapter has a different notion of context,
much like various effectful languages have different notions of effects (such as exceptions or
mutable state). However, in all of the calculi, the context has a number of common properties that
are captured by the \emph{flat coeffect algebra}. This means that there are equational properties
that hold for all of the coeffect systems. Further properties hold for systems where the context
satisfies additional properties.

In this section, we look at such shared syntactic properties. This accompanies the previous section,
which provided a \emph{semantic} justification for the axioms of coeffect algebra with a
\emph{syntactic} justification. Operationally, this section can also be viewed as providing a
pathway to an operational semantics for two of our systems (implicit parameters and liveness),
which can be based on syntactic substitution. As we discuss later, the notion of context for
dataflow is more complex.

% --------------------------------------------------------------------------------------------------

\subsection{Syntactic properties}
\label{sec:flat-syntax-props}

Before discussing the syntactic properties of general coeffect calculus formally, it should be
clarified what is meant by providing a ``pathway to operational semantics'' in this section. We do
that by contrasting syntactic properties of coeffect systems with more familiar effect systems.
Writing $\subst{e_1}{x}{e_2}$ for a standard capture-avoiding syntactic substitution, the following
equations define four syntactic reductions on the terms:
%
\begin{equation*}
\begin{array}{rllcl}
(\lambda x.e_1)~e_2 &{\reduce_{\ident{cbn}}}& \subst{e_1}{x}{e_2}   &&(\textit{call-by-name})\\
(\lambda x.e_1)~v   &{\reduce_{\ident{cbv}}}& \subst{e_1}{x}{v}     &\quad&(\textit{call-by-value})\\
e &{\reduce_\eta}& \lambda x.e~x                                    &&(\textit{$\eta$-expansion})
\end{array}
\end{equation*}
%
The rules capture syntactic reductions that can be performed in a general calculus, without any
knowledge of the specific notion of context. If the reductions preserve the type of the expression
(type preservation), then operational semantics can be defined as a repeated application of the
rules, together with additional domain-specific rules for each context-aware language, until
a specified normal form (\ie~a value) is reached.

In the rest of the section, we briefly outline the interpretation of the three
rules and then we focus on call-by-value (Section~\ref{sec:flat-syntax-cbv}) and call-by-name
(Section~\ref{sec:flat-syntax-cbn}) in more details.

The focus of this chapter is on the general coeffect system and so we do not discuss the
domain-specific reduction rules for individual context-aware language. Some work on both operational
and denotational semantics of general coeffect systems has been done by Brunel et al.
\cite{coeffects-quantitative} and Breuvart and Pagani \cite{coeffects-modelling}.
We give formal semantics of implicit parameters and dataflow in Chapter~\ref{ch:semantics} by
translation to a simple functional programming language instead.)

\paragraph{Call-by-name.}
In call-by-name, the argument is syntactically substituted for all occurrences of a variable. It
can be used as the basis for operational semantics of purely functional languages. However, using
the rule in effectful languages breaks the \emph{type preservation} property. For example, consider
a language with effect system where functions are annotated with sets of effects such as $\{ \ident{write} \}$.
A function $\lambda x.y$ is effect-free:
%
\begin{equation*}
y\!:\!\tau_1 \vdash \lambda x.y : \tau_1 \xrightarrow{\emptyset} \tau_2 \;\&\; \emptyset
\end{equation*}
%
Substituting an expression $e$ with effects $\{ \ident{write} \}$ for $y$ changes the type of
the function by adding latent effects (without changing the immediate effects):
%
\begin{equation*}
\vdash \lambda x.e : \tau_1 \xrightarrow{ \{ \ident{write} \} } \tau_2 \;\&\; \emptyset
\end{equation*}
%
Similarly to effect systems, substituting a context-dependent computation $e$ for a variable $y$ can
add latent coeffects to the function type. However, this is not the case for \emph{all} flat coeffect
calculi. For example, call-by-name reduction preserves types and coeffects for the implicit
parameters system. This means that certain coeffect systems support call-by-name evaluation strategy
and could be embedded in purely functional language (such as Haskell).

\paragraph{Call-by-value.}

The call-by-value evaluation strategy is often used by effectful languages. Here, an argument is
first reduced to a \emph{value} before performing the substitution. In effectful languages, the notion
of value is defined syntactically. For example, in the \emph{Effect} language \cite{monads-effects-marriage},
values are identifiers $x$ or functions $(\lambda x.e)$.

The notion of \emph{value} in coeffect systems differs from the usual syntactic understanding.
A function $(\lambda x.e)$ does not defer all context demands of the body $e$ and may have
immediate context demands. Thus we say that $e$ is a value if it is a value in the usual
sense \emph{and} has no immediate context demands. We define this formally in
Section~\ref{sec:flat-syntax-cbv}.

The call-by-value evaluation strategy preserves typing for a wide range of flat coeffect calculi,
including all our three examples. However, it is rather weak -- in order to use it, the domain-specific
semantics needs to provide a way for reducing a context-dependent term $\coctx{\Gamma}{\cclrd{r}} \vdash e : \tau$
to a value, \ie~a term $\coctx{\Gamma}{\cunit} \vdash e' : \tau$ with no context demands.

% --------------------------------------------------------------------------------------------------

\subsection{Call-by-value evaluation}
\label{sec:flat-syntax-cbv}

As discussed in the previous section, call-by-value reduction can be used for most flat coeffect
calculi, but it provides a very weak general model. The hard work of reducing a context-dependent
term to a \emph{value} has to be provided for each system. Syntactic values are defined
in the usual way:
%
\begin{equation*}
\begin{array}{llll}
v\in\mathit{SynVal}   & v &::=& x \sep c \sep (\lambda x.e)\\
n\in\mathit{NonVal}   & n &::=& e_1\;e_2 \sep \kvd{let}~x=e_1~\kvd{in}~e_2\\
e\in\mathit{Expr}     & e &::=& v \sep n
\end{array}
\end{equation*}
%
The syntactic form \emph{SynVal} captures syntactic values, but a context-dependency-free value in
coeffect calculus cannot be defined purely syntactically, because a function $(\lambda x.e)$ may
still have context demands -- for example a function $(\lambda x.\kvd{prev}~x)$ has an
immediate context demand $1$ (requiring 1 past value of all variables in the context).

\begin{definition}
An expression $e$ is a \emph{value}, written as $\textit{val}(e)$ if it is a syntactic value,
\ie~$e \in \mathit{SynVal}$ and it has no context-dependencies, \ie~$\coctx{\Gamma}{ \cunit } \vdash e : \tau$.
\end{definition}

\noindent
Call-by-value substitution substitutes a value, with context demands $\cunit$, for a
variable, whose access is also annotated with $\cunit$. Thus, it does not affect the type and
context demands of the term:

\begin{lemma}[Call-by-value substitution]
\label{thm:flat-subst-cbv}
In a flat coeffect calculus with a coeffect algebra $(\C, \cseq, \cpar, \czip, \cunit, \czero, \cleq)$,
given a value $\coctx{\Gamma}{\cunit} \vdash v : \sigma$ and an expression
$\coctx{\Gamma,  x\!:\!\sigma}{ \cclrd{r}  } \vdash e : \tau$, then substituting $v$ for $x$ does not
change the type and context demands, that is $\coctx{\Gamma}{ \cclrd{r} } \vdash \subst{e}{x}{v} : \tau$.
\end{lemma}
\begin{proof}
By induction over the type derivation, using the fact that $x$ and $v$ are annotated
with $\cunit$ and that variables are never removed from the set $\Gamma$ in the flat coeffect
calculus.
\end{proof}

\noindent
The substitution lemma~\ref{thm:flat-subst-cbv} holds for all flat coeffect systems. However,
proving that call-by-value reduction preserves typing requires an additional constraint on the
flat coeffect algebra, which relates the $\czip$ and $\cpar$ operations. This is captured
by the \emph{approximation} property:
%
\begin{equation*}
\cclrd{r}\,\czip\,\cclrd{t}~\;\cleq~\;\cclrd{r}\,\cpar\,\cclrd{t}
\hspace{10em}(\textit{approximation})
\end{equation*}
%
Intuitively, this specifies that the $\czip$ operation (splitting of context demands)
under-approximates the actual context capabilities while the $\cpar$ operation (combining of
context demands) over-approximates the actual context demands.

The property holds for the three systems we consider -- for implicit parameters, this is
an equality; for liveness and dataflow (which both use a lattice), the greatest lower bound
is smaller than the least upper bound.

Assuming $\reduce_{\ident{cbv}}$ is call-by-value reduction that reduces the term
$(\lambda x.e)\,v$ to a term $\subst{e}{x}{v}$, the type preservation theorem is
stated as follows:

\begin{theorem}[Type preservation for call-by-value]
\label{thm:cbv-reduction}
In a flat coeffect system satisfying the approximation property, that is
$\cclrd{r}\,\czip\,\cclrd{t}~\;\cleq~\;\cclrd{r}\,\cpar\,\cclrd{t}$,
if $\coctx{\Gamma}{\cclrd{r}} \vdash e : \tau$
and $e \reduce_{\ident{cbv}} e'$ then $\coctx{\Gamma}{\cclrd{r}} \vdash e' : \tau$.
\end{theorem}
\begin{proof}
Consider the typing derivation for the term $(\lambda x.e)\,v$ before reduction:
\begin{equation*}
\inference
  { \inference
  { \inference
      {\coctx{\Gamma, x\!:\!\tau_1}{\cclrd{r}\;\czip\;\cclrd{t}} \vdash e : \tau_2}
      {\coctx{\Gamma}{\cclrd{r}} \vdash \lambda x.e : \tau_1 \xrightarrow{\cclrd{t}} \tau_2 } &
   \coctx{\Gamma}{\cunit} \vdash v : \tau_1 }
  {\coctx{\Gamma}{\cclrd{r} \;\cpar\; (\cunit \,\cseq\, \cclrd{t})} \vdash (\lambda x.e)\,v : \tau_2} }
  {\coctx{\Gamma}{\cclrd{r} \;\cpar\; \cclrd{t}} \vdash (\lambda x.e)\,v : \tau_2}
\end{equation*}
The final step simplifies the coeffect annotation using the fact that $\cunit$ is a unit of $\cseq$.
From Lemma~\ref{thm:flat-subst-cbv}, $\subst{e}{x}{v}$ has the same coeffect annotation as $e$.
As $\cclrd{r}\,\czip\,\cclrd{t}\;\cleq\;\cclrd{r}\,\cpar\,\cclrd{t}$, we can apply subcoeffecting:
%
\begin{equation*}
\tyrule{sub}
 { \coctx{\Gamma}{\cclrd{r}\;\czip\;\cclrd{t}} \vdash \subst{e}{x}{v} : \tau_2 }
 { \coctx{\Gamma}{\cclrd{r}\;\cpar\;\cclrd{t}} \vdash \subst{e}{x}{v} : \tau_2 }
\end{equation*}
%
Comparing the final conclusions of the above two typing derivations shows that
the reduction preserves type and coeffect annotation.
\end{proof}

% --------------------------------------------------------------------------------------------------

\subsection{Call-by-name evaluation}
\label{sec:flat-syntax-cbn}

When reducing the expression $(\lambda x.e_1)~e_2$ using the call-by-name strategy, the
sub-expression $e_2$ is substituted for all occurrences of the variable $v$ in an expression $e_1$.
As discussed in Section~\ref{sec:flat-syntax-props}, the call-by-name strategy does not \emph{in
general} preserve the type of a terms in coeffect calculi, but it does preserve the typing in two
interesting cases.

Typing is preserved for different reasons in two of our systems, so we briefly review the
concrete examples. Then, we prove the substitution lemma for two special cases of flat coeffects
(Lemma~\ref{thm:cbn-substitution-top} and Lemma~\ref{thm:cbn-substitution-bot}) and finally, we
state the conditions under which typing preservation holds for flat coeffect calculi
(Theorem~\ref{thm:cbn-flat}).

\paragraph{Dataflow.}
Reducing an expression $(\lambda x.e_1)~e_2$ to  $\subst{e_1}{x}{e_2}$ does not always
preserve the type of the expression in dataflow languages. This case is similar to the example shown
earlier with effectful computations. As a minimal example, consider the substitution of
a context-dependent expression $\kvd{prev}~z$ for a variable $y$ in a function $\lambda x.y$:
%
\begin{equation*}
\begin{array}{rclcl}
 \coctx{y\!:\!\tau_1,z\!:\!\tau_1}{0} &\narrow{\vdash}& \lambda x.y : \tau_1 \xrightarrow{0} \tau_2 & & (\textnormal{before}) \\
 \coctx{z\!:\!\tau_1}{1} &\narrow{\vdash}& \lambda x.\kvd{prev}~z : \tau_1 \xrightarrow{1} \tau_2 & & (\textnormal{after}) \\
\end{array}
\end{equation*}
%
After the substitution, the coeffect of the body is $1$. The rule for lambda abstraction requires
that $1=\mathit{min}(r,s)$ and so the least solution is to set both $r,s$ to $1$. The substitution
this affects the coeffects attached both to the function type and the overall context.

Semantically, the coeffect over-approximates the actual demands -- at run-time, the code does not
actually access a previous value of the argument $x$. This fact cannot be captured by a flat coeffect
type system, but it can be captured using the structural system discussed in Chapter~\ref{ch:structural}.

\paragraph{Implicit parameters.} In dataflow, substituting $\kvd{prev}~x$ for a variable $y$ in
an expression $\lambda z.y$ changes the context demands attached to the type of the function.
This is the case not just for the preferred unique typing derivation, but for all possible typings
that can be obtained using the (\emph{abs}) rule. However, this is not the case for all
systems. Consider a substitution $\subst{\lambda x.y}{y}{\ident{?p}}$ that substitutes
an implicit parameter access $\ident{?p}$ for a free variable $y$ under a lambda:
%
\begin{equation*}
\begin{array}{rclcl}
 \coctx{y\!:\!\tau_1}{\emptyset} &\narrow{\vdash}& \lambda x.y : \tau_1 \xrightarrow{\emptyset} \tau_2 & & (\textnormal{before}) \\
 \coctx{\emptyset}{ \{\ident{?p}\} } &\narrow{\vdash}& \lambda x.\ident{?p} : \tau_1 \xrightarrow{\emptyset} \tau_2 & & (\textnormal{after}) \\
\end{array}
\end{equation*}
%
The (\emph{after}) judgement shows one possible typing of the body -- one that does not change the
coeffects of the function type and attaches all additional coeffects (implicit parameters) to the
context. In case of implicit parameters (and, more generally, systems with set-like annotations)
this is always possible.

\paragraph{Liveness.} In liveness, the type preservation also holds, but for a different reason. Consider
a substitution $\subst{\lambda x.y}{y}{e}$ that substitutes an arbitrary expression $e$ of
type $\tau_1$ with coeffects $\cclrd{r}$ for a variable $y$:
%
\begin{equation*}
\begin{array}{rclcl}
 \coctx{y\!:\!\tau_1}{\ident{L}} &\narrow{\vdash}& \lambda x.y : \tau_1 \xrightarrow{\ident{L}} \tau_2 & & (\textnormal{before}) \\
 \coctx{\emptyset}{\ident{L}} &\narrow{\vdash}& \lambda x.e : \tau_1 \xrightarrow{\ident{L}} \tau_2 & & (\textnormal{after}) \\
\end{array}
\end{equation*}
%
In the original expression, both the overall context and the function type are annotated with \ident{L},
because the body contains a variable access. An expression $e$ can always be treated as being annotated
with $\ident{L}$ (because $\ident{L}$ is the top element of the lattice) and so we can also treat $e$
as being annotated with coeffects $\ident{L}$. As a result, substitution does not change the coeffect.

\paragraph{A grand CBN reduction theorem.}
The above examples (implicit parameters and liveness) demonstrate two particular kinds of coeffect
algebra for which call-by-name reduction preserves typing. Proving the type preservation separately
provides more insight into how the systems work. We consider the two cases separately, but find a
more general formulation for both of them.

\begin{definition}
We call a flat coeffect algebra \emph{top-pointed} if $\cunit$ is the greatest (top) coeffect scalar
($\forall r \in \C \;.\; r \,\cleq\, \cunit $) and \emph{bottom-pointed} if it is the smallest (bottom)
element ($\forall r \in \C \;.\; r \,\cgeq\, \cunit $).
\end{definition}

\noindent
Liveness is an example of top-pointed coeffects as variables are annotated with
$\ident{L}$ and $\ident{D} \leq \ident{L}$, while implicit parameters and dataflow are examples
of bottom-pointed coeffects. For top-pointed flat coeffects, the substitution lemma holds without
additional demands:

\begin{lemma}[Top-pointed substitution]
\label{thm:cbn-substitution-top}
In a top-pointed flat coeffect calculus with an algebra $(\C, \cseq, \cpar, \czip, \cunit, \czero, \cleq)$,
when we substitute  an expression $e_s$ with arbitrary coeffects $\cclrd{s}$ for a variable $x$ in $e_r$,
the resulting expression is still typeable in a context with the original coeffect of $e_r$:
%
\begin{equation*}
\begin{array}{l}
 \coctx{\Gamma}{\cclrd{s}} \vdash e_s : \tau_s \;\; \wedge \;\;
   \coctx{\Gamma_1,  x : \tau_s, \Gamma_2}{ \cclrd{r}  } \vdash e_r : \tau_r\\
 \quad \Rightarrow \;\; \coctx{\Gamma_1,\Gamma,\Gamma_2}{ \cclrd{r} } \vdash \subst{e_r}{x}{e_s} : \tau_r
\end{array}
\end{equation*}
\end{lemma}

\begin{proof}
Using subcoeffecting ($\cclrd{s} \,\cleq\, \cunit$) and a variation of Lemma~\ref{thm:flat-subst-cbv}.
\end{proof}
%
\noindent
As variables are annotated with the top element $\cunit$, we can substitute the term $e_s$
for any variable and use subcoeffecting to get the original typing (because
$\cclrd{s} \,\cleq\, \cunit$).

In a bottom pointed coeffect system, substituting $e$ for $x$ increases the context
demands. However, if the system satisfies the strong condition that $\czip = \cseq = \cpar$
then the context demands arising from the substitution can be associated with the context
$\Gamma$, leaving the context demands of a function value unchanged. As a result, substitution
does not break soundness as in effect systems. The requirement $\czip = \cseq = \cpar$ holds for
our implicit parameters example (all three operators are a set union) and for other coeffect
systems that track sets of context demands discussed in Section~\ref{sec:applications-flat-distr}.
It allows the following substitution lemma:

\begin{lemma}[Bottom-pointed substitution]
\label{thm:cbn-substitution-bot}
In a bottom-pointed flat coeffect calculus with an algebra $(\C, \cseq, \cpar, \czip, \cunit, \czero, \cleq)$
where $\czip = \cseq = \cpar$ is an idempotent and commutative operation and
$\cclrd{r}\,\cleq\,\cclrd{r'} \Rightarrow \forall\cclrd{s}.\cclrd{r}\,\cseq\,\cclrd{s}\;\cleq\;\cclrd{r'}\,\cseq\,\cclrd{s}$ then:
%
\begin{equation*}
\begin{array}{l}
\coctx{\Gamma}{\cclrd{s}} \vdash e_s : \tau_s \;\; \wedge \;\;
\coctx{\Gamma_1,  x : \tau_s, \Gamma_2}{ \cclrd{r}  } \vdash e_r : \tau_r\\
\quad \Rightarrow \;\; \coctx{\Gamma_1,\Gamma,\Gamma_2}{ \cclrd{r} \,\cseq\, \cclrd{s} } \vdash \subst{e_r}{x}{e_s} : \tau_r
\end{array}
\end{equation*}

\end{lemma}
\begin{proof}
By induction over $\vdash$, using the idempotent, commutative monoid structure to keep $\cclrd{s}$ with
the free-variable context. See Appendix~\ref{sec:appendix-flat-cbn}.
\end{proof}

\noindent
The flat system discussed here is \emph{flexible enough} to let us always re-associate new context
demands (arising from the substitution) with the free-vari\-able context. In contrast, the
structural system discussed in Chapter~\ref{ch:structural} is \emph{precise enough} to keep the
coeffects associated with individual variables, thus preserving typing in a complementary way.

The two substitution lemmas discussed above show that the call-by-name evaluation strategy can be
used for certain coeffect calculi, including liveness and implicit parameters. Assuming
$\reduce_{\ident{cbn}}$ is the standard call-by-name reduction, the following theorem holds:

\begin{theorem}[Type preservation for call-by-name]
\label{thm:cbn-flat}
In a coeffect system that satisfies the conditions for Lemma~\ref{thm:cbn-substitution-top} or
Lemma~\ref{thm:cbn-substitution-bot}, if $\coctx{\Gamma}{\cclrd{r}} \vdash e : \tau$
and $e \rightarrow_{\ident{cbn}} e'$ then it is also the case that $\coctx{\Gamma}{\cclrd{r}} \vdash e' : \tau$.
\end{theorem}
\begin{proof}

For top-pointed coeffect algebra (using Lemma~\ref{thm:cbn-substitution-top}), the proof is similar
to the one in Theorem~\ref{thm:cbv-reduction}, using the facts that $\cclrd{s} \,\cleq\, \cunit$
and $r \,\czip\, t \;=\; r \,\cpar\, t$.
For bottom-pointed coeffect algebra, consider the typing derivation for the term
$(\lambda x.e_r)\,e_s$ before reduction:
%
\begin{equation*}
\inference
  { \inference
      {\coctx{\Gamma, x:\tau_s}{\cclrd{r}} \vdash e_r : \tau_r}
      {\coctx{\Gamma}{\cclrd{r}} \vdash \lambda x.e_r : \tau_s \xrightarrow{\cclrd{r}} \tau_r } &
   \coctx{\Gamma}{\cclrd{s}} \vdash e_s : \tau_s }
  {\coctx{\Gamma}{\cclrd{r} \;\cpar\; (\cclrd{s} \,\cseq\, \cclrd{r})} \vdash (\lambda x.e_r)\,e_s : \tau_r }
\end{equation*}
%
The derivation uses the idempotence of $\czip$ in the first step, followed by the
(\emph{app}) rule. The type of the term after substitution, using Lemma~\ref{thm:cbn-substitution-bot} is:
%
\begin{equation*}
\inference
  { \coctx{\Gamma, x:\tau_s}{\cclrd{r}} \vdash e_r : \tau_r &
    \coctx{\Gamma}{\cclrd{s}} \vdash e_s : \tau_s }
  { \coctx{\Gamma, x:\tau_r}{\cclrd{r}\;\cseq\;\cclrd{s}} \vdash \subst{e_r}{x}{e_s} : \tau_s }
\end{equation*}
%
From the assumptions of Lemma~\ref{thm:cbn-substitution-bot}, we know that $\cseq\,=\,\cpar$
and the operation is idempotent, so trivially:
$\cclrd{r}\;\cseq\;\cclrd{s} = \cclrd{r} \;\cpar\; (\cclrd{s} \,\cseq\, \cclrd{r})$
\end{proof}

\paragraph{Expansion theorem.}
The $\eta$-expansion (local completeness) is similar to $\beta$-reduction (local soundness) in that
it holds for some flat coeffect systems, but not for all. Out of the examples we discuss, it
holds for implicit parameters, but does not hold for liveness and dataflow.

Recall that $\eta$-expansion turns $e$ into $\lambda x.e~x$. In the case of liveness, the
expression $e$ may require no variables (both immediate and latent coeffects are marked as
$\ident{D}$). However, the resulting expression $\lambda x.e~x$ accesses a variable,
marking the context and function argument as live. In case of dataflow, the immediate coeffects
are made larger by the lambda abstraction -- the context demands of the function value are
imposed on the declaration site of the new lambda abstraction. We remedy this limitation in
the next chapter.

However, $\eta$-expansion preserves the type for implicit parameters and, more generally,
for any flat coeffect algebra where $\cpar \,=\, \czip$. Assuming $\rightarrow_\eta$
performs an expansion that turns a function-typed term $e$ to a
syntactic function $\lambda x.e~x$, the following theorem holds:

\begin{theorem}[Type preservation of $\eta$-expansion]
In a bottom-pointed flat coeffect calculus with an algebra $(\C, \cseq, \cpar, \czip, \cunit, \czero, \cleq)$
where $\czip = \cpar$, if $\coctx{\Gamma}{\cclrd{r}} \vdash e : \tau_1 \xrightarrow{\cclrd{s}} \tau_2$
and $e \rightarrow_\eta e'$ then $\coctx{\Gamma}{\cclrd{r}} \vdash e' : \tau_1 \xrightarrow{\cclrd{s}} \tau_2 $.
\end{theorem}
\begin{proof}
The following derivation shows that $\lambda x.f~x$ has the same type as $f$:
\begin{equation*}
\inference
  { \inference
    { \coctx{\Gamma}{\cclrd{r}} \vdash f : \tau_1 \xrightarrow{\cclrd{s}} \tau_2 &
      \coctx{x\!:\!\tau_1}{\cunit} \vdash x\!:\!\tau_1 }
    { \coctx{\Gamma, x\!:\!\tau_1}{\cclrd{r} \;\cpar\; (\cunit \,\cseq\, \cclrd{s}) } \vdash f~x : \tau_2 } }
  { \inference
    { \inference
      { \coctx{\Gamma, x\!:\!\tau_1}{\cclrd{r} \;\cpar\; \cclrd{s} } \vdash f~x : \tau_2 }
      { \coctx{\Gamma, x\!:\!\tau_1}{\cclrd{r} \;\czip\; \cclrd{s} } \vdash f~x : \tau_2 } }
    { \coctx{\Gamma}{ \cclrd{r} } \vdash \lambda x.f~x : \tau_1 \xrightarrow{\cclrd{s}} \tau_2 } }
\end{equation*}
%
The derivation starts with the expression $e$ and derives the type for $\lambda x.e~x$. The
application yields context demands $\cclrd{r}\,\cpar\,\cclrd{s}$. In order to recover the
original typing, this must be equal to $\cclrd{r}\,\czip\,\cclrd{s}$. Note that the derivation
shows just one possible typing -- the expression $\lambda x.e~x$ has other types -- but
this is sufficient for type preservation.
\end{proof}

\noindent
In summary, flat coeffect calculi do not \emph{in general} permit call-by-name evaluation, but
there are several cases where call-by-name evaluation can be used. Among the examples we discuss,
these include liveness and implicit parameters. Moreover, for implicit parameters the
$\eta$-expansion holds as well, giving us both local soundness and local completeness as coined
by Pfenning and Davies \cite{logic-modal-reconstruction}.



% ==================================================================================================
%
%    #######
%    #       #    # ##### ###### #    #  ####  #  ####  #    #  ####
%    #        #  #    #   #      ##   # #      # #    # ##   # #
%    #####     ##     #   #####  # #  #  ####  # #    # # #  #  ####
%    #         ##     #   #      #  # #      # # #    # #  # #      #
%    #        #  #    #   #      #   ## #    # # #    # #   ## #    #
%    ####### #    #   #   ###### #    #  ####  #  ####  #    #  ####
%
% ==================================================================================================

\section{Syntactic properties and extensions}
\label{sec:flat-exts}

The flat coeffect algebra introduced in Section~\ref{sec:flat-calculus} requires a number of axioms.
The axioms are required for three reasons -- to be able to define the categorical structure
in Section~\ref{sec:semantics-theory}, to prove equational properties in Section~\ref{sec:flat-syntax}
and finally, to guarantee intuitive syntactic properties for constructs such as
$\lambda$-abstraction and pairs in context-aware calculi.

In this section, we turn to the last point. We consider subcoeffecting and subtyping
(Section~\ref{sec:flat-exts-sub}), discuss what syntactic equivalences are permitted
by the properties of $\czip$ (Section~\ref{sec:flat-exts-lambda}) and we extend the calculus with
pairs and units and discuss their syntactic properties (Section~\ref{sec:flat-exts-tup}).

% --------------------------------------------------------------------------------------------------

\begin{figure}[t]
\begin{equation*}
\tyrule{sub-trans}
  { \tau_1 <: \tau_2 & \tau_2 <: \tau_3 }
  { \tau_1 <: \tau_3  }
\end{equation*}
\begin{equation*}
\tyrule{sub-fun}
  { \tau_1' <: \tau_1 & \tau_2 <: \tau_2' & \cclrd{r'} \cgeq \cclrd{r} }
  { \tau_1 \xrightarrow{\cclrd{r}} \tau_2 <: \tau_1' \xrightarrow{\cclrd{r'}} \tau_2' }
\end{equation*}
\begin{equation*}
\tyrule{sub-refl}
  { }
  { \tau <: \tau }
\end{equation*}

\figcaption{Subtyping rules for flat coeffect calculus}
\label{fig:flat-types-sub}
\end{figure}

% --------------------------------------------------------------------------------------------------

\subsection{Subcoeffecting and subtyping}
\label{sec:flat-exts-sub}

The \emph{flat coeffect algebra} includes the $\cleq$ relation which captures the ordering of
coeffects and can be used to define subcoeffecting. Syntactically, an expression with context
demands $\cclrd{r'}$ can be treated as an expression with a greater context. This is captured
by the (\emph{sub}) rule shown in Figure~\ref{fig:flat-types} (recall that for implicit
parameters $\cleq = \cclrd{\subseteq}$):
%
\begin{equation*}
\tyrule{sub}
  {\coctx{\Gamma}{\cclrd{r'}} \vdash e : \tau }
  {\coctx{\Gamma}{\cclrd{r}} \vdash e : \tau }\quad\quad(\cclrd{r'} \cleq \cclrd{r})
\end{equation*}
%
Semantically, when read from the consequent to the assumption, this means that we can \emph{drop}
some of the provided context. For example, if an expression requires implicit parameters
$\{ \ident{?p} \}$ it can be treated as requiring $\{ \ident{?p}, \ident{?q} \}$. The semantic
function will then be provided with a dictionary containing both assignments and it can ignore
(or even actively drop) the value for the unused parameter \ident{?q}.

Subcoeffecting only affects the immediate coeffects attached to the free-variable context.
In Figure~\ref{fig:flat-types-sub}, we add sub-typing on function types, making it possible to treat
a function with smaller context demands as a function with greater context demands:
%
\begin{equation*}
\tyrule{sub-typ}
  { \coctx{\Gamma}{\cclrd{r}} \vdash e : \tau & \tau <: \tau' }
  { \coctx{\Gamma}{\cclrd{r}} \vdash e : \tau' }
\end{equation*}
%
The definition uses the standard reflexive and transitive $<:$ operator. As the (\emph{sub-fun})
shows, the function type is contra-variant in the input and co-variant in the output. The
(\emph{sub-typ}) rule allows using sub-typing on expressions in the coeffect calculus.

%---------------------------------------------------------------------------------------------------

\subsection{Typing of let binding}
\label{sec:flat-exts-let}

Recall the (\emph{let}) rule in Figure~\ref{fig:flat-types}. It annotates the expression
$\kvd{let}~x=e_1~\kvd{in}~e_2$ with context demands $\cclrd{s}\;\cpar\;(\cclrd{s}\,\cseq\,\cclrd{r})$.
This rule can be derived from the typing derivation for an expression $(\lambda x.e_2)~e_1$ as
a special case. We use the idempotence of $\czip$ as follows:
%
\begin{equation*}
\tyrule{app}
  {\begin{array}{l}
   \vspace{-1.5em}
   \coctx{\Gamma}{\cclrd{r}} \vdash e_1 : \tau_1
   \end{array} &
   \tyruler{abs}
       { \coctx{\Gamma, x\!:\!\tau_1}{\cclrd{s}} \vdash e_2 : \tau_2 }
       { \coctx{\Gamma}{\cclrd{s}} \vdash \lambda x.e_2 : \tau_1 \xrightarrow{\cclrd{s}} \tau_2 } }
  { \coctx{\Gamma}{\cclrd{s}\;\cpar\;(\cclrd{s}\,\cseq\,\cclrd{r})} \vdash (\lambda x.e_2)~e_1 : \tau_2 }
\end{equation*}
%
This is one possible derivation, but other derivations may be valid for concrete coeffect system.
The design decision of using this particular derivation for the typing of \kvd{let} is motivated by
the fact that the typing obtained using the special rule is more precise for all the examples
consider in this chapter. To see this, assume an arbitrary splitting
$\cclrd{s} = \cclrd{s_1}\,\czip\,\cclrd{s_2}$. Table~\ref{tab:flat-simplelet}
shows the coeffect annotation derived from $(\lambda x.e_2)~e_1$, the coeffect annotation obtained
by the (\emph{let}) rule and the simplified coeffect annotation using the particular flat coeffect
algebras.

\begin{table}
\begin{center}
\begin{tabular}{ | l | c | c | c |}
\hline
& \textbf{\footnotesize Derived \hspace{1em}} & \textbf{\footnotesize Definition\hspace{1em}} & \textbf{\footnotesize Simplified\hspace{1em}} \\ \hline
\hspace{-1em}{\footnotesize Implicit parameters} & $\cclrd{s_1} \cup (\cclrd{s_2} \cup \cclrd{r})$ & $\cclrd{s} \cup (\cclrd{s} \cup \cclrd{r})$ & $\cclrd{s} \cup \cclrd{r}$ \\ \hline
\hspace{-1em}{\footnotesize Liveness} & $\cclrd{s_1} \sqcap (\cclrd{s_2} \sqcup \cclrd{r})$ & $\cclrd{s} \sqcap (\cclrd{s} \sqcup \cclrd{r})$ & $\cclrd{s}$ \\ \hline
\hspace{-1em}{\footnotesize Dataflow} & $\mathit{max}(\cclrd{s_1}, \cclrd{s_2} + \cclrd{r})$ & $\mathit{max}(\cclrd{s}, \cclrd{s} + \cclrd{r})$ & $\cclrd{s} + \cclrd{r}$ \\ \hline
\end{tabular}
\end{center}

\vspace{-0.5em}
\figcaption{Simplified coeffect annotation for let binding in three flat calculi instances}
\label{tab:flat-simplelet}
\end{table}

It is perhaps somewhat unexpected that the annotation can be simplified in different ways for
different examples. However, for all our systems, the simplified annotation (right column in
Table~\ref{tab:flat-simplelet}) is more precise than the original (left column). Recall that
$\cclrd{s} = \cclrd{s_1}\,\czip\,\cclrd{s_2}$. The following inequalities hold:
%
\begin{equation*}
\begin{array}{rclll}
\cclrd{s_1} \cup (\cclrd{s_2} \cup \cclrd{r}) &\supseteq& (\cclrd{s_1} \cup \cclrd{s_2}) \cup \cclrd{r}
  && \textnormal{(implicit parameters)}\\
\cclrd{s_1} \sqcap (\cclrd{s_2} \sqcup \cclrd{r}) &\sqsupseteq&  (\cclrd{s_1} \sqcap \cclrd{s_2})
  && \textnormal{(liveness)} \\
\mathit{max}(\cclrd{s_1}, \cclrd{s_2} + \cclrd{r}) &\geq& \mathit{min}(\cclrd{s_1}, \cclrd{s_2}) + \cclrd{r}
  &\quad& \textnormal{(dataflow)} \\
\end{array}
\end{equation*}
%
In other words, the inequality states that using idempotence, we get a more precise typing.
Using the $\cgeq$ operator of flat coeffect algebra, this property can be expressed in general as:
%
\begin{equation*}
\cclrd{s_1} \;\cpar\; (\cclrd{s_2} \,\cseq\, \cclrd{r}) \;\cgeq\;
  (\cclrd{s_1} \,\czip\, \cclrd{s_2}) \;\cpar\; ((\cclrd{s_1} \,\czip\, \cclrd{s_2}) \,\cseq\, \cclrd{r})
\end{equation*}
%
This property does not follow from the axioms of the flat coeffect algebra. To make
the flat coeffect system as general as possible, we do not \emph{in general} require it as
an additional axiom, although the above examples provide a reasonable basis for using
the specialized (\emph{let}) rule in the flat coeffect system.

% --------------------------------------------------------------------------------------------------

\subsection{Properties of lambda abstraction}
\label{sec:flat-exts-lambda}

In Section~\ref{sec:flat-calculus-lambda}, we discussed how to reconcile two typings for
lambda abstraction -- for implicit parameters, the lambda function needs to split context
demands using $\cclrd{r} \cup \cclrd{s}$, but for dataflow and liveness it suffices to
duplicate the demand $\cclrd{r}$ of the body. We consider coeffect calculi for which the
simpler duplication of coeffects is sufficient.

\paragraph{Simplified abstraction.}
Recall that $(\C, \czip)$ is a band, that is, $\czip$  is idempotent and associative. The
idempotence means that the context demands of the body can be required from both the
declaration site and the call site. In Section~\ref{sec:flat-unique-ldf}, we introduced the
(\emph{idabs}) rule (repeated below for reference), which uses the idempotence and duplicates
coeffect annotations:

\begin{equation*}
\tyrule{idabs}
  {\coctx{\Gamma, x\!:\!\tau_1}{\cclrd{r}} \vdash e : \tau_2}
  {\coctx{\Gamma}{\cclrd{r}} \vdash \lambda x.e : \tau_1 \xrightarrow{\cclrd{r}} \tau_2 }
\tyrule{abs}
  {\coctx{\Gamma, x\!:\!\tau_1}{\cclrd{r}\,\czip\,\cclrd{r}} \vdash e : \tau_2}
  {\coctx{\Gamma}{\cclrd{r}} \vdash \lambda x.e : \tau_1 \xrightarrow{\cclrd{r}} \tau_2 }
\end{equation*}
%
To derive (\emph{idabs}), we use idempotence on the body annotation $\cclrd{r}\;=\;\cclrd{r}\;\czip\;\cclrd{r}$
and then use the standard (\emph{abs}) rule. So, (\emph{idabs}) follows from (\emph{abs}),
but the other direction is not necessarily the case. The following condition identifies
coeffect calculi where (\emph{abs}) can be derived from (\emph{idabs}).

\begin{definition}
A flat coeffect algebra $(\C, \cseq, \cpar, \czip, \cunit, \czero, \cleq)$ is \emph{strictly oriented} if for all
$\cclrd{s}, \cclrd{r} \in \C$ it is the case that $\cclrd{r} \,\czip\, \cclrd{s} \;\cleq\; \cclrd{r}$.
\end{definition}

\begin{remark}
\label{thm:flat-alt-abs}
For a flat coeffect calculus with a strictly oriented algebra, equipped with subcoeffecting and
subtyping, the standard (abs) rule can be derived from the (idabs) rule.
\end{remark}
\begin{proof}
The following derives the conclusion of (\emph{abs}) using (\emph{idabs}), subcoeffecting,
sub-typing and the fact that the algebra is \emph{strictly oriented}:

\begin{equation*}
\tyrule{typ}
  {\hspace{-5em} \tyrule{sub}
     {\hspace{-4em} \tyrule{idabs}
        {\coctx{\Gamma, x\!:\!\tau_1}{\cclrd{r} \,\czip\, \cclrd{s}} \vdash e : \tau_2}
        {\coctx{\Gamma}{\cclrd{r} \,\czip\, \cclrd{s}} \vdash \lambda x.e : \tau_1 \xrightarrow{\cclrd{r} \,\czip\, \cclrd{s}} \tau_2 } }
     {\coctx{\Gamma}{\cclrd{r}} \vdash \lambda x.e : \tau_1 \xrightarrow{\cclrd{r} \,\czip\, \cclrd{s}} \tau_2} \;
           \textnormal{\footnotesize{($\cclrd{r} \;\cleq\; \cclrd{r} \,\czip\, \cclrd{s}$)}} \hspace{-5em} }
  {\coctx{\Gamma}{\cclrd{r}} \vdash \lambda x.e : \tau_1 \xrightarrow{\cclrd{s}} \tau_2} \;
           \textnormal{\footnotesize{($\cclrd{r} \;\cleq\; \cclrd{r} \,\czip\, \cclrd{s}$)}}
\end{equation*}
\end{proof}

\noindent
The practical consequence of the Remark~\ref{thm:flat-alt-abs} is that, for strictly
oriented coeffect calculi (such as our liveness and dataflow computations), the (\emph{idabs})
rule not only determines a unique typing derivation (as discussed in Section~\ref{sec:flat-unique-ldf}),
but it gives (together with subtyping and subcoeffecting) an equivalent type system.

\paragraph{Symmetry.}
The $\czip$ operation is idempotent and associative. In all of the three examples considered in
this chapter, the operation is also \emph{symmetric}. To make our definitions more general, we
do not require this to be the case for \emph{all} flat coeffect systems. However, systems with
symmetric $\czip$ have the following property.

\begin{remark}
For a flat coeffect calculus such that $\cclrd{r}\,\czip\,\cclrd{s} = \cclrd{s}\,\czip\,\cclrd{r}$,
assuming that $\cclrd{r'}, \cclrd{s'}, \cclrd{t'}$ is a permutation of $\cclrd{r},\cclrd{s},\cclrd{t}$:
%
\begin{equation*}
\inference
  {\coctx{\Gamma, x\!:\!\tau_1, y:\tau_2}{\cclrd{r} \,\czip\, \cclrd{s} \,\czip\, \cclrd{t}} \vdash e : \tau_3}
  {\coctx{\Gamma}{\cclrd{r'}} \vdash \lambda x.\lambda y.e :
      \tau_1 \xrightarrow{\cclrd{s'}} (\tau_2 \xrightarrow{\cclrd{t'}} \tau_3) }
\end{equation*}
\end{remark}

\noindent
Intuitively, this means that the context demands of a function with multiple arguments can be
split arbitrarily between the declaration site and (multiple) call sites.

% --------------------------------------------------------------------------------------------------

\begin{figure}[t]
\begin{equation*}
\tyrule{pair}
  {\coctx{\Gamma}{\cclrd{r}} \vdash e_1 : \tau_1 & \coctx{\Gamma}{\cclrd{s}} \vdash e_2 : \tau_2}
  {\coctx{\cclrd{r}\,\cpar\,\cclrd{s}}{\Gamma} \vdash (e_1, e_2) : \tau_1 \times \tau_2 }
\end{equation*}
\begin{equation*}
\tyrule{proj}
  {\coctx{\Gamma}{\cclrd{r}} \vdash e : \tau_1 \times \tau_2 }
  {\coctx{\Gamma}{\cclrd{r}} \vdash \pi_i~e : \tau_{i} }
\end{equation*}
\begin{equation*}
\tyrule{unit}
  {}
  {\coctx{\Gamma}{\czero} \vdash () : \ident{unit} }
\end{equation*}

\figcaption{Typing rules for pairs and units}
\label{fig:flat-ext-types}
\end{figure}

% --------------------------------------------------------------------------------------------------

\subsection{Language with pairs and unit}
\label{sec:flat-exts-tup}

To focus on the key aspects of flat coeffect systems, the calculus introduced in Section~\ref{sec:flat-calculus}
consists only of variables, abstraction, application and let binding. Here, we extend it with pairs
and the unit value to sketch how it can be turned into a more complete programming language and to
further motivate the axioms for $\cpar$. The syntax of the language is extended as follows:

\noindent
\begin{equation*}
\begin{array}{rcl}
e &::=& \ldots \sep () \sep e_1, e_2 \\
\tau &::=& \ldots \sep \ident{unit} \sep \tau \times \tau
\end{array}
\end{equation*}
%
The typing rules for pairs and the unit value are shown in Figure~\ref{fig:flat-ext-types}.
The unit value (\emph{unit}) is annotated with the $\czero$ coeffect (the same as other constants).
Pairs, created using the $(e_1, e_2)$ expression, are annotated with a coeffect that combines
the coeffects of the two sub-expressions using the \emph{pointwise} operator $\cpar$. The operator
models the case when the (same) available context is split and passed to two independent
sub-expressions. Finally, the (\emph{proj}) rule is uninteresting, because $\pi_i$ can be
viewed as a pure unary function.

\paragraph{Properties.}
Pairs and the unit value in a lambda calculus typically form a monoid. Assuming $\simeq$ is an
isomorphism that performs appropriate transformation on values, without affecting other
properties (here, coeffects) of the expressions. The monoid axioms then correspond to
the requirement that $(e_1, (e_2, e_3)) \simeq ((e_1, e_2), e_3)$ (associativity) and the
demand that $((), e) \simeq e \simeq (e, ())$ (unit).

Thanks to the properties of $\cpar$, the flat coeffect calculus obeys the monoid axioms for pairs.
In the following, we assume that \ident{assoc} is a pure function transforming a pair $(x_1, (x_2, x_3))$
to a pair $((x_1, x_2), x_3)$. We write $e \equiv e'$ when for all $\Gamma, \tau$ and $\cclrd{r}$,
it is the case that $\coctx{\Gamma}{\cclrd{r}} \vdash e : \tau$ if and only if
$\coctx{\Gamma}{\cclrd{r}} \vdash e' : \tau$.

\begin{remark}
\label{thm:flat-tup-eq}
For a flat coeffect calculus with pairs and units, the following holds:
%
\begin{equation*}
\begin{array}{rclcl}
 \ident{assoc}~(e_1, (e_2, e_3)) &\equiv& ((e_1, e_2), e_3) &\qquad\qquad&(\emph{associativity}) \\
 \pi_1~(e, ()) &\equiv& e &&(\emph{right unit})\\
 \pi_2~((), e) &\equiv& e &&(\emph{left unit})\\
\end{array}
\end{equation*}
\end{remark}
\begin{proof}
Follows from the fact that $(\C, \cpar, \czero)$ is a monoid and \ident{assoc}, $\pi_1$ and
$\pi_2$ are pure functions (treated as constants in the language).
\end{proof}

\noindent
The Remark~\ref{thm:flat-tup-eq} motivates the demand of the monoid structure
$(\C, \cpar, \czero)$ of the flat coeffect algebra. We require only unit and associativity
axioms. In our three examples, the $\cpar$ operator is also symmetric, which additionally
guarantees that $(e_1, e_2) \simeq (e_2, e_1)$, which is a property that is expected to hold
for $\lambda$-calculus.



% ==================================================================================================
%
%     #####
%    #     #  ####  #    #  ####  #      #    #  ####  #  ####  #    #  ####
%    #       #    # ##   # #    # #      #    # #      # #    # ##   # #
%    #       #    # # #  # #      #      #    #  ####  # #    # # #  #  ####
%    #       #    # #  # # #      #      #    #      # # #    # #  # #      #
%    #     # #    # #   ## #    # #      #    # #    # # #    # #   ## #    #
%     #####   ####  #    #  ####  ######  ####   ####  #  ####  #    #  ####
%
% ==================================================================================================
\section{Summary}

This chapter presented the \emph{flat coeffect calculus} -- a unified system for tracking
\emph{whole-context} properties of computations, that is properties related to the
execution environment or the entire context in which programs are executed.
This is the first of the two \emph{coeffect calculi} developed in this thesis.

The flat coeffect calculus is parameterized by a \emph{flat coeffect algebra} that captures
the structure of the information tracked by the type system. We instantiated the system to
capture three specific systems, namely liveness, dataflow and implicit parameters. However,
the system is more general and an capture various other applications outlined in
Section~\ref{sec:applications-flat}.

An inherent property of flat coeffect systems is the ambiguity of the typing for lambda
abstraction. The body of a function requires certain context, but the context can be often
provided by either the declaration-site or the call site. Resolving this ambiguity has to be
done differently for each concrete coeffect system, depending on its specific notion of context.
We discussed this for implicit parameters, dataflow and liveness in Section~\ref{sec:flat-unique}
and noted that the result for dataflow and liveness generalizes for any coeffect calculus
with strictly oriented coeffect algebra (Remark~\ref{thm:flat-alt-abs}).

Finally, we introduced the equational theory for flat coeffect calculus. Although each
concrete instance of flat coeffect calculus models different notion of context, there are
syntactic properties that hold for all flat coeffect systems satisfying certain additional
conditions. In particular, two \emph{type preservation} theorems prove that the operational
semantics for two classes of flat coeffect calculi (including liveness and implicit parameters)
can be based on standard call-by-name reduction.

In the next section, we move from abstract treatment of the flat coeffect calculus to a more
concrete discussion. We explain its category-theoretical motivation, we use it to define
translational semantics (akin to Haskell's ``do'' notation) and we prove a soundness result that
well-typed programs in flat coeffect calculi for implicit parameters and dataflow do not get
stuck in the translated version.
