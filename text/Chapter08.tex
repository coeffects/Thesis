\chapter{Further work}
\label{ch:further}

The prototype implementation discussed in the previous chapter directly follows the two
coeffect calculi presented in this thesis. This links together all aspects of the coeffect
theory (type system, semantics, safety proofs) and it provides practical support for the
presented theoretical work. However, the theory of coeffects could be embedded in practical
programming languages in a various ways and the theory could be further developed in a number
of different directions.

The most important alternative directions revisit three design decisions made in this thesis.
First, rather than discussing flat and structural coeffects, we can treat them in a single
unified calculus tracking both kinds of context dependence. Second, rather than using ``language
semantics'' style (Section~\ref{sec:path-sem-langs}), we could use a ``meta-language'' style
and extend the host language with explicit constructs for working with coeffects. Third,
rather than implementing a prototype coeffect language, we could embed coeffects into an
existing language using techniques inspired by Haskell's ``do'' notation.

\paragraph{Chapter structure and contributions}
\begin{itemize}
\item We start by unifying the two kinds of coeffects discussed so far. We introduce the
  \emph{unified coeffect calculus} (Section~\ref{sec:further-unified}), which generalizes flat
  and structural systems and can be instantiated to track both flat and structural properties.

\item We discuss an alternative approach to defining coeffect systems based on the meta-language
  style (Section~\ref{sec:further-meta}), which highlights the relationship between our work and
  related work arising from modal logics such as CMTT \cite{logic-cmtt}.

\item We consider a way of implementing coeffects based on embedding comonadic computations
  via a lightweight syntactic extension and a rich type systems akin to Haskell's ``do'' notation
  (Section~\ref{sec:further-impl}).

\item Finally, we discuss extensions needed for real-world source languages with constructs
  such as conditionals and further applications of coeffects arising from substructural and bunched
  logics (Section~\ref{sec:further-theory})
\end{itemize}

\noindent
The unified coeffect calculus presented in the first part of the chapter is a novel result that
completes the theory developed in this thesis. The next two sections present important future and
related work, respectively.

% ==================================================================================================

\section{The unified coeffect calculus}
\label{sec:further-unified}

The type systems of the flat coeffect calculus (Figure~\ref{fig:flat-types}) and the structural
coeffect calculus (Figure~\ref{fig:struct-types}) differ in a number of ways. Understanding the
differences is the key to reconciling the two systems:

\begin{itemize}
\item The structural coeffect calculus contains explicit rules for context manipulation
  (weakening, contraction, exchange). In the flat coeffect calculus, these rules are not defined
  explicitly, but they can be derived thanks to the fact that variables in the context can be
  freely reordered.

\item In the structural coeffect calculus, the variable context is treated as a vector
  and is annotated with a vector of (scalar) coeffects. In the flat coeffect calculus,
  the variable context is a finite partial function (from names to types) and is annotated with
  a single (scalar) coeffect.

\item In the flat coeffect calculus, we distinguish between \emph{splitting} context requirements
  and \emph{merging} of context requirements ($\cpar$ and $\czip$, respectively). In the structural
  coeffect calculus, the operations (which model appending and splitting vectors) are invertible
  and so the structural coeffect algebra uses the same tensor product $\atimes$. However, the
  $\cpar$ operation is still needed in the contraction rule.
\end{itemize}

\noindent
In the unified calculus presented in this section, we address the three differences as follows.
We include explicit rules for context manipulation in the calculus; in systems that arise from flat
calculi, the structural rules do not change coeffects and can thus be applied freely. We generalize
the structure of coeffect annotations using the notion of a ``container'' which can be specialized
to obtain a single annotation or a vector of annotations. This could potentially be used to capture
other structures such as trees in bunched typing \cite{substruct-bunched}. Finally, we distinguish
between splitting and merging of context requirements (using the notation $\apar$ and $\azip$,
respectively). For structural coeffect calculi, the two operators coincide, but for flat
coeffect calculi, they differ and provide the needed flexibility.

\subsection{Shapes and containers}
Our generalization of coeffect structure using a \emph{coeffect container} is based on containers of
Abbott et al. \cite{types-containers}. Containers have later been linked to comonads by Ahman et al.
\cite{comonads-containers}, but here we use them as part of the coeffect algebra, rather than to
provide semantics of context-aware languages.

Intuitively a container describes data
types such as lists, trees or streams. A container is formed by shapes (\eg~lengths of
lists)\footnote{Shapes can also be intuitively thought of as sizes, but this is not fully precise
as some containers may have multiple shapes of the same length, \eg~differently balanced trees.}.
For every shape, we can obtain a set of positions in the container (\eg~offsets in a list of a
specified length). More formally:

\begin{definition}
A \emph{container} consists of a pair $(S,P)$, usually written as $S \triangleleft P$.
Here, $S$ is a set of shapes and $P$ is a shape-indexed family $P : S \rightarrow \ident{Set}$
of positions.
\end{definition}

\noindent
Well-known examples of containers include lists, non-empty lists, (un\-boun\-ded) streams,
trees and the singleton data type (which contains exactly one element). Containers relevant
to our work are lists and singleton data types:

\begin{itemize}
\item The container representing lists is given by $S \triangleleft P$ where
  shapes are integers $S = \ident{Nat}$ (lengths of a list). The set of positions for a
  given length $n$ is the set of indices $P(n)= \{ 1 \ldots n \}$.

\item The container representing the singleton data type is given by $S \triangleleft P$ where
  shapes are given by a singleton set $S = \{ \ast \}$ and the set of positions for the
  shape $\ast$ contains exactly one position. To follow the intuition based on offset or
  index, we write the single position as $0$, that is $P(\ast) = \{ 0 \}$.
\end{itemize}

\noindent
In the unified coeffect calculus, the structure of coeffect annotations is defined by a
container with additional operations (discussed later) that links it with the free-variable
context $\Gamma$.

\subsection{Structure of coeffects}
In the structural coeffect calculus, the coeffect annotation was formed by a vector of coeffect
scalars. The annotations in the unified coeffect calculus are similar, but a \emph{vector} is
replaced with a more general \emph{container}. The primitive coeffect annotations in the unified
calculus are formed of \emph{coeffect scalars}. The coeffect scalars are equipped with the same
structure as in structural coeffect calculus (Definition~\ref{def:structural-scalar}). In this
section, we refer to it as \emph{\cclrd{unified coeffect scalar}} (and we repeat the definition
below). Then we define \emph{\sclrd{unified coeffect containers}} which determines how coeffect
scalar values are attached to the free-variable context. Finally, we define the
\emph{\aclrd{unified coeffect algebra}} which consists of shape-indexed coeffect scalar values.

As in the structural coeffect calculus, the contexts in the unified calculus are annotated with
shape-indexed coeffects, written as $\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e : \tau$;
functions take just a single input parameter and so are annotated with scalar coeffect values
$\sigma \xrightarrow{\cclrd{r}} \tau$.

\paragraph{Coeffect scalars.}
The following definition of the coeffect scalar structure repeats the
Definition~\ref{def:structural-scalar} from the previous chapter.

\begin{definition}
A \emph{\cclrd{unified coeffect scalar}} $(\C, \,\cseq, \,\cpar, \,\cunit, \,\czero, \,\cleq)$ is a set
$\C$ together with elements $\cunit, \,\czero \in \C$, binary operations $\cseq, \,\cpar$ such that
$(\C, \,\cseq, \,\cunit)$ and $(\C, \,\cpar, \,\czero)$ are monoids and a binary relation $\cleq$ such
that $(\C, \cleq)$ is a pre-order. That is, for all $r,s,t\in \C$:
%
\begin{equation*}
\begin{array}{ccr}
r \;\cseq\; (s \;\cseq\; t) = (r \;\cseq\; s) \;\cseq\; t  &
\cunit \;\cseq\; r = r = r \;\cseq\; \cunit &
\textnormal{(monoid)}
\\
r \;\cpar\; (s \;\cpar\; t) = (r \;\cpar\; s) \;\cpar\; t &
\czero \;\cpar\; r = r = r \;\cpar\; \czero &
\textnormal{(monoid)}
\\
\textnormal{if}~~r\; \cleq\; s ~~\textnormal{and}~~s\; \cleq\; t~~\textnormal{then}~~r\; \cleq\; t&
t\; \cleq\; t &
\textnormal{(pre-order)}
\\
\end{array}
\end{equation*}
%
The following distributivity axioms hold:
\begin{align*}
\quad (\cclrd{r}\, \cpar\, \cclrd{s}) \;\cseq\; \cclrd{t} & = (\cclrd{r} \,\cseq\, \cclrd{t}) \;\cpar\; (\cclrd{s}\, \cseq\, \cclrd{t}) \\
\quad \cclrd{t} \;\cseq\; (\cclrd{r}\, \cpar\, \cclrd{s}) & = (\cclrd{t} \,\cseq\, \cclrd{r}) \;\cpar\; (\cclrd{t}\, \cseq\, \cclrd{s})
\end{align*}
%
In addition, we require the following two properties of $\czero, \cpar$ and $\cleq$:
\begin{equation*}
\begin{array}{l}
 \quad \cclrd{r}\,\cleq\,\cclrd{r'} \; \Rightarrow \; \forall\cclrd{s}.\;(\cclrd{r}\,\cseq\,\cclrd{s})\;\cleq\;(\cclrd{r'}\,\cseq\,\cclrd{s}) \\
 \quad \czero\;\cleq\;(\czero\,\cseq\,\cclrd{r})
\end{array}
\end{equation*}
\end{definition}

\noindent
As previously, the monoid $(\C,\cseq,\cunit)$ models sequential composition; the laws guarantee
an underlying category structure; $\cunit$ and $\czero$ represent an accessed and unused variable,
respectively.

The $\cpar$ operation models combining of context requirements arising from multiple parts of a
program. The meaning depends on the coeffect container. The operation can either combine requirements
of individual variables (structural coeffects) or requirements attached to the whole context of
multiple sub-exp\-ressions (flat coeffects).

\paragraph{Coeffect containers.}
The coeffect container is a container that determines how are scalar coeffects attached to
free-variable contexts. In addition to a container $\SHP$ formed by shapes and shape-indexed positions,
the coeffect container provides a mapping that returns the shape corresponding to a free-variable context.

The mapping between the shape of the variable context and the shape of the coeffect annotation
is not necessarily bijective. For example, coeffect annotations in flat systems have just a single
shape $\SH = \{ \ast \}$.

In the coeffect judgment $\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e : \tau$, the coeffect annotation
$\aclrd{\textbf{r}}$ is drawn from the set of coeffect scalars $\C$ indexed by the shape corresponding
to $\Gamma$. We write $\sclrd{s} = \slen{\Gamma}$ for the shape corresponding to $\Gamma$. The operation
$\SP(\sclrd{s})$ returns a \emph{set} of positions and so we can write $\aclrd{\textbf{r}} \in
  \SP(\sclrd{s}) \rightarrow \C$  as a mapping from positions (defined by the shape) to scalar coeffects.
We write this as the exponent $\aclrd{\textbf{r}} \in \C^{\SP(\sclrd{s})}$.
The coeffect container is equipped with an operation that appends shapes (when concatenating
variable contexts) and two special shapes in $\SH$ representing the empty context and the singleton
context.

\begin{definition}
A \emph{\sclrd{coeffect container}} structure $(\SHP, \stimes, \sempty, \sunit, \slen{-})$
comprises a container $\SHP$ with a binary operation $\stimes$ on $\SH$ for appending shapes, a
mapping from free-variable contexts to shapes $\slen{\Gamma} \in \SH$, and elements $\sempty,\sunit \in
\SH$ such that $(\SH, \stimes, \sempty)$ is a monoid.

The elements $\sempty$ and $\sunit$ represent the shapes of the empty and the singleton free-variable
context, respectively. The $\stimes$ operation corresponds to concatenation of free-variable contexts.
Given $\Gamma_1$ and $\Gamma_2$ such that $\sclrd{s_1}=\slen{\Gamma_1}, \sclrd{s_2}=\slen{\Gamma_2}$,
we require that $\sclrd{s_1}\,\stimes\,\sclrd{s_2}=\slen{\Gamma_1, \Gamma_2}$.
\end{definition}

\noindent
As discussed earlier, we use two kinds of coeffect containers that describe the structure of vectors
(for structural coeffects) and the shape of trivial singleton container (for flat coeffects):

\begin{example}
\label{ex:further-struct-shape}
Structural coeffect container is defined as $\sclrd{(\SHP, {|}\textnormal{--}{|}, +, 0, 1)}$
where $\SH=\mathbb{N}$ and $\SP(\sclrd{n})=\{ 1 \ldots n \}$. The shape mapping ${|}\Gamma{|}$ returns the
number of variables in $\Gamma$. Empty and singleton contexts are annotated with $0$ and $1$,
respectively, and shapes of combined contexts are added so that ${|}\Gamma_1, \Gamma_2{|} =
{|}\Gamma_1{|} + {|}\Gamma_2{|}$.

Therefore, a coeffect annotation is a vector
$\aclrd{\textbf{r}} \in \C^{\SP(\sclrd{n})}$ and assigns a coeffect scalar $\aclrd{\textbf{r}}(i) \in \C$
for each position (corresponding to a variable $x_i$ in the context).
\end{example}

\begin{example}
\label{ex:further-flat-shape}
Flat coeffect container is defined as $\sclrd{(\SHP, {|}-{|}, \diamond, \sflat, \sflat)}$.
The container is defined as a singleton data type $\SH = \{\sflat \}$ and $\SP(\sflat) = \{ 0 \}$
with a constant function ${|}\Gamma{|}=\sflat$ and a trivial operation $\sflat\,\diamond\,\sflat = \sflat$.

That is, there is a single shape
$\sflat$ with a single position and all free-variable contexts have the same singleton shape.
Therefore, a coeffect annotation is drawn from $\C^{\{\sflat\}}$ which is isomorphic to $\C$
and so a coeffect scalar $\cclrd{r}\in \C$ is associated with every free-variable context.
\end{example}

\begin{example}
Similarly, we can also define a coeffect container with \emph{no} positions,
\ie~$\sclrd{(\SHP, {|}-{|}, \diamond, \sflat, \sflat)}$ where $\SH = \{\sflat \}$, $\SP(\sflat) = \emptyset$,
${|}\Gamma{|}=\sflat$ and $\sflat\,\diamond\,\sflat = \sflat$.
This reduces our system to the simply-typed $\lambda$-calculus with no context annotations, because
$\SP(\sflat)=\emptyset$ and so coeffect annotations would be from the empty set $\C^\emptyset$.
\end{example}


\paragraph{Unified coeffect algebra.}
The unified coeffect calculus annotates typing judgments with shape-indexed coeffect annotations.
The \emph{\aclrd{unified coeffect algebra}} combines a coeffect scalar and a coeffect container
to define shape-indexed coeffects and operations for manipulating these.

The definition here reconciles the third point discussed in Section~\ref{sec:further-unified} --
the fact that flat coeffects use separate operations for splitting and merging ($\cpar$ and $\czip$)
while structural coeffects use the tensor $\atimes$. In the unified calculus, we use two operators
that can, however, coincide.

\begin{definition}
Given a \cclrd{unified coeffect scalar} $(\C, \cseq, \cpar, \cunit, \czero, \cleq)$ and a
\sclrd{coeffect container} $(\SHP, \slen{-}, \stimes, \sempty, \sunit)$ a \aclrd{unified
coeffect algebra} extends the two structures with $(\azip, \apar, \azero)$ where $\azero \in \C^{\SP(\sempty)}$
is a coeffect annotation for the empty context and $\azip, \apar$ are families of operations that
combine coeffect annotations indexed by shapes. That is $\forall \sclrd{n},\sclrd{m} \in \SH$:

\begin{equation*}
\apar_{\sclrd{m},\sclrd{n}}, \azip_{\sclrd{m},\sclrd{n}} ~:~ \C^{\SP \sclrd{m}} \times \C^{\SP \sclrd{n}} \rightarrow \C^{\SP (\sclrd{m}\,\stimes\,\sclrd{n})}
\end{equation*}
\end{definition}

\noindent
A coeffect algebra induces the following three additional operations:
%
\begin{equation*}
\begin{array}{rclcrcl}
 \alift{-} &\narrow{:}& \C \rightarrow \C^{\SP(\sunit)}  \\
 \alift{\cclrd{x}} &\narrow{=}& \lambda \_ . \cclrd{x}   \\
\end{array}
\begin{array}{rclcrcl}
 \aseq_{\sclrd{m}} &\narrow{:}&  \C \times \C^{\SP(\sclrd{m})} \rightarrow \C^{\SP(\sclrd{m})}   \\
 \cclrd{r}\, \aseq\, \aclrd{\textbf{s}} &\narrow{=}& \lambda \sclrd{s} . \cclrd{r}\, \cseq\, \aclrd{\textbf{s}}(\sclrd{s}) \\
\end{array}
\begin{array}{rclcrcl}
 \alen{-} &\narrow{:}& \C^{\SP(\sclrd{m})} \rightarrow \sclrd{m}\\
 \alen{\aclrd{\textbf{r}}} &\narrow{=}& \sclrd{m}
\end{array}
\end{equation*}
%
The $\alift{-}$ operation lifts a scalar coeffect to a shape-indexed coeffect that is indexed by
the shape of a singleton context. The $\aseq_{\sclrd{m}}$ operation is a left multiplication of a
vector by a scalar. As we always use bold face for vectors and ordinary face for scalars (as well
as a distinct colour), using the same symbol is not ambiguous. We also tend to omit the subscript
$\sclrd{m}$ and write~$\aseq$.

Finally, we define $\alen{-}$ as an operation that returns the shape of a given shape-indexed
coeffect. The only purpose is to simplify notation, as we tend to avoid subscripts, but often need
to specify that shapes of variable context and coeffect match,
\eg~$\alen{\aclrd{\textbf{r}}} = \slen{\Gamma}$.

\paragraph{Splitting and merging coeffects.}
The operators $\apar$ and $\azip$ combine shape-indexed coeffects associated with two contexts.
For example, assume we have $\Gamma_1$ and $\Gamma_2$ with coeffects $\aclrd{\textbf{r}} \in
\C^{\SP(\sclrd{m})}$ and $\aclrd{\textbf{s}} \in \C^{\SP(\sclrd{n})}$. In the structural system, the
context shapes $\sclrd{m}, \sclrd{n}$ denote the number of variables in the two contexts. The
combined context $\Gamma_1, \Gamma_2$ has a shape $\sclrd{m}\,\stimes\,\sclrd{n}$ and the combined
coeffects $\aclrd{\textbf{r}} \,\azip\, \aclrd{\textbf{s}}, \aclrd{\textbf{r}} \,\apar\, \aclrd{\textbf{s}}
\in \C^{\SP(\sclrd{m} \stimes \sclrd{n})}$ are indexed by that shape.

For structural coeffect systems such as bounded reuse, both $\apar$ and $\azip$ are
just the tensor product $\times$ of vectors. For flat coeffect systems, the operations
can be defined independently, letting $\azip=\czip$ and $\apar=\cpar$.

The difference between $\azip$ and $\apar$ is clarified by the semantics (Sec\-tion~\ref{sec:further-semantics}),
where $\aclrd{\textbf{r}}\,\azip\,\aclrd{\textbf{s}}$ is an annotation of the \emph{codomain} of
a morphism that merges the capabilities provided by two contexts (in the syntactic
reading, splits the context requirements), while $\aclrd{\textbf{r}}\,\apar\,\aclrd{\textbf{s}}$
is an annotation of the \emph{domain} of a morphism that splits the capabilities of a single
context into two parts (in the syntactic reading, merges their context requirements).
Syntactically, this means that we always use $\azip$ in the rule \emph{assumptions} and
$\apar$ in \emph{conclusions}.

% --------------------------------------------------------------------------------------------------

\newcommand{\tystmt}[2]{ (\text{\footnotesize{#1}})~~{#2} }
\newcommand{\ctxtrans}[3]{ #2 \rightsquigarrow #1, #3 }
\newcommand{\ctxtransnl}[3]{ \begin{array}{l} #2 \rightsquigarrow\\ #1, #3 \end{array}}

\begin{figure}[t]

{\small a.) Syntax-driven typing rules:}
\begin{equation*}
\tyrule{var}
  { }
  {\coctx{x\!:\!\tau}{\alift{\cunit}} \vdash x : \tau }
\end{equation*}
\begin{equation*}
\tyrule{const}
  {c \!:\! \tau \in \Delta}
  {\coctx{()}{\azero} \vdash c : \tau }
\end{equation*}
\begin{equation*}
\tyrule{app}
  {\coctx{\Gamma_1}{\aclrd{\textbf{r}}} \vdash e_1 : \tau_1 \xrightarrow{\cclrd{t}} \tau_2 &
   \coctx{\Gamma_2}{\aclrd{\textbf{s}}} \vdash e_2 : \tau_1 }
  {\coctx{\Gamma_1, \Gamma_2}{\aclrd{\textbf{r}\;\apar\;(\cclrd{t} \,\aseq\, \aclrd{\textbf{s}})}} \vdash e_1~e_2 : \tau_2}
\end{equation*}
\begin{equation*}
\tyrule{abs}
  {\coctx{\Gamma, x\!:\!\tau_1}{\aclrd{\textbf{r}}\,\azip\,\alift{\cclrd{s}}} \vdash e : \tau_2}
  {\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash \lambda x.e : \tau_1 \xrightarrow{\cclrd{s}} \tau_2 }
\end{equation*}
\begin{equation*}
\tyrule{let}
  { \coctx{\Gamma_1}{\aclrd{\textbf{r}}} \vdash e_1 : \tau_1 &
    \coctx{\Gamma_2, x\!:\!\tau_1}{\aclrd{\textbf{s}}\;\azip\;\alift{\cclrd{t}}} \vdash e_2 : \tau_2}
  {\coctx{\Gamma_1, \Gamma_2}{(\cclrd{t} \,\aseq\, \aclrd{\textbf{r}}) \;\apar\; \aclrd{\textbf{s}}} \vdash \kvd{let}~x=e_1~\kvd{in}~e_2 : \tau_2 }
\end{equation*}

\vspace{1.5em}
{\small b.) Structural rules for context manipulation:}
\begin{equation*}
\tyrule{sub}
  {\coctx{\Gamma_1,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} \azip \alift{\cclrd{s'}} \azip \aclrd{\textbf{q}}} \vdash e : \tau}
  {\coctx{\Gamma_1,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} \apar \alift{\cclrd{s}} \apar \aclrd{\textbf{q}}} \vdash e : \tau}
\quad
(\cclrd{s'} \cleq \cclrd{s})
\end{equation*}
\begin{equation*}
\tyrule{weak}
  {\coctx{\Gamma}{ \aclrd{\textbf{r}} } \vdash e : \tau}
  {\coctx{\Gamma,x \!:\! \tau_1}{\aclrd{\textbf{r}} \apar \alift{ \czero }} \vdash e : \tau}
\end{equation*}
\begin{equation*}
\tyrule{exch}
  {\coctx{\Gamma_1,x\!:\!\tau_1,y\!:\!\tau_2,\Gamma_2}{\aclrd{\textbf{r}} \azip \alift{\cclrd{s}} \azip \alift{\cclrd{t}} \azip \aclrd{\textbf{q}}} \vdash e : \tau}
  {\coctx{\Gamma_1,y\!:\!\tau_2,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} \apar \alift{\cclrd{t}} \apar \alift{\cclrd{s}} \apar \aclrd{\textbf{q}}} \vdash e : \tau}
\quad
\begin{array}{l}
 \slen{\Gamma_1} = \alen{\aclrd{\textbf{r}}}\\[-0.25em]
 \slen{\Gamma_2} = \alen{\aclrd{\textbf{s}}}
\end{array}
\end{equation*}
\begin{equation*}
\hspace{2.5em}
\tyrule{contr}
  {\coctx{\Gamma_1,y\!:\!\tau_1,z\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} \azip \alift{\cclrd{s}} \azip \alift{\cclrd{t}} \azip \aclrd{\textbf{q}}} \vdash e : \tau}
  {\coctx{\Gamma_1,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} \apar \alift{\cclrd{s} \,\cpar\, \cclrd{t}} \apar \aclrd{\textbf{q}}} \vdash \subst{e}{z,y}{x} : \tau}
~
\begin{array}{l}
 \slen{\Gamma_1} = \alen{\aclrd{\textbf{r}}}\\[-0.25em]
 \slen{\Gamma_2} = \alen{\aclrd{\textbf{s}}}
\end{array}
\end{equation*}

\vspace{0.5em}
\figcaption{Type system for the unified coeffect calculus}
\label{fig:unif-types}
\end{figure}

% --------------------------------------------------------------------------------------------------

\subsection{Unified coeffect type system}
\label{sec:further-types}
The unified coeffect system in Figure~\ref{fig:unif-types} resembles the structural type system
shown in Figure~\ref{fig:struct-types}. Rather than explaining the rules one-by-one, we focus on
how the unified system differs from the structural system.

The type system for the unified coeffect calculus is parameterized by a coeffect scalar
$(\C, \cseq, \cpar, \cunit, \czero, \cleq)$ together with a coeffect algebra $(\azip, \apar, \azero)$
and the derived constructs $\alift{-}$, $\alen{-}$ and $\aseq$.
As in the structural system, free-variable contexts $\Gamma$ are treated as vectors (without duplicate
variables) with associativity built-in. The order of variables matters, but can be changed
using the exchange rule. The context annotations $\aclrd{\textbf{r}}, \aclrd{\textbf{s}}, \aclrd{\textbf{t}}$
are shape-indexed coeffects (rather than simple vectors as before). As before, functions are
annotated with coeffects scalars.

\paragraph{Syntax-driven rules.}
The (\emph{var}) rule is syntactically the same as in the structural system, but it should be read
differently. The $\alift{-}$ operation does not create a \emph{vector}, but a \emph{shape-indexed
coeffect} that returns $\cunit$ for all positions in the singleton shape $\sunit$.
The (\emph{const}) rule annotates empty context with a special annotation of the shape $\sempty$.

In a structural system, the two annotations correspond to a singleton and empty vector, respectively.
However, for a singleton shape with one position, the annotations are equivalent to annotating
variables with a scalar $\cunit$ and constants with a scalar $\czero$.

In the (\emph{app}), (\emph{abs}) and (\emph{let}) rules, the only change from the structural
system is that the vector concatenation $\atimes$ is now replaced with context splitting/merging
of the unified coeffect algebra. As already mentioned, we use splitting of context requirements $\azip$
in rule \emph{assumptions} and merging of context requirements $\apar$ in rule \emph{conclusions}.

Note that we use the terms \emph{merging} and \emph{splitting} in the syntactic (top-down) sense. As
discussed in Section~\ref{sec:flat-calculus-understanding}, we can also read
the rules in semantic (bottom-up) sense, in which case assumptions merge available contextual
information and conclusions split available contextual information.

\paragraph{Structural rules.}
The merging/splitting operations in the structural rules are changed in the same way as in the
rules above. It is also worth noting that structural coeffect system used vectors of multiple
elements. For example, $\alift{\cclrd{s},\cclrd{t}}$ and $\alift{\cclrd{t},\cclrd{s}}$ in the (\emph{exch})
rule denoted two-element vectors. In the unified system, this is replaced with merging/splitting
of two lifted scalars: $\alift{\cclrd{s}} \azip \alift{\cclrd{t}}$ and $\alift{\cclrd{t}} \apar \alift{\cclrd{s}}$.

In structural systems, the two notations mean the same thing -- we are simply concatenating or splitting two
singleton vectors. However, this generalization allows us to capture flat coeffect systems as well.
The lifting operation in flat systems simply returns the lifted scalar and operators $\azip$ and
$\apar$ correspond to operations on coeffect scalars. As discussed in Section~\ref{sec:further-flat},
thanks to the properties of coeffect scalars, contraction, weakening and exchange that do not
affect the coeffect annotation are admissible for all flat systems embedded in the unified
coeffect calculus.

% --------------------------------------------------------------------------------------------------

\subsection{Structural coeffects}
\label{sec:further-structural}

The unified coeffect system uses a general notion of context shape, but it has been designed with
structural and flat systems in mind. In this and the next section, we show how it captures
the two coeffect systems from Chapter~\ref{ch:flat} and Chapter~\ref{ch:structural}.

The unified calculus closely resembles the structural system and so using it to model structural
systems is easy -- given a coeffect scalar, we use the coeffect container that describes a \emph{vector}
of annotations (Example~\ref{ex:further-struct-shape}) and define a coeffect algebra formed by
a vector (free monoid) of scalars.

\begin{definition}
\label{def:further-struct}
Given a coeffect scalar $(\C, \cseq, \cpar, \cunit, \czero, \cleq)$ a \emph{structural coeffect system}
is defined by:

\begin{itemize}
\item A coeffect container $\sclrd{(\SHP, {|}\textnormal{--}{|}, +, 0, 1)}$ where $\SH=\mathbb{N}$ and
  $\SP(\sclrd{n})=\{ 1 \ldots n \}$ and  ${|}x_1\!:\!\tau_1,\ldots,x_n\!:\!\tau_n{|}=n$.

\item A coeffect algebra $\aclrd{(\times, \times, \epsilon)}$ where $\times$ and $\epsilon$ are
  shape-indexed versions of the binary operation and the unit of a free monoid over $\C$.
  That is $\epsilon : \C^{\SP(\sclrd{0})}$ is an empty vector and
  $\times : \C^{\SP(\sclrd{n})} \times \C^{\SP(\sclrd{m})} \rightarrow \C^{\SP(\sclrd{n + m})}$
  appends vectors.
\end{itemize}
\end{definition}

\noindent
The definition is valid since the shape operations form a monoid
$\sclrd{(\mathbb{N}, +, 0)}$ and $\slen{\textnormal{--}}$ (calculating the length of
a list) is a monoid homomorphism from the free monoid to the monoid of
shapes.

\paragraph{Properties.}
An important property of the unified system is that, when used in a structural way as discussed
above, it gives calculi with the same properties as the structural system described in
Chapter~\ref{ch:structural}. This can be easily seen by comparing the Figure~\ref{fig:unif-types}
with the Figure~\ref{fig:struct-types} and using the free monoid interpretation of the unified
coeffect algebra.

\begin{remark}
The system described in Definition~\ref{def:further-struct} is equivalent to the structural coeffect
system described in Figure~\ref{fig:struct-types}. That is, a typing derivation using a structural
coeffect embedded in the unified system is valid if and only if the corresponding derivation is
valid in the structural system.
\end{remark}

\noindent
Using the above definition, our unified coeffect system can capture per-variable coeffect properties
discussed in Section~\ref{sec:applications-structural}. This includes the system for bounded reuse
(which is only used in the structural form) and precise tracking of per-variable dataflow and liveness.

% --------------------------------------------------------------------------------------------------

\subsection{Flat coeffects}
\label{sec:further-flat}

The same unified coeffect system can be used to capture systems that track whole-context (flat)
coeffects such as implicit parameters. This is achieved using a singleton-shaped container for
coeffect annotations. The resulting system has explicit structural rules (and is syntactically
different from the standard flat coeffect system), but we show that they are equivalent.

Flat coeffect systems are characterised by a singleton set of shapes (Example~\ref{ex:further-flat-shape}).
In this setting, the context annotations $\C^{ \SP(\sflat) } = \{0\} \rightarrow \C$ are equivalent
to coeffect scalars $\C$. In addition to the coeffect scalar structure, we need to define $\apar$
and $\azip$. Our examples of flat coeffects use $\cpar$ (merging of scalar coeffects) for $\apar$
(merging of shaped coeffect annotations). The $\azip$ operation (corresponding to $\czip$
in flat coeffect calculus) needs to be provided explicitly.

\begin{definition}
\label{def:further-flat}
Given a coeffect scalar $(\C, \cseq, \cpar, \cunit, \czero, \cleq)$ and a binary operation
$\cclrd{\wedge} : \C \times \C \rightarrow \C$ such that $(\cclrd{r \wedge s}) \,\cleq\, (\cclrd{r}\,\cpar\,\cclrd{s})$,
the unified coeffect algebra modelling a flat coeffect systems consists of:
%
\begin{itemize}{}
\item A flat coeffect container $\sclrd{(\SHP, {|}-{|}, \diamond, \sflat, \sflat)}$ as defined in
  Example~\ref{ex:further-flat-shape}.

\item A flat coeffect algebra $(\czip, \cpar, \czero)$, \ie~$\apar = \cpar$
  and $\azero = \czero$ with an\\ additional binary operation $\azip = \czip$.
\end{itemize}
\end{definition}

\noindent
Intuitively, the requirement $(\cclrd{r}\,\czip\,\cclrd{s}) \;\cleq\; (\cclrd{r}\,\cpar\,\cclrd{s})$,
which could be also written as $(\aclrd{r}\,\azip\,\aclrd{s}) \;\aclrd{\leq}\; (\aclrd{r}\,\apar\,\aclrd{s})$,
denotes that splitting context requirements and then re-combining them preserves all the requirements
from the assumptions. The system may be imprecise and conclusions can overapproximate assumptions, but
it cannot lose requirements. This is fundamental for showing that exchange and contraction are admissible
in the unified system.

\paragraph{Properties.}
To show that the typing of flat properties in the unified system is equivalent to the typing in the
flat system, we show that a valid typing judgement in the first system is a valid typing judgement in
the second system and vice versa.

In one direction, we show that the unified system (capturing flat properties) permits weakening,
contraction and exchange rules that do not change the coeffect annotations. This guarantees that
a valid judgement in flat system is also valid in the unified system.

\begin{lemma}
\label{thm:further-weak}
A unified coeffect calculus capturing flat properties admits weakening that does not change the
coeffect annotation.
\end{lemma}
\begin{proof}
The rule is admissible using the following derivation:
\begin{equation*}
\inference
  { \inference
      {\coctx{\Gamma}{ \cclrd{r} } \vdash e : \tau}
      {\coctx{\Gamma,x \!:\! \tau_1}{\cclrd{r} \;\apar\; \alift{ \czero }} \vdash e : \tau} }
  { \inference
      {\coctx{\Gamma,x \!:\! \tau_1}{\cclrd{r} \,\cpar\, \czero} \vdash e : \tau}
      {\coctx{\Gamma,x \!:\! \tau_1}{\cclrd{r}} \vdash e : \tau} }
\end{equation*}

\noindent
We write $\cclrd{r}$ rather than $\aclrd{\textbf{r}}$, because we are tracking flat properties.
The first step is an application of the (\emph{weak}) rule. Next, we use the fact that
$\apar=\cpar$ and $\alift{\czero}=\czero$, which is the unit of the monoid $(\C, \cpar, \czero)$.
\end{proof}

\begin{lemma}
A unified coeffect calculus capturing flat properties admits exchange that does not change the
coeffect annotation.
\end{lemma}
\begin{proof}
We use the idempotence of $\czip$ and $\cpar$ together with the (\emph{exch}) rule:
\begin{equation*}
\inference
  { \inference
      { \inference
          {\coctx{\Gamma_1,x\!:\!\tau_1,y\!:\!\tau_2,\Gamma_2}{\cclrd{r}} \vdash e : \tau}
          {\coctx{\Gamma_1,x\!:\!\tau_1,y\!:\!\tau_2,\Gamma_2}{\cclrd{r} \,\czip\, \cclrd{r} \,\czip\, \cclrd{r} \,\czip\, \cclrd{r}} \vdash e : \tau} }
      { \coctx{\Gamma_1,x\!:\!\tau_1,y\!:\!\tau_2,\Gamma_2}{\cclrd{r} \azip \alift{\cclrd{r}} \azip \alift{\cclrd{r}} \azip \cclrd{r}} \vdash e : \tau } }
  { \inference
      {\coctx{\Gamma_1,y\!:\!\tau_2,x\!:\!\tau_1,\Gamma_2}{\cclrd{r} \apar \alift{\cclrd{r}} \apar \alift{\cclrd{r}} \apar \cclrd{r}} \vdash e : \tau}
      {\inference
         {\coctx{\Gamma_1,y\!:\!\tau_2,x\!:\!\tau_1,\Gamma_2}{\cclrd{r}\,\cpar\,\cclrd{r}\,\cpar\,\cclrd{r}\,\cpar\,\cclrd{r}} \vdash e : \tau}
         {\coctx{\Gamma_1,y\!:\!\tau_2,x\!:\!\tau_1,\Gamma_2}{\cclrd{r}} \vdash e : \tau} } }
\end{equation*}

\noindent
Using idempotence, we first duplicate the annotation $\cclrd{r}$ to get a coeffect in the form
$\cclrd{r} \azip \alift{\cclrd{r}} \azip \alift{\cclrd{r}} \azip \cclrd{r}$ as required by the
assumption of the (\emph{exch}) rule. Note that $\alift{-}$ can be added freely as
$\alift{\cclrd{r}}$ is equivalent to $\cclrd{r}$. After applying (\emph{exch}), we use
idempotence of $\apar$.
\end{proof}

\begin{lemma}
A unified coeffect calculus capturing flat properties admits contraction that does not change the
coeffect annotation.
\end{lemma}
\begin{proof}
Similarly to exchange, the proof uses idempotence of $\czip$ and $\cpar$:
\begin{equation*}
\inference
  { \inference
      {\coctx{\Gamma_1,y\!:\!\tau_1,z\!:\!\tau_1,\Gamma_2}{\cclrd{r} \czip\, \cclrd{r} \czip\, \cclrd{r} \czip\, \cclrd{r}} \vdash e : \tau}
      {\coctx{\Gamma_1,y\!:\!\tau_1,z\!:\!\tau_1,\Gamma_2}{\cclrd{r} \azip \alift{\cclrd{r}} \azip \alift{\cclrd{r}} \azip \cclrd{r}} \vdash e : \tau} }
  { \inference
      {\coctx{\Gamma_1,x\!:\!\tau_1,\Gamma_2}{\cclrd{r} \apar \alift{\cclrd{r} \,\cpar\, \cclrd{r}} \apar \cclrd{r}} \vdash \subst{e}{z,y}{x} : \tau}
      {\coctx{\Gamma_1,x\!:\!\tau_1,\Gamma_2}{\cclrd{r} \,\cpar\, \cclrd{r} \,\cpar\, \cclrd{r} \,\cpar\, \cclrd{r}} \vdash \subst{e}{z,y}{x} : \tau} }
\begin{array}{r} \\[2.5em] \qedhere \end{array}
\end{equation*}
\end{proof}

\noindent
In the last two cases, we need to turn the coeffect into a form that is required by the exchange
and contraction rules. Aside from idempotence, we could use the unit property and obtain
\eg~$\czero\,\czip\,\cclrd{r}\,\czip\,\czero\,\czip\,\czero$. However, this approach does not
work because $\cpar$ and $\czip$ may have different unit elements (in fact, we do not ever require
the existence of a unit for $\czip$).

In the other direction, we need to show that any valid judgement in the unified system (tracking
flat properties) is also valid in the flat system. The syntax-directed rules are the same in both
systems, but we need to show that any use of (explicit) weakening, contraction and exchange can be
derived in the flat system.

\begin{lemma}
Weakening, as defined in a unified coeffect calculus capturing flat properties, is admissible in
the flat coeffect calculus.
\end{lemma}
\begin{proof}
Similar to the proof in Lemma~\ref{thm:further-weak}. The property follows from the fact that
$\bot=\alift{\czero}$ is the unit of $\cpar$.
\end{proof}

\begin{lemma}
\label{thm:further-rev-contr}
Contraction, as defined in a unified coeffect calculus capturing flat properties, is admissible in
the flat coeffect calculus.
\end{lemma}
\begin{proof}
The application of (\emph{contr}) rule has the following form:
\begin{equation*}
\inference
 { \inference
    {\coctx{\Gamma_1,y\!:\!\tau_1,z\!:\!\tau_1,\Gamma_2}{\cclrd{r} \,\czip\, \cclrd{s} \,\czip\, \cclrd{t} \,\czip\, \cclrd{q}} \vdash e : \tau}
    {\coctx{\Gamma_1,y\!:\!\tau_1,z\!:\!\tau_1,\Gamma_2}{\cclrd{r} \,\azip\, \alift{\cclrd{s}} \,\azip\, \alift{\cclrd{t}} \,\azip\, \cclrd{q}} \vdash e : \tau} }
 { \inference
    {\coctx{\Gamma_1,x\!:\!\tau_1,\Gamma_2}{\cclrd{r} \,\apar\, \alift{\cclrd{s} \,\cpar\, \cclrd{t}} \,\apar\, \cclrd{q}} \vdash \subst{e}{z,y}{x} : \tau}
    {\coctx{\Gamma_1,x\!:\!\tau_1,\Gamma_2}{\cclrd{r} \,\cpar\, \cclrd{s} \,\cpar\, \cclrd{t} \,\cpar\, \cclrd{q}} \vdash \subst{e}{z,y}{x} : \tau} }
\end{equation*}
%
From Definition~\ref{def:further-flat}, we know that $(\cclrd{r} \,\czip\, \cclrd{s} \,\czip\, \cclrd{t} \,\czip\, \cclrd{q})
\;\cleq\; (\cclrd{r} \,\cpar\, \cclrd{s} \,\cpar\, \cclrd{t} \,\cpar\, \cclrd{q})$. Thus, the judgement
 can be derived using the (\emph{sub}) rule of flat coeffect calculus.
\end{proof}


\begin{lemma}
\label{thm:further-rev-exch}
Exchange, as defined in a unified coeffect calculus capturing flat properties, is admissible in
the flat coeffect calculus.
\end{lemma}
\begin{proof}
The application of (\emph{exch}) rule has the following form:
\begin{equation*}
\inference
 {\inference
    {\coctx{\Gamma_1,x\!:\!\tau_1,y\!:\!\tau_2,\Gamma_2}{\cclrd{r} \,\czip\, \cclrd{s} \,\czip\, \cclrd{t} \,\czip\, \cclrd{q}} \vdash e : \tau}
    {\coctx{\Gamma_1,x\!:\!\tau_1,y\!:\!\tau_2,\Gamma_2}{\cclrd{r} \,\azip\, \alift{\cclrd{s}} \,\azip\, \alift{\cclrd{t}} \,\azip\, \cclrd{q}} \vdash e : \tau} }
 {\inference
    {\coctx{\Gamma_1,y\!:\!\tau_2,x\!:\!\tau_1,\Gamma_2}{\cclrd{r} \,\apar\, \alift{\cclrd{t}} \,\apar\, \alift{\cclrd{s}} \,\apar\, \cclrd{q}} \vdash e : \tau}
    {\coctx{\Gamma_1,y\!:\!\tau_2,x\!:\!\tau_1,\Gamma_2}{\cclrd{r} \,\cpar\, \cclrd{t} \,\cpar\, \cclrd{s} \,\cpar\, \cclrd{q}} \vdash e : \tau} }
\end{equation*}
%
From idempotence of $\czip$, we get that $\cclrd{r} \,\czip\, \cclrd{s} \,\czip\, \cclrd{t} \,\czip\, \cclrd{q} =
\cclrd{r} \,\czip\, \cclrd{t} \,\czip\, \cclrd{s} \,\czip\, \cclrd{q}$. Thus the judgement can be derived using
(\emph{sub}) as in contraction.
\end{proof}

\noindent
A consequence of the equivalence discussed above is that the unified coeffect system can capture
all properties that can be captured by the flat coeffect system -- including implicit parameters,
rebindable resources, Haskell type classes (discussed by Orchard~\cite{comonads-dom-thesis}),
dataflow and variable liveness.



% =================================================================================================
%
%    #   #          #                    ##
%    #   #          #                     #
%    ## ##   ###   ####    ###            #     ###   # ##    ## #  #   #   ###    ## #   ###
%    # # #  #   #   #         #  #####    #        #  ##  #  #  #   #   #      #  #  #   #   #
%    #   #  #####   #      ####           #     ####  #   #   ##    #   #   ####   ##    #####
%    #   #  #       #  #  #   #           #    #   #  #   #  #      #  ##  #   #  #      #
%    #   #   ###     ##    ####          ###    ####  #   #   ###    ## #   ####   ###    ###
%                                                            #   #                #   #
%                                                             ###                  ###
% =================================================================================================

\section{Coeffect meta-language}
\label{sec:further-meta}

In Section~\ref{sec:path-sem-langs}, we discussed two ways of using monads in programming
language semantics as introduced by Moggi \cite{monad-notions}. The first approach is to use
monads in the \emph{semantics} of an effectful language. The second approach is to extend the
language with (additional) monadic constructs that can then be used for writing effectful
monads explicitly.

In this thesis, we focused on the first approach. In both flat and structural coeffect calculi,
the term language is that of a simply-typed $\lambda$-calculus, and we used (flat or structural)
indexed comonads to give the semantics for the language and to derive type system for it.

In this section, we briefly discuss the other technique. That is, we embed indexed
comonads into a $\lambda$-calculus as additional constructs. To do that, we introduce the
type constructor $\ctyp{\cclrd{r}}{\tau}$ which represents a value $\tau$ wrapped in additional
context (semantically, this corresponds to an indexed comonad) and we add language constructs
that correspond to the operations of indexed comonads. The coeffect meta-language highlights the
relationship between coeffects and closely related work on contextual modal type theory (CMTT)
\cite{logic-cmtt}. Developing the system further is also an interesting future research direction.

% -------------------------------------------------------------------------------------------------

\subsection{Coeffects and contextual modal type theory}

As discussed in Section~\ref{sec:path-sem-contextdep}, context-aware computations are related
to modal logics -- comonads have been used to model the $\square$ modality and as a basis for
meta-languages that include $\square$ as a type constructor
\cite{logic-intuitionistic-modal,logic-modal-reconstruction,logic-intuitionistic-modal,logic-cmtt}.
Nanevski et al. \cite{logic-cmtt} extend an S4 term language to a contextual modal type theory (CMTT).
From the perspective of this thesis, CMTT can be viewed as a \emph{meta-language} version of our
coeffect calculus.

\paragraph{Context in CMTT and coeffects.}
Aside from the fact that coeffect calculi use comonads for \emph{semantics} and CMTT embeds
comonads (the $\square$ modality) into the meta-language, there are two important differences.

Firstly, the \emph{context} in CMTT is a set of variables required by a computation, which
makes CMTT useful for meta-programming and staged computations. In coeffect calculi, the context
requirements are formed by an abstract coeffect algebra, which is more general and can capture
variable contexts, but also integers, two-point lattices, etc.

Secondly, CMTT uses different intuitive understanding of the comonad (type constructor) and
the associated operations. In categorical semantics of coeffect calculi, the $\ctyp{\cclrd{r}}{\tau}$
constructor refers to a value of type $\tau$ \emph{together} with additional context specified
by the coeffect annotation $\cclrd{r}$ (\eg~a list of past values or additional resources).

In contrast in CMTT\footnote{To avoid using different notations, we write $\ctyp{\Psi}{\tau}$ instead of the
original $[\Psi]{\tau}$} the type $\ctyp{\Psi}{\tau}$ models a value that \emph{requires} the
context $\Psi$ in order to produce value $\tau$. This also changes the interpretation of the
two operations of a comonad:
\begin{equation*}
\begin{array}{rcl}
 \ident{counit} &\narrow{:}& \ctyp{\cunit}{\alpha} \rightarrow \alpha\\
 \ident{cobind} &\narrow{:}& (\ctyp{\cclrd{r}}{\alpha} \rightarrow \beta) \rightarrow
    \ctyp{\cclrd{r}\cseq\cclrd{s}}{\alpha} \rightarrow \ctyp{\cclrd{s}}{\beta}
\end{array}
\end{equation*}
Two readings of the signatures are possible, but they give quite different meanings to the operations:

\begin{itemize}
\item \textsc{Coeffect interpretation.} The \ident{counit} operation extracts a value
  and does not require any additional context; the \ident{cobind} operation requires
  context $\cclrd{r}\,\cseq\,\cclrd{s}$, uses the part specified by $\cclrd{r}$ to
  evaluate the function, ending with a value $\beta$ together with remaining context
  $\cclrd{s}$.
\item \textsc{CMTT interpretation.} The \ident{counit} operation evaluates a computation
  that requires no additional context to obtain a $\alpha$ value; given a function that
  turns a computation requiring context $\cclrd{r}$ into a value $\beta$, the \ident{cobind}
  operation can turn a computation that requires context $\cclrd{r}\,\cseq\,\cclrd{s}$
  into a computation that requires just $\cclrd{s}$ and contains $\beta$ (a part of the
  context requirements is eliminated by the function).
\end{itemize}

\noindent
Although the different reading does not affect formal properties of the systems, it is important
to understand the difference when discussing the two systems as they provide a different
intuition.

The sketch of a coeffect meta-language in the following section attempts to bridge the gap
between coeffects and CMTT. Just like CMTT, it embeds comonads as language constructs, but
it annotates them with a (flat) coeffect algebra, thus it generalizes CMTT which tracks only
sets of variables. Future work on the coeffect meta-language would thus be an interesting
development for both coeffect systems and CMTT.

% -------------------------------------------------------------------------------------------------

\subsection{Coeffect meta-language}

The coeffect meta-language could be designed using both flat and structural indexed comonads.
For simplicity, this section only discusses the flat variant. The syntax of types and terms
of the language includes the type constructor $\ctyp{\cclrd{r}}{\tau}$ and four additional
language constructs:
%
\begin{equation*}
\begin{array}{rcl}
 \tau &\narrow{::=}& \alpha \sep \tau_1 \rightarrow \tau_2 \sep \ctyp{\cclrd{r}}{\tau}\\
 e &\narrow{::=}& v \sep \lambda x.e \sep e_1~e_2 \sep !e    \\[-0.25em]
  &        \sep& \kvd{let\;box}~x=e_1~\kvd{in}~e_2           \\[-0.25em]
  &        \sep& \kvd{split}~e_1~\kvd{into}~x,y~\kvd{in}~e_2 \\[-0.25em]
  &        \sep& \kvd{merge}~e_1, e_2~\kvd{into}~x~\kvd{in}~e_2
\end{array}
\end{equation*}
%
The $!e$ and $\kvd{let\;box}$ constructs correspond to the \ident{counit} and \ident{cobind}
operation of the comonad. To define meta-language for flat indexed comonads, we also include
\kvd{split} and \kvd{merge} that embed the corresponding operations.

\paragraph{Types for coeffect meta-language.}
The type system for the language is shown in Figure~\ref{fig:conclusions-cml}. The first part
shows the usual typing rules for simply-typed $\lambda$-calculus. For simplicity, we omit typing
rules for pairs, but those need to be present as the \kvd{merge} operation works on tuples.

The second part of the typing rules is more interesting. The (\emph{counit}) operation extracts
a value from a comonadic context and corresponds to variable access in coeffect calculi. The
\kvd{let\;box} construct (\emph{cobind}) takes an input $e_1$ with context $\cclrd{r}\,\cseq\,\cclrd{s}$
and a computation that turns a variable $x$ with a context $\cclrd{r}$ into a value $\tau_2$.
The result is a computation that produces a $\tau_2$ value with the remaining context specified
by $\cclrd{s}$. Note that the expressions $e_2$ and $e_1$ correspond to the first and second
arguments of the \ident{cobind} operation. The keyword \kvd{let\;box} is chosen following
CMTT\footnote{The rule is similar to the \ident{letbox} rule for ICML \cite[p. 14]{logic-cmtt},
although it differs because of our generalization of comonads where \ident{bind} composes
coeffect annotations rather than requiring the same annotation everywhere.}.

The \kvd{split} and \kvd{merge} constructs follow a similar pattern. They both apply some
transformation on one or two values in a context and then add the new value as a fresh variable
to the variable context. We omit subcoeffecting, but it could be easily added following
the method used elsewhere.

% -------------------------------------------------------------------------------------------------

\begin{figure}[t]

{\small a.) Typing rules for the simply typed $\lambda$-calculus}

\begin{equation*}
\tyrule{var}
  {x : \tau \in \Gamma}
  {\Gamma \vdash x : \tau }
\end{equation*}
\begin{equation*}
\tyrule{app}
  {\Gamma \vdash e_1 : \tau_2 \rightarrow \tau_1 &
   \Gamma \vdash e_2 : \tau_2 }
  {\Gamma \vdash e_1~e_2 : \tau_1 }
\end{equation*}
\begin{equation*}
\tyrule{abs}
  {\Gamma, x:\tau_1 \vdash e : \tau_2}
  {\Gamma \vdash \lambda x.e : \tau_1 \rightarrow \tau_2 }
\end{equation*}

\vspace{1em}
{\small b.) Additional typing rules arising from \emph{flat indexed comonads}}

\begin{equation*}
\tyrule{cobind}
  {\Gamma \vdash e_1 : \ctyp{\cclrd{r}\,\cseq\,\cclrd{s}}{\tau_1} & \Gamma, x : \ctyp{\cclrd{r}}{\tau_1} \vdash e_2 : \tau_2 }
  {\Gamma \vdash \kvd{let\;box}~x=e_1~\kvd{in}~e_2 : \ctyp{\cclrd{s}}{\tau_2}}
\end{equation*}
\begin{equation*}
\tyrule{counit}
  {\Gamma \vdash e : \ctyp{\cunit}{\tau}}
  {\Gamma \vdash !e : \tau}
\end{equation*}
\begin{equation*}
\tyrule{split}
  {\Gamma \vdash e_1 : \ctyp{\cclrd{r}\,\cpar\,\cclrd{s}}{\tau_1} &
   \Gamma, x:\ctyp{\cclrd{r}}{\tau_1}, y:\ctyp{\cclrd{s}}{\tau_1} \vdash e_2 : \tau_2 }
  {\Gamma \vdash \kvd{split}~e_1~\kvd{into}~x,y~\kvd{in}~e_2 : \tau_2 }
\end{equation*}
\begin{equation*}
\tyrule{merge}
  {\Gamma \vdash e_1 : \ctyp{\cclrd{r}}{\tau_1} &
   \Gamma \vdash e_2 : \ctyp{\cclrd{s}}{\tau_2} \\
   \Gamma, x:\ctyp{\cclrd{r}\,\czip\,\cclrd{s}}{(\tau_1 \times \tau_2)} \vdash e_2 : \tau_3 }
  {\Gamma \vdash \kvd{merge}~e_1, e_2~\kvd{into}~x~\kvd{in}~e_2 : \tau_3 }
\end{equation*}

\figcaption{Type system for the (flat) coeffect meta-language}
\label{fig:conclusions-cml}
\end{figure}

% -------------------------------------------------------------------------------------------------

\subsection{Embedding flat coeffect calculus}

The \emph{meta-language} approach of embedding comonads in a language is more general than the
\emph{semantics} approach. This thesis focuses on a narrower use that better guides the design of
a type system for context-aware programming languages.

However, it is worth demonstrating that the (flat) coeffect calculus can be embedded in the
meta-language described in the previous section. This may be desirable, \eg~when using the
meta-language for reasoning about context-aware computations. We briefly consider the embedding
as it illuminates the relationship between coeffects and CMTT (unfortunately it is not possible
to embed coeffect calculi in CMTT because of the more general annotations structure).

Given a typing judgement $\coctx{\Gamma}{\cclrd{r}} \vdash e : \tau$ in the flat coeffect calculus,
we define $\sem{\coctx{\Gamma}{\cclrd{r}} \vdash e : \tau}_v$ as its embedding in the coeffect
meta-language. Note that the translation is indexed by $v$, which is a name of variable used
to represent the entire variable context of the source language. The translation is defined in
Figure~\ref{fig:conclusions-embed}. The embedding resembles the semantics discussed in
Section~\ref{sec:flat-semantics}. This is not surprising as the meta-language directly mirrors
the operations of an indexed comonad.

% -------------------------------------------------------------------------------------------------

\begin{figure}[t]
\begin{equation*}
\begin{array}{l}
 \sem{ \coctx{\Gamma}{\cunit}\vdash x_i : \tau_i }_v = \pi_i (!v) \\[0.25em]
 \sem{ \coctx{\Gamma}{\cclrd{r}\;\cpar\;(\cclrd{s}\,\cseq\,\cclrd{t})} \vdash e_1~e_2 : \tau_2 }_v =\\[-0.25em]
   \qquad \kvd{split}~v~\kvd{into}~v_s, v_{rt}~\kvd{in} \\[-0.25em]
   \qquad \sem{ \coctx{\Gamma}{\cclrd{s}} \vdash e_1 : \tau_1 \xrightarrow{\cclrd{t}} \tau_2 }_{v_s}
      ~(\kvd{let\;box}~v_r = v_{rt}~\kvd{in}~\sem{ \coctx{\Gamma}{\cclrd{r}} \vdash e_2 : \tau_1}_{v_r}) \\[0.25em]
 \sem{ \coctx{\Gamma}{\cclrd{r}} \vdash \lambda x.e:\tau_1 \xrightarrow{\cclrd{s}} \tau_2 }_v = \lambda x. \\[-0.25em]
   \qquad \kvd{merge}~v,x~\kvd{into}~v_{rs}~\kvd{in}~\sem{ \coctx{(\Gamma,x:\tau_1)}{\cclrd{r}\,\czip\,\cclrd{s}} \vdash e : \tau_2 }_{v_{rs}}
\end{array}
\end{equation*}
\figcaption{Embedding flat coeffect calculus in coeffect meta-language }
\label{fig:conclusions-embed}
\end{figure}


% =================================================================================================
%
% 	 #####                 #     #                                                #
% 	 #                     #     #                                                #
% 	 #      #   #  # ##   ####   # ##    ###   # ##          #   #   ###   # ##   #   #
% 	 ####   #   #  ##  #   #     ##  #  #   #  ##  #         #   #  #   #  ##  #  #  #
% 	 #      #   #  #       #     #   #  #####  #             # # #  #   #  #      ###
% 	 #      #  ##  #       #  #  #   #  #      #             # # #  #   #  #      #  #
% 	 #       ## #  #        ##   #   #   ###   #              # #    ###   #      #   #
%
% =================================================================================================

\section{Related and future work}
\label{sec:further-further}

Most of the related and future work has been discussed throughout the thesis. This section summarizes
two interesting directions for future work and the related work in the area. First, we look at a way of
embedding coeffects in existing languages such as Haskell that is inspired by the Haskell's ``do'' notation
(Section~\ref{sec:further-impl}). Second, we discuss extensions to the theory of coeffects that
are needed for real-world programming languages and we consider how the system could be extended
to generalize languages based on substructural and bunched logics (Section~\ref{sec:further-theory}).

\subsection{Embedded context-aware DSLs}
\label{sec:further-impl}

Many of the examples of contextual computation that we discussed earlier have been implemented as
a single-purpose programming language feature (\eg~implicit parameters \cite{app-implicit-parameters}
or distributed computations \cite{app-distributed-ml5,app-distributed-links}). However,
the main contribution of this thesis is that it captures
\emph{multiple} different notions of context-aware computations using just a \emph{single}
common abstraction. For this reason, future practical implementations of coeffects should not be
single-purpose language features, but rather reusable abstractions that
can be instantiated with a concrete \emph{coeffect algebra} specified by the user.
One approach towards this goal is to build a specialized context-aware language such as the
one implemented in Chapter~\ref{ch:impl}. An alternative method is to embed context-aware
DSLs into a richer target functional language.

In order to do this, the target programming language needs to provide two features; one that allows
embedding of context-aware computations themselves in programs akin to the ``do'' notation
in Haskell and one that allows tracking of the contextual information in the type system.

% -------------------------------------------------------------------------------------------------

\paragraph{Embedding contextual computations}

The embedding of \emph{contextual} computations into programming languages can follow the successful
model of \emph{effectful} computations. In purely functional programming languages such as Haskell,
effectful computations are embedded by \emph{implementing} their model within the language
and inserting the necessary (monadic) plumbing. This is made easier by the ``do'' notation or
monad comprehensions \cite{other-haskell98,monads-compre}, which insert the monadic operations
automatically.

The recently proposed ``codo'' notation \cite{comonads-codo} provides similar automation for
context-aware computations based on comonads. The notation follows the semantics of our
flat coeffect calculus (Chapter~\ref{ch:flat}). Extending the ``codo'' notation to support calculi based
on the structural coeffect calculus (Chapter~\ref{ch:structural}) is an interesting future work --
this would require explicitly manipulating individual context variables and application of structural
rules, which is not needed in flat coeffects.

In ML-like languages, effects (and many coeffects) are built-in into the language semantics,
but they can still benefit from a special notation for explicitly marking effectful (coeffectful)
blocks of code. In F\#, this is done using \emph{computation expressions}  \cite{app-computation-zoo}
that differ from the ``do'' notation in two ways. First, they support wider range of
constructs, making it possible to wrap existing F\# code within a block without other changes.
Second, they support other abstractions including monads, applicative functors and monad
transformers. It would be interesting to see if computation expressions can be extended to
support programming with computations based on flat/structural indexed comonads.

More lightweight syntax for effectful computation can be obtained using
techniques that automatically insert the necessary monadic plumbing (without
special syntax). This has been done for effectful computations \cite{monads-lightweight-ml}
and a similar approach would be worth exploring for coeffects.

% -------------------------------------------------------------------------------------------------

\paragraph{Coeffect annotations as types}

The other aspect of practical implementation of coeffects is that of tracking the context requirements
(coeffect annotations) in the type system. To achieve this (without resorting to a single-purpose
language feature) the type system needs to be able to capture various kinds of coeffect algebras.
The structures required in this thesis include sets (with union or intersection), natural numbers (with
addition, maximum, minimum and multiplication), two-point lattice (for liveness) and free monoids
(vectors of annotations).

In a joint work on embedding effect systems in Haskell \cite{effects-embedding}, we demonstrated that
the recent additions to the Haskell type system provide enough power to implement structures such
as sets at the type level. Using these to embed coeffect systems in Haskell is one fruitful
future direction for implementing applied context-aware languages.

In dependently-typed languages such as Agda or Idris \cite{other-agda,other-idris},
the embedding of coeffects can be implemented more directly (as terms implementing sets or lattices
can be lifted to the type level). However, we believe that coeffect tracking does not require full
dependent types and can be made accessible in more mainstream languages. Dependent ML
\cite{types-dependent-ml} provides an interesting example of a language with some dependent typing
(\eg~computations with integers) which is still close to its non-dependently-typed predecessor ML.

Another approach for embedding computations into the type system has been pioneered by F\#
\emph{type providers} \cite{app-inforich}. Technically, type providers are compiler extensions
that generate types based on external data sources or other information in order to provide easy
access to data or services. A similar approach could be used for embedding \emph{algebras} such
as coeffect algebras into the type system. An \emph{algebra provider} would then be a library that
specifies the objects of the algebra, its equational laws and generalization rules for type inference.
This could provide an easy-to-use way of embedding coeffect tracking in pragmatic languages
such as F\#. It is worth noting that the mechanism could also subsume F\# units of measure
\cite{types-units-of-measure}; these could be alternatively provided via one such \emph{algebra
provider}.


% -------------------------------------------------------------------------------------------------

\subsection{Extending the theory of coeffects }
\label{sec:further-theory}

\paragraph{Richer coeffect languages.}
The coeffect calculi presented in this thesis are based on a simple $\lambda$-calculus, comprising
variables, lambda abstraction, application and let-binding. This lets us focus on fundamental
properties of coeffect systems (and explain how coeffect system differ from better-known effect
systems), but it is hardly sufficient for a realistic programming language.

Further work is to extend the coeffect systems presented here to a full programming language. A
useful reference is the work of Nielson and Nielson~\cite{effects-nielson} who consider a
similar development for effect systems, adding conditionals, recursion and polymorphism.

Coeffect annotations in context-aware programming languages can contain significant amount
of information. Thus, the programming language also needs a form of type inference that can propagate
such information. This has been done for effect systems \cite{effects-polymorphic}. For coeffects,
the prototype implementation discussed in Chapter~\ref{ch:impl} provides basic support for
type inference, however formal treatment of the algorithm is left to future work.

% -------------------------------------------------------------------------------------------------

\paragraph{Language semantics.}

As discussed in Section~\ref{sec:path-sem}, comonads can be used to define the semantics of a
programming language in two ways. The first, ``language semantics'', approach is to use a
single comonad to describe the semantics of a specific context-aware property. The second,
``meta-language'' approach is to extend the language with explicit constructs representing the
operations of the underlying comonad.

The categorical semantics in this thesis used the ``language semantics'' style, but mainly as a
guide for the development of the type systems. Further work includes more precise treatment of
the categorical structure of indexed comonads. This has partly been done for flat coeffects by
Orchard~\cite{comonads-dom-thesis}. A joint work with Orchard~\cite{coeffects-icfp14} shows the
first steps for structural systems. As discussed in Section~\ref{sec:unified-semantics}, further
work is to develop a similar categorical model for the unified coeffect calculus, possibly using
the categorical notion of containers \cite{types-containers}.

We briefly outlined a calculus based on the ``meta-language'' approach in Section~\ref{sec:unified-meta}.
Developing this technique further could unify coeffect systems with the work on Contextual Modal
Type-Theory (CMTT) \cite{logic-cmtt} and allow other interesting applications of coeffects such
as meta-programming \cite{logic-cmtt} and distributed computing with explicit modalities \cite{app-distributed-ml5}.

% -------------------------------------------------------------------------------------------------

\paragraph{Substructural and bunched logics.}

In the \emph{flat} and \emph{structural} coeffect calculi, we attach annotations to the \emph{entire
context} and to \emph{individual variables}, respectively. We later unified the two systems
in Section~\ref{sec:unified-unified}.

An intriguing question is whether coeffects can generalize \emph{bunched typing} \cite{substruct-bunched},
which uses a tree-like structure of variable contexts (also discussed in Section~\ref{sec:path-logic}).
The definition of the \emph{unified coeffect calculus} is likely not expressive enough -- bunched
typing requires tree-like variable context, while we use a vector. Furthermore, bunched typing
annotates internal nodes of the tree (sub-contexts are combined using ``;'' or using ``,'') rather
than just variables. Finding a simple coeffect system that is capable of capturing bunched typing
is thus an interesting further work. Indeed, this could lead to numerous uses of coeffects as
bunched typing is the basis for widely-used separation logic \cite{substruct-separation-logic}.



% ==================================================================================================
%
%        ###                         ##                    #
%       #   #                         #
%       #       ###   # ##    ###     #    #   #   ###    ##     ###   # ##    ###
%       #      #   #  ##  #  #   #    #    #   #  #        #    #   #  ##  #  #
%       #      #   #  #   #  #        #    #   #   ###     #    #   #  #   #   ###
%       #   #  #   #  #   #  #   #    #    #  ##      #    #    #   #  #   #      #
%        ###    ###   #   #   ###    ###    ## #  ####    ###    ###   #   #  ####
%
% ==================================================================================================

\section{Summary}

In this chapter, we looked at three alternative directions for further development of coeffects.
The key technical contribution of this chapter is the \emph{unified coeffect system}
(Section~\ref{sec:further-unified}), which unifies the flat and structural system presented
in the previous two chapters. This provides an alternative to the separate treatment of
per-context and per-variable contextual dependencies at the cost of making the system more
complex. To unify the two, we introduced \emph{coeffect container}, which determines how are
coeffect annotations attached to variable contexts. We then discussed two
instances of the structure that capture flat and structural properties.

Next, we discussed how our work relates to meta-language based on comonads (Section~\ref{sec:further-meta}).
We present a \emph{coeffect meta-language} that extends a simple functional programming language
with additional language constructs corresponding to contextual operations. This is similar to the
target languages used in the translational semantics in Chapter~\ref{ch:semantics}, but it follows
a notation similar to the one used by contextual modal type theory (CMTT). This elucidates the
relationship between our work and CMTT.

Finally, we considered an alternative approach to practical implementation of coeffect systems.
Rather than building a specialized programming language (as we did in Chapter~\ref{ch:impl}), we
discuss the technical requirements for embedding coeffects as a domain-specific language (DSL) into
a statically-typed functional language with rich type system such as Haskell. This can be done by
following the successful example of Haskell's ``do'' notation.
