%!TEX root = ../main.tex

\chapter{Conclusions} 
\label{ch:conclusions} 

% ==================================================================================================
%
%       ###                                            
%      #   #                                           
%      #      #   #  ## #   ## #    ###   # ##   #   # 
%       ###   #   #  # # #  # # #      #  ##  #  #   # 
%          #  #   #  # # #  # # #   ####  #      #  ## 
%      #   #  #  ##  # # #  # # #  #   #  #       ## # 
%       ###    ## #  #   #  #   #   ####  #          # 
%                                                #   # 
%                                                 ###  
% =================================================================================================

Some of the most fundamental academic work is not the one solving hard research problems, but the 
one that changes how we understand the world. Some philosophers argue that \emph{language} is the 
key for understanding how we think, while in science the dominant thinking is determined by 
\emph{paradigms} \cite{philosophy-kuhn} or \emph{research programmes} \cite{philosophy-lakatos}.
In a way, programming languages play a similar role for computer science and software development.

This thesis aims to change how developers and programming language designers think about 
\emph{context} or \emph{execution environments} of programs. Such context or execution environment
has numerous forms -- mobile applications access network, GPS location or user's personal data; 
journalists obtain information published on the web or through open government data initiatives. 
This thesis aims to change our understanding of \emph{context} so that the above examples are 
viewed uniformly through a single programming language abstraction, which we call \emph{coeffects}, 
rather than as disjoint cases. This is done through the following three contributions.

% --------------------------------------------------------------------------------------------------

\section{Unified presentation.}

In $\lambda$-calculus, the term \emph{context} is usually used for the free-variable context.
However, there are many other programming language features that are related to context or program's
execution environment. In Chapter~\ref{ch:applications}, we revisit many of such features --
including resource tracking in distributed computing, cross-platform development, data-flow 
programming and liveness analysis, but also Haskell's type classes and implicit parameters. 

The main contribution of the chapter is that it presents the disjoint language features in a 
unified way. We show type systems and semantics for many of the languages, illuminating
the fact that they are closely related. 

Considering applications is one way of approaching the theory of coeffects introduced in this thesis.
Other pathways to coeffects are discussed in Chapter~\ref{ch:pathways}, which looks at theoretical 
developments leading to coeffects, including the work on effect systems, comonadic semantics and 
linear logics.

% --------------------------------------------------------------------------------------------------

\section{Flat coeffect calculus.}

The applications discussed in Chapter~\ref{ch:applications} fall into two categories. In the first
category (Section~\ref{sec:applications-flat}), the additional contextual information are 
\emph{whole-context} properties. They either capture properties of the execution environment or
affect the whole free-variable context.

In Chapter~\ref{ch:flat}, we develop a \emph{flat coeffect calculus} which gives us an unified way
of tracking \emph{whole-context} properties. The calculus is parameterized by a \emph{flat coeffect
algebra} that captures the algebraic properties that contextual information satisfy. Concrete 
instances of flat coeffects include Haskell's implicit parameters, whole-context liveness and
whole-context data-flow. 

Our focus is on the syntactic properties of the calculus -- we give a type system 
(Section~\ref{sec:flat-calculus}) and discuss equational theory of the calculus (Section~\ref{sec:flat-syntax}).
In the flat coeffect calculus, $\beta$-reduction and $\eta$-expansion do not generally preserve
type of expressions, but we identify two conditions when this is the case -- this gives us
a basis for operational semantics of our calculi for liveness and implicit parameters. 
The design of the type system is further validated by categorical semantics
(Section~\ref{sec:flat-semantics}) which models flat coeffect calculus in terms of 
\emph{flat indexed comonad} -- a structure based on categorical dual of monads.

% --------------------------------------------------------------------------------------------------

\section{Structural coeffect calculus.}

In the second category of context-aware systems discussed in Section~\ref{sec:applications-structural},
contextual properties are \emph{per-variable}. The systems discussed here resemble sub-structural
logics, but rather than \emph{restricting} variable use, they \emph{track} additional information
about how variables are used.

We unify systems with \emph{per-variable} contextual properties in Chapter~\ref{ch:structural},
which describes our \emph{structural coeffect calculus} (Section~\ref{sec:struct-calculus}). 
Similarly to the flat variant, the calculus is parameterized by a \emph{structural coeffect algebra}. 
Concrete instances of the calculus track bounded variable use (\ie~how many times is variable 
accessed), data-flow properties (how many past values are needed) and liveness (\ie~can variable 
be accessed). 

The structural coeffect calculus has desirable equational properties (Section~\ref{sec:struct-syntax}).
In particular, type preservation for $\beta$-reduction and $\eta$-expansion holds for all structural
coeffect calculi. This follows from the fact that structural coeffect associates contextual requirements
with individual variables and preserves the connection by including explicit structural rules
(weakening, exchange and contraction).

The Chapters~\ref{ch:flat} and \ref{ch:structural} present the main novel technical contributions of this
thesis. In Chapter~\ref{ch:unified}, we develop the two calculi further by introducing a unified
presentation of the two (by parameterizing the calculus by the \emph{shape} of context) and we present
an alternative presentation that makes type inference easier.

% --------------------------------------------------------------------------------------------------

\section{Summary}

