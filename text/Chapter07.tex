%!TEX root = ../main.tex

\chapter{Conclusions and further work} 
\label{ch:conclusions} 

Some of the most fundamental academic work is not the one solving hard research problems, but the 
one that changes how we understand the world. Some philosophers argue that \emph{language} is the 
key for understanding how we think, while in science the dominant thinking is determined by 
\emph{paradigms} \cite{philosophy-kuhn} or \emph{research programmes} \cite{philosophy-lakatos}.
In a way, programming languages play a similar role for computer science and software development.

This thesis aims to change how developers and programming language designers think about 
\emph{context} or \emph{execution environments} of programs. Such context or execution environment
has numerous forms -- mobile applications access network, GPS location or user's personal data; 
journalists obtain information published on the web or through open government data initiatives;
in data-flow programming, we have access to past values of expressions.
This thesis aims to change our understanding of \emph{context} so that the above examples are 
viewed uniformly through a single programming language abstraction, which we call \emph{coeffects}, 
rather than as disjoint cases.

In this chapter, we give a brief summary of the technical development completed in this thesis
(Section~\ref{sec:conc-summary}). The thesis looks at two kinds of context-dependence, identifies
common patterns and captures those using three \emph{coeffect calculi}. Next, we give an overview
of further work (Section~\ref{sec:conc-further}), often referring to longer discussion in earlier
chapters. Finally, Section~\ref{sec:conc-conclusions} concludes the thesis.


% ==================================================================================================
%
%       ###                                            
%      #   #                                           
%      #      #   #  ## #   ## #    ###   # ##   #   # 
%       ###   #   #  # # #  # # #      #  ##  #  #   # 
%          #  #   #  # # #  # # #   ####  #      #  ## 
%      #   #  #  ##  # # #  # # #  #   #  #       ## # 
%       ###    ## #  #   #  #   #   ####  #          # 
%                                                #   # 
%                                                 ###  
% =================================================================================================

\section{Summary}
\label{sec:conc-summary}

Modern computer programs run in rich and diverse environments or \emph{contexts}. The richness means 
that environments provides additional resources and capabilities that may be accessed by the program. 
The diversity means that programs often need to run in multiple different environments, such as mobile 
phones, servers, web browsers or even on the GPU. In this thesis, we present the foundations for
building programming languages that simplify writing software for such rich and diverse environments.

% --------------------------------------------------------------------------------------------------

\paragraph{Notions of context.}

In $\lambda$-calculus, the term \emph{context} is usually refers to the free-variable context.
However, other programming language features are also related to context or program's
execution environment. In Chapter~\ref{ch:applications}, we revisit many of such features --
including resource tracking in distributed computing, cross-platform development, data-flow 
programming and liveness analysis, but also Haskell's implicit parameters. 

The main contribution of the chapter is that it presents the disjoint language features in a 
unified way. We show type systems and semantics for many of the languages, illuminating
the fact that they are closely related. 

Considering applications is one way of approaching the theory of coeffects introduced in this thesis.
Other pathways to coeffects are discussed in Chapter~\ref{ch:pathways}, which looks at theoretical 
developments leading to coeffects, including the work on effect systems, comonadic semantics and 
linear logics.

% --------------------------------------------------------------------------------------------------

\paragraph{Flat coeffect calculus.}

The applications discussed in Chapter~\ref{ch:applications} fall into two categories. In the first
category (Section~\ref{sec:applications-flat}), the additional contextual information are 
\emph{whole-context} properties. They either capture properties of the execution environment or
affect the whole free-variable context.

In Chapter~\ref{ch:flat}, we develop a \emph{flat coeffect calculus} which gives us an unified way
of tracking \emph{whole-context} properties. The calculus is parameterized by a \emph{flat coeffect
algebra} that captures the algebraic properties of contextual information. Concrete 
instances of flat coeffects include Haskell's implicit parameters, whole-context liveness and
whole-context data-flow. 

Our focus is on the syntactic properties of the calculus -- we give a type system 
(Section~\ref{sec:flat-calculus}) and discuss equational theory of the calculus (Section~\ref{sec:flat-syntax}).
In the flat coeffect calculus, $\beta$-reduction and $\eta$-expansion do not generally preserve
the type of an expression, but we identify two conditions when this is the case -- this gives us
a basis for operational semantics of our calculi for liveness and implicit parameters. 

The design of the type system is further validated by categorical semantics
(Section~\ref{sec:flat-semantics}) which models flat coeffect calculus in terms of 
\emph{flat indexed comonad} -- a structure based on a categorical dual of monads.

% --------------------------------------------------------------------------------------------------

\paragraph{Structural coeffect calculus.}

~ The second category of context-aware systems discussed in Section~\ref{sec:applications-structural}
captures \emph{per-variable} contextual properties. The systems discussed here resemble sub-structural
logics, but rather than \emph{restricting} variable use, they \emph{track} how the variables are used.

We unify systems with \emph{per-variable} contextual properties in Chapter~\ref{ch:structural},
which describes our \emph{structural coeffect calculus} (Section~\ref{sec:struct-calculus}). 
Similarly to the flat variant, the calculus is parameterized by a \emph{structural coeffect algebra}. 
Concrete instances of the calculus track bounded variable use (\ie~how many times is a variable 
accessed), data-flow properties (how many past values are needed) and liveness (\ie~can variable 
be accessed). 

The structural coeffect calculus has desirable equational properties (Section~\ref{sec:struct-syntax}).
In particular, type preservation for $\beta$-reduction and $\eta$-expansion holds for all instances of the
structural coeffect calculus. This follows from the fact that structural coeffect 
associates contextual requirements with individual variables and preserves the connection by 
including explicit structural rules (weakening, exchange and contraction).

% --------------------------------------------------------------------------------------------------

\paragraph{Unified calculus.}

The Chapters~\ref{ch:flat} and \ref{ch:structural} present the main novel technical contributions of this
thesis. In Chapter~\ref{ch:unified}, we discuss the similarities and differences between the two. 
Although the calculi are worth considering separately (as they have different equational properties),
they can be presented in a uniform way. In Section~\ref{sec:unified-unified}, we present the 
\emph{unified coeffect calculus}, which can be instantiate to track both per-variable and 
whole-context properties. The key trick is to parameterize the calculus by the \emph{shape} of 
a context, which can be a vector (corresponding to the vector of free variables) or a singleton
container (attaching one annotation to the whole context).

% =================================================================================================
%                                                                                    
% 	 #####                 #     #                                                #     
% 	 #                     #     #                                                #     
% 	 #      #   #  # ##   ####   # ##    ###   # ##          #   #   ###   # ##   #   # 
% 	 ####   #   #  ##  #   #     ##  #  #   #  ##  #         #   #  #   #  ##  #  #  #  
% 	 #      #   #  #       #     #   #  #####  #             # # #  #   #  #      ###   
% 	 #      #  ##  #       #  #  #   #  #      #             # # #  #   #  #      #  #  
% 	 #       ## #  #        ##   #   #   ###   #              # #    ###   #      #   # 
%                                                                                    
% =================================================================================================                                                                     

\section{Further work}
\label{sec:conc-further}

Most of the further work has been discussed throughout the thesis, so this section
serves mainly as an overview. We follow the same structure as when discussing pathways to 
coeffects (Chapter~\ref{ch:pathways}). We consider further work related to syntactic approach
to coeffect systems, categorical semantics of coeffects, and connections with sub-structural type 
systems and bunched logics. 

% -------------------------------------------------------------------------------------------------

\paragraph{Syntactic coeffect systems.}
The coeffect calculi presented in this thesis are based on a simple $\lambda$-calculus, comprising
variables, lambda abstraction, application and let-binding. This lets us focus on fundamental
properties of coeffect systems (and explain how coeffect system differ from better-known effect
systems), but it is hardly sufficient for a realistic programming language. 

Further work is to extend the coeffect systems presented here to a full programming language. A
useful reference is the work of Nielson and Nielson~\cite{effects-nielson} who consider a 
similar development for effect systems, adding conditionals, recursion and polymorphism.

Coeffect annotations in context-aware programming languages can contain significant amount
of information. Thus, the programming langauge also needs a form of type inference that can propagate
such information. This has been done for effect systems \cite{effects-polymorphic}. For 
\emph{flat coeffects}, type inference is complicated by the non-determinism in the typing rule
for lambda abstraction, but the problem is simpler for \emph{structural coeffects}. In addition
to the \emph{algebra providers} (discussed in Section~\ref{sec:unified-impl-types}), it would also
be worth developing a bidirectional type system \cite{types-bidirectional} for coeffects, where 
\emph{some} annotations are required, but most types and coeffects are reconstructed automatically.

% -------------------------------------------------------------------------------------------------

\paragraph{Language semantics.}

As discussed in Section~\ref{sec:path-sem}, comonads can be used to define the semantics of a
programming language in two ways. The first, ``language semantics'', approach is to use a 
single comonad to describe the semantics of a specific context-aware property. The second,
``meta-language'' approach is to extend the language with explicit constructs representing the 
operations of the underlying comonad.

The categorical semantics in this thesis used the ``language semantics'' style, but mainly as a
guide for the development of the type systems. Further work includes more precise treatment of
the categorical structure of indexed comonads. This has partly been done for flat coeffects by
Orchard~\cite{comonads-dom-thesis}. A joint work with Orchard~\cite{coeffects-icfp14} shows the
first steps for structural systems. As discussed in Section~\ref{sec:unified-semantics}, further
work is to develop a similar categorical model for the unified coeffect calculus, possibly using
the categorical notion of containers \cite{types-containers}.

We briefly outlined a calculus based on the ``meta-language'' approach in Section~\ref{sec:unified-meta}.
Developing this technique further could unify coeffect systems with the work on Contextual Modal
Type-Theory (CMTT) \cite{logic-cmtt} and allow other interesting applications of coeffects such
as meta-programming \cite{logic-cmtt} and distributed computing with explicit modalities \cite{app-distributed-ml5}.

% -------------------------------------------------------------------------------------------------

\paragraph{Substructural and bunched logics.}

In the \emph{flat} and \emph{sturctural} coeffect calculi, we attach annotations to the \emph{entire
context} and to \emph{individual variables}, respectively. We later unified the two systems 
in Section~\ref{sec:unified-unified}.

An intriguing question is whether coeffects can generalize \emph{bunched typing} \cite{substruct-bunched},
which uses a tree-like structure of variable contexts (also discussed in Section~\ref{sec:path-logic}).
The definition of the \emph{unified coeffect calculus} is likely not expressive enough -- bunched
typing requires tree-like variable context, while we use a vector. Furthermore, bunched typing
annotates internal nodes of the tree (sub-contexts are combined using ``;'' or using ``,'') rather 
than just variables. Finding a simple coeffect system that is capable of capturing bunched typing
is thus an interesting further work. Indeed, this could lead to numerous uses of coeffects as 
bunched typing is the basis for widely-used separation logic \cite{substruct-separation-logic}.

% -------------------------------------------------------------------------------------------------

\paragraph{Applications.}
The last direction for further development is developing practical programming langauges or
libraries based on the theory presented in this thesis. We believe that the most useful approach
is to extend programming languages with a reusable coeffect system and allow library developers 
define their own coeffect algebras. This option has been discussed in Section~\ref{sec:unified-impl}.
For languages like Haskell, this can be done through a light-weight syntactic sugar akin to the
``do'' notation.

Another option is to use coeffects just as the underlying theory of a single-purpose programming
language feature. When discussing why context-aware programming matters (Section~\ref{sec:intro-whymatters}),
we covered a number of concrete problems that developers are facing today. Each of those would
presents an important further work. The most important practical challenges are cross-compilation 
(often solved using complex $\prepk{\#if}$ pre-processor rules) and tracking of provenance
and security properties.



% =================================================================================================                                                                     
%
% 	  ###                         ##                    #                        
% 	 #   #                         #                                             
% 	 #       ###   # ##    ###     #    #   #   ###    ##     ###   # ##    ###  
% 	 #      #   #  ##  #  #   #    #    #   #  #        #    #   #  ##  #  #     
% 	 #      #   #  #   #  #        #    #   #   ###     #    #   #  #   #   ###  
% 	 #   #  #   #  #   #  #   #    #    #  ##      #    #    #   #  #   #      # 
% 	  ###    ###   #   #   ###    ###    ## #  ####    ###    ###   #   #  ####  
%
% =================================================================================================

\section{Summary}
\label{sec:conc-conclusions}

We believe that understanding what programs \emph{require} from the world is equally important as 
how programs \emph{affect} the world. 

The latter has been uniformly captured by effect systems and monads. Those provide not just 
technical tools for defining semantics and designing type systems, but they also \emph{shape}
our thinking -- they let us view seemingly unrelated programming language features (exceptions,
state, I/O) as instances of the same concept and thus reduce the number of distinct language
features that developers need to understand. 

This thesis aims to provide a similar unifying theory and tools for capturing context-dependence
in programming languages. We showed that programming language features (liveness, data-flow, 
implicit parameters, etc.) that were previously treated separately can be captured by a common 
framework developed in this thesis. The main technical contribution of this thesis is that it  
provides the necessary tools for programming language designers -- including parameterized type 
systems, categorical semantics based on indexed comonads and equational theory.

If there is a one thing that the reader should remember from this thesis, it is the fact that
there is a unified notion of \emph{context}, capturing many common scenarios in programming.
