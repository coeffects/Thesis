%!TEX root = ../main.tex

\chapter{Further work and conclusions} 
\label{ch:conclusions} 

The main goal of this thesis is to demonstrate that different programming language features
and libraries involving \emph{context} can be seen as instances of the same unified notion.
The examples we explore include many properties of context important in modern software 
development (including distributed and cross-platform development) as well as context studied 
in fundamental programming language research (including data-flow, linear logics and variable 
liveness).

This thesis demonstrates that all these notions of context have something in common. In 
particular, they can be modelled by our flat or structural coeffect calculi. Although the 
results presented in this thesis are mainly of a theoretical nature, we indeed believe that 
coeffects should be integrated in main-stream programming languages.

In this chapter, we present further work in two directions. Firstly, we outline one possible
approach for practical implementations of coeffects (Section~\ref{sec:conclusions-impl}). 
Secondly, we discuss an alternative approach to defining coeffect systems which highlights
the relationship between our work and related work arising from modal logics 
(Section~\ref{sec:conclusions-meta}). Finally, the Section~\ref{sec:conclusions-summary} summarizes
and concludes the thesis.



% =================================================================================================
%                                                                   
%      ####                         #       #                   ##   
%      #   #                        #                            #   
%      #   #  # ##    ###    ###   ####    ##     ###    ###     #   
%      ####   ##  #      #  #   #   #       #    #   #      #    #   
%      #      #       ####  #       #       #    #       ####    #   
%      #      #      #   #  #   #   #  #    #    #   #  #   #    #   
%      #      #       ####   ###     ##    ###    ###    ####   ###  
%                                                                
% =================================================================================================

\section{Towards practical coeffects}
\label{sec:conclusions-impl}

As discussed earlier, the main focus of this thesis is the development of the much needed 
\emph{theory of context-aware computations} and so discussing the details of a practical 
implementation of coeffect tracking is beyond the scope of the thesis. However, this section
briefly outlines one possible pathway towards this goal.

Many of the examples of contextual computation that we discussed earlier have been implemented as 
a single-purpose programming language feature (\eg~implicit parameters \cite{app-implicit-parameters} 
or distributed computations \cite{app-distributed-ml5,app-distributed-links}). However, 
the main contribution of this thesis is that it captures
\emph{multiple} different notions of context-aware computations using just a \emph{single}
common abstraction. For this reason, we advocate that future practical implementations of
coeffects should not be single-purpose language features, but instead reusable abstractions that
can be instantiated with a concrete \emph{coeffect algebra} specified by the user.

In order to do this, programming languages need to provide two features; one that allows 
embedding of context-aware computations themselves in programs (akin to the ``do'' notation
in Haskell) and one that allows tracking of the contextual information in the type system.

% -------------------------------------------------------------------------------------------------

\subsection{Embedding contextual computations}

The embedding of \emph{contextual} computations in programming languages can learn from better 
explored emedding of \emph{effectful} computations. In purely functional programming languages
such as Haskell, effectful computations are embedded by \emph{implementing} them and inserting the
necessary (monadic) plumbing. This is made easier by the ``do'' notation \cite{other-haskell98} 
that inserts the monadic operations automatically.

The recently proposed ``codo'' notation \cite{comonads-codo} provides a similar plumbing for
context-aware computations based on comonads. The notation is close to the semantics of our 
flat coeffect calculus (Chapter~\ref{ch:flat}). Extending the ``codo'' notation to support calculi based 
on the structural coeffect calculus (Chapter~\ref{ch:structural}) is an interesting futrue work -- 
this requires explicitly manipulating individual context variables and application of structural
rules, which is not needed in flat coeffects.

In ML-like languages, effects (and many coeffects) are built-in into the language semantics, 
but they can still use a special notation for explicitly marking effectful (coeffectful) 
blocks of code. In F\#, this is done using \emph{computation expressions}  \cite{app-computation-zoo}
that differ from the ``do'' notation in two ways. First, they support wider range of 
constructs, making it possible to wrap existing F\# code in a block without other changes.
Second, they support other abstractions including monads, applicative functors and monad
transformers. It would be interesting to see if computation expressions can be extended to
handle computations based on flat/structural indexed comonads.

More lightweight syntax for effectful computation can be obtained using
techniques that automatically insert the necessary monadic plumbing (wihtout a
special syntax). This has been done in the context of effecful computations \cite{monads-lightweight-ml}
and similar approach would be worth exploring for coeffects. 

% -------------------------------------------------------------------------------------------------

\subsection{Coeffect annotations as types}

The other aspect of practical implementation of coeffects is tracking the context requirements
(coeffect annotations) in the type system. To achieve this (without resorting to a single-purpose
language feature) the type system needs to be able to capture various kinds of coeffect algebras. 
The structures used in this thesis include sets (with union or interesection), natural numbers (with 
addition, maximum, minimum and multiplication), two-point lattice (for liveness) and free monoids 
(vectors of annotations).

The work on embedding effect systems in Haskell \cite{effects-embedding} shows that the
recent additions to the Haskell type system provide enough poer to implement structures such
as sets at the type level. Using these to embed coeffect systems in Haskell is one fruitful 
future direction for applied coeffects.  

In dependently-typed programming languages such as Agda \cite{other-agda} or Idris \cite{other-idris},
the embedding of coeffects can be implemented more directly. However, we believe that coeffect
tracking does not require full dependent types and can be made accessible in more main-stream
languages. Dependent ML \cite{types-dependent-ml} provides an interesting example of a language
with some dependent typing which is still close to its non-dependently-typed predecessor ML.

Another approach for embedding computations into the type system has been pioneered by F\#
\emph{type providers} \cite{app-inforich}. Technically, type providers are compiler extensions 
that generate types based on external data sources or other information in order to provide easy 
access to data or services. A similar approach could be used for embedding \emph{algberas} such
as coeffect algebras into the type system. A \emph{algebra provider} would be a library that 
specifies the objects of the algebra, equational laws and generalization rules for type inference.
This could provide an easy to use way of embedding coeffect tracking in pragmatic languages
such as F\#. It is worth noting that the mechanism could also subsume F\# units of measure
\cite{types-units-of-measure}, which could be provided via one such \emph{algebra provider}.



% =================================================================================================
%                                                                                             
%    #   #          #                    ##                                                    
%    #   #          #                     #                                                    
%    ## ##   ###   ####    ###            #     ###   # ##    ## #  #   #   ###    ## #   ###  
%    # # #  #   #   #         #  #####    #        #  ##  #  #  #   #   #      #  #  #   #   # 
%    #   #  #####   #      ####           #     ####  #   #   ##    #   #   ####   ##    ##### 
%    #   #  #       #  #  #   #           #    #   #  #   #  #      #  ##  #   #  #      #     
%    #   #   ###     ##    ####          ###    ####  #   #   ###    ## #   ####   ###    ###  
%                                                            #   #                #   #        
%                                                             ###                  ###         
% =================================================================================================

\section{Coeffect meta-language}
\label{sec:conclusions-meta} 

In Section~\ref{sec:path-sem-langs}, we discussed two ways of using monads in programming
language semantics introduced by Moggi \cite{monad-notions}. The first approach is to use
monads in the \emph{semantics} of an effectful language. The second approach is to extend the
language with (additional) monadic constructs that can then be used for writing effectful
monads explicitly.

In this thesis, we focused on the first approach. In both flat and structural coeffect calculi,
the term language is that of simply-typed $\lambda$-calculus, and we used (flat or structural)
indexed comonads to give the semantics for the language and to derive type system for it.

In this section, we briefly discuss the alternative approach. That is, we embed indexed
comonads into a $\lambda$-calculus as additional constructs. To do that, we introduce the
type constructor $\ctyp{\cclrd{r}}{\tau}$ which represents a value $\tau$ wrapped in additional
context (semantically, this corresponds to an indexed comonad) and we add language constructs
that correspond to the operations of indexed comonads.

This section provides a brief sketch of coeffect meta-language to highlight the relationship
between coeffects and important related work on contextual modal type theory (CMTT) \cite{logic-cmtt}.
Developing the system further is an interesting future research direction.

% -------------------------------------------------------------------------------------------------

\subsection{Coeffects and contextual modal type theory}

As discussed in Section~\ref{sec:path-sem-contextdep}, context-aware computations are related
to modal logics -- comonads have been used to model the $\square$ modality and as a basis for
meta-languages that include $\square$ as a type constructor
\cite{logic-intuitionistic-modal,logic-modal-reconstruction,logic-intuitionistic-modal,logic-cmtt}.
Nanevski et al. \cite{logic-cmtt} extend an S4 term language to a contextual modal type theory (CMTT).
From the perspective of this thesis, CMTT can be viewed as a \emph{meta-language} version of our
coeffect calculus.

\paragraph{Context in CMTT and coeffects.}
Aside from the fact that coeffect calculi use comonads for \emph{semantics} and CMTT embeds
comonads (the $\square$ modality) into the meta-language, there are two important differences.

Firstly, the \emph{context} in CMTT is a set of variables required by a computation, which
makes CMTT useful for meta-programming and staged computations. In coeffect calculi, the context
requirements are formed by a coeffect algebra, which is more general and can capture
variable contexts, but also integers, two-point lattices, \emph{etc.}

Secondly, CMTT uses different intuitive understanding of the comonad (type constructor) and
the associated operations. In categorical semantics of coeffect calculi, the $\ctyp{\cclrd{r}}{\tau}$
constructor refers to a value of type $\tau$ \emph{together} with additional context specified
by $\cclrd{r}$ (\eg~list of past values or additional resources). In contrast in 
CMTT\footnote{To avoid using different notations, we write $\ctyp{\Psi}{\tau}$ instead of the 
original $[\Psi]{\tau}$} the type $\ctyp{\Psi}{\tau}$ models a value that \emph{requires} the 
context $\Psi$ in order to produce value $\tau$. This also changes the interpretation of the 
two operations of a comonad:
\begin{equation*}
\begin{array}{rcl}
 \ident{counit} &\narrow{:}& \ctyp{\cunit}{\alpha} \rightarrow \alpha\\
 \ident{cobind} &\narrow{:}& (\ctyp{\cclrd{r}}{\alpha} \rightarrow \beta) \rightarrow 
    \ctyp{\cclrd{r}\cseq\cclrd{s}}{\alpha} \rightarrow \ctyp{\cclrd{s}}{\beta}
\end{array}
\end{equation*}
Both readings are possible, but they give quite different meanings to the operations:

\begin{itemize}
\item \emph{Coeffect interpretation.} The \ident{counit} operation extracts a value 
  and does not require any additional context; the \ident{cobind} operation requires
  context $\cclrd{r}\,\cseq\,\cclrd{s}$, uses the part specified by $\cclrd{r}$ to 
  evaluate the function, ending with a value $\beta$ together with remaining context
  $\cclrd{s}$.
\item \emph{CMTT interpretation.} The \ident{counit} operation evaluates a computation 
  that requires no additional context to obtain a $\alpha$ value; given a function that
  turns a computation requiring context $\cclrd{r}$ into a value $\beta$, the \ident{cobind}
  operation can turn a computation that requires context $\cclrd{r}\,\cseq\,\cclrd{s}$ 
  into a computation that requires just $\cclrd{s}$ and contains $\beta$ (a part of the
  context requirements is eliminated by the function).
\end{itemize}

\noindent
Although the different reading does not affect formal properties of the systems, it is important
to understand the difference when discussing the two systems. 

The sketch of a coeffect meta-language in the following section attempts to bridge the gap
between coeffects and CMTT. Just like CMTT, it embeds comonads as language constructs, but
it annotates them with a (flat) coeffect algebra, thus it generalizes CMTT which tracks only
sets of variables. Future work on the coeffect meta-language would thus be an interesting 
development for both coeffect systems and CMTT.

% -------------------------------------------------------------------------------------------------

\subsection{Coeffect meta-language}

The coeffect meta-langauge could be designed using both flat and structural indexed comonads.
For simplicity, this section only discusses the flat variant. The syntax of types and terms
of the langauge includes the type constructor $\ctyp{\cclrd{r}}{\tau}$ and four expression forms:
%
\begin{equation*}
\begin{array}{rcl}
 \tau &\narrow{::=}& \alpha \sep \tau_1 \rightarrow \tau_2 \sep \ctyp{\cclrd{r}}{\tau}\\
 e &\narrow{::=}& v \sep \lambda x.e \sep e_1~e_2 \sep !e    \\[-0.25em]
  &        \sep& \kvd{let\;box}~x=e_1~\kvd{in}~e_2           \\[-0.25em]
  &        \sep& \kvd{split}~e_1~\kvd{into}~x,y~\kvd{in}~e_2 \\[-0.25em]
  &        \sep& \kvd{merge}~e_1, e_2~\kvd{into}~x~\kvd{in}~e_2 
\end{array}
\end{equation*}
%
The $!e$ and $\kvd{let\;box}$ constructs correspond to the \ident{counit} and \ident{cobind}
operation of the comonad. To define meta-langauge for flat indexed comonads, we also include 
\kvd{split} and \kvd{merge} that embed the corresponding operations. 

\paragraph{Types for coeffect meta-language.}
The type system for the language is shown in Figure~\ref{fig:conclusions-cml}. The first part
shows the usual typing rules for simply-typed $\lambda$-calculus. For simplicity, we omit typing 
rules for pairs, but those need to be present as the \kvd{merge} operation works on tuples.

The second part of the typing rules is more interesting. The (\emph{counit}) operation extracts
a value from a comonadic context and corresponds to variable access in coeffect calculi. The
\kvd{let\;box} construct (\emph{cobind}) takes an input $e_1$ with context $\cclrd{r}\,\cseq\,\cclrd{s}$
and a computation that turns a variable $x$ with a context $\cclrd{r}$ into a value $\tau_2$.
The result is a computation that produces a $\tau_2$ value with the remaining context specified
by $\cclrd{s}$. Note that the expression $e_2$ and $e_1$ corresponds to the first and second
arguments of the \ident{cobind} operation. The keyword \kvd{let\;box} is chosen following 
CMTT\footnote{The rule is similar to the \ident{letbox} rule for ICML \cite[p. 14]{logic-cmtt},
although it differs because of our generalization of comonads where \ident{bind} composes
coeffect annotations rather than requiring the same annotation everywhere.}.

The \kvd{split} and \kvd{merge} constructs follow a similar pattern. They both apply some 
transformation on one or two values in a context and then add the new value as a fresh variable
to the variable context. For simplicity, we omit sub-coeffecting, but it could be easily added 
following the pattern used elsewhere.

% -------------------------------------------------------------------------------------------------

\begin{figure}[t]

{\small a.) Typing rules for the simply typed $\lambda$-calculus}

\begin{equation*}
\tyrule{var}
  {x : \tau \in \Gamma}
  {\Gamma \vdash x : \tau }
\end{equation*}
\begin{equation*}
\tyrule{app}
  {\Gamma \vdash e_1 : \tau_2 \rightarrow \tau_1 &
   \Gamma \vdash e_2 : \tau_2 }
  {\Gamma \vdash e_1~e_2 : \tau_1 }
\end{equation*}
\begin{equation*}
\tyrule{abs}
  {\Gamma, x:\tau_1 \vdash e : \tau_2}
  {\Gamma \vdash \lambda x.e : \tau_1 \rightarrow \tau_2 }
\end{equation*}

\vspace{1em}
{\small b.) Additional typing rules arising from \emph{flat indexed comonads}}

\begin{equation*}
\tyrule{cobind}
  {\Gamma \vdash e_1 : \ctyp{\cclrd{r}\,\cseq\,\cclrd{s}}{\tau_1} & \Gamma, x : \ctyp{\cclrd{r}}{\tau_1} \vdash e_2 : \tau_2 }
  {\Gamma \vdash \kvd{let\;box}~x=e_1~\kvd{in}~e_2 : \ctyp{\cclrd{s}}{\tau_2}}
\end{equation*}
\begin{equation*}
\tyrule{counit}
  {\Gamma \vdash e : \ctyp{\cunit}{\tau}}
  {\Gamma \vdash !e : \tau}
\end{equation*}
\begin{equation*}
\tyrule{split}
  {\Gamma \vdash e_1 : \ctyp{\cclrd{r}\,\cpar\,\cclrd{s}}{\tau_1} &
   \Gamma, x:\ctyp{\cclrd{r}}{\tau_1}, y:\ctyp{\cclrd{s}}{\tau_1} \vdash e_2 : \tau_2 }
  {\Gamma \vdash \kvd{split}~e_1~\kvd{into}~x,y~\kvd{in}~e_2 : \tau_2 }
\end{equation*}
\begin{equation*}
\tyrule{merge}
  {\Gamma \vdash e_1 : \ctyp{\cclrd{r}}{\tau_1} &
   \Gamma \vdash e_2 : \ctyp{\cclrd{s}}{\tau_2} \\
   \Gamma, x:\ctyp{\cclrd{r}\,\czip\,\cclrd{s}}{(\tau_1 \times \tau_2)} \vdash e_2 : \tau_3 }
  {\Gamma \vdash \kvd{merge}~e_1, e_2~\kvd{into}~x~\kvd{in}~e_2 : \tau_3 }
\end{equation*}

\caption{Type system for the (flat) coeffect meta-language}
\label{fig:conclusions-cml}
\end{figure}

% -------------------------------------------------------------------------------------------------

\subsection{Embedding flat coeffect calculus}

The \emph{meta-language} approach of embedding comonads in a language is more general than the
\emph{semantics} approach. This thesis focuses on a narrower use that better guides the design of
a type system for context-aware programming languages. 

However, it is worth noting that 
(flat) coeffect calculus can be embedded in the meta-language described above. This may be 
desirable, \eg~when using the meta-language for reasoning about context-aware computations. 
We briefly consider the embedding as it illuminates the relationship between coeffects and
CMTT (although it is not possible to embed coeffect calculi in CMTT because of the more general
annotations structure).

Given a typing judgement $\coctx{\Gamma}{\cclrd{r}} \vdash e : \tau$ in a flat coeffect calculus,
we define $\sem{\coctx{\Gamma}{\cclrd{r}} \vdash e : \tau}_v$ as its emebdding in the coeffect
meta-language. Note that the translation is indexed by $v$, which is a name of variable used 
to represent the entire variable context of the source language. The translation is defined in
Figure~\ref{fig:conclusions-embed}. The embedding resembles the semantics discussed in 
Section~\ref{sec:flat-semantics}. This is not surprising as the meta-language directly mirrors
the operations of a monad.

% -------------------------------------------------------------------------------------------------

\begin{figure}[t]
\begin{equation*}
\begin{array}{l}
 \sem{ \coctx{\Gamma}{\cunit}\vdash x_i : \tau_i }_v = \pi_i (!v) \\[0.25em]
 \sem{ \coctx{\Gamma}{\cclrd{r}\;\cpar\;(\cclrd{s}\,\cseq\,\cclrd{t})} \vdash e_1~e_2 : \tau_2 }_v =\\[-0.25em]
   \qquad \kvd{split}~v~\kvd{into}~v_s, v_{rt}~\kvd{in} \\[-0.25em]
   \qquad \sem{ \coctx{\Gamma}{\cclrd{s}} \vdash e_1 : \tau_1 \xrightarrow{\cclrd{t}} \tau_2 }_{v_s}
      ~(\kvd{let\;box}~v_r = v_{rt}~\kvd{in}~\sem{ \coctx{\Gamma}{\cclrd{r}} \vdash e_2 : \tau_1}_{v_r}) \\[0.25em]
 \sem{ \coctx{\Gamma}{\cclrd{r}} \vdash \lambda x.e:\tau_1 \xrightarrow{\cclrd{s}} \tau_2 }_v = \lambda x. \\[-0.25em]
   \qquad \kvd{merge}~v,x~\kvd{into}~v_{rs}~\kvd{in}~\sem{ \coctx{(\Gamma,x:\tau_1)}{\cclrd{r}\,\czip\,\cclrd{s}} \vdash e : \tau_2 }_{v_{rs}}
\end{array}
\end{equation*}
\caption{Embedding flat coeffect calculus in coeffect meta-language }
\label{fig:conclusions-embed}
\end{figure}

% ==================================================================================================
%
%       ###                                            
%      #   #                                           
%      #      #   #  ## #   ## #    ###   # ##   #   # 
%       ###   #   #  # # #  # # #      #  ##  #  #   # 
%          #  #   #  # # #  # # #   ####  #      #  ## 
%      #   #  #  ##  # # #  # # #  #   #  #       ## # 
%       ###    ## #  #   #  #   #   ####  #          # 
%                                                #   # 
%                                                 ###  
% =================================================================================================

\section{Summary}
\label{sec:conclusions-summary}

Some of the most fundamental academic work is not the one solving hard research problems, but the 
one that changes how we understand the world. Some philosophers argue that \emph{language} is the 
key for understanding how we think, while in science the dominant thinking is determined by 
\emph{paradigms} \cite{philosophy-kuhn} or \emph{research programmes} \cite{philosophy-lakatos}.
In a way, programming languages play a similar role for computer science and software development.

This thesis aims to change how developers and programming language designers think about 
\emph{context} or \emph{execution environments} of programs. Such context or execution environment
has numerous forms -- mobile applications access network, GPS location or user's personal data; 
journalists obtain information published on the web or through open government data initiatives. 
This thesis aims to change our understanding of \emph{context} so that the above examples are 
viewed uniformly through a single programming language abstraction, which we call \emph{coeffects}, 
rather than as disjoint cases. This is done through the following three contributions.

\paragraph{Unified presentation.}
In $\lambda$-calculus, the term \emph{context} is usually used for the free-variable context.
However, there are many other programming language features that are related to context or program's
execution environment. In Chapter~\ref{ch:applications}, we revisit many of such features --
including resource tracking in distributed computing, cross-platform development, data-flow 
programming and liveness analysis, but also Haskell's type classes and implicit parameters. 

The main contribution of the chapter is that it presents the disjoint language features in a 
unified way. We show type systems and semantics for many of the languages, illuminating
the fact that they are closely related. 

Considering applications is one way of approaching the theory of coeffects introduced in this thesis.
Other pathways to coeffects are discussed in Chapter~\ref{ch:pathways}, which looks at theoretical 
developments leading to coeffects, including the work on effect systems, comonadic semantics and 
linear logics.

\paragraph{Flat coeffect calculus.}
The applications discussed in Chapter~\ref{ch:applications} fall into two categories. In the first
category (Section~\ref{sec:applications-flat}), the additional contextual information are 
\emph{whole-context} properties. They either capture properties of the execution environment or
affect the whole free-variable context.

In Chapter~\ref{ch:flat}, we develop a \emph{flat coeffect calculus} which gives us an unified way
of tracking \emph{whole-context} properties. The calculus is parameterized by a \emph{flat coeffect
algebra} that captures the algebraic properties that contextual information satisfy. Concrete 
instances of flat coeffects include Haskell's implicit parameters, whole-context liveness and
whole-context data-flow. 

Our focus is on the syntactic properties of the calculus -- we give a type system 
(Section~\ref{sec:flat-calculus}) and discuss equational theory of the calculus (Section~\ref{sec:flat-syntax}).
In the flat coeffect calculus, $\beta$-reduction and $\eta$-expansion do not generally preserve
type of expressions, but we identify two conditions when this is the case -- this gives us
a basis for operational semantics of our calculi for liveness and implicit parameters. 
The design of the type system is further validated by categorical semantics
(Section~\ref{sec:flat-semantics}) which models flat coeffect calculus in terms of 
\emph{flat indexed comonad} -- a structure based on categorical dual of monads.

\paragraph{Structural coeffect calculus.}
In the second category of context-aware systems discussed in Section~\ref{sec:applications-structural},
contextual properties are \emph{per-variable}. The systems discussed here resemble sub-structural
logics, but rather than \emph{restricting} variable use, they \emph{track} additional information
about how variables are used.

We unify systems with \emph{per-variable} contextual properties in Chapter~\ref{ch:structural},
which describes our \emph{structural coeffect calculus} (Section~\ref{sec:struct-calculus}). 
Similarly to the flat variant, the calculus is parameterized by a \emph{structural coeffect algebra}. 
Concrete instances of the calculus track bounded variable use (\ie~how many times is variable 
accessed), data-flow properties (how many past values are needed) and liveness (\ie~can variable 
be accessed). 

The structural coeffect calculus has desirable equational properties (Section~\ref{sec:struct-syntax}).
In particular, type preservation for $\beta$-reduction and $\eta$-expansion holds for all structural
coeffect calculi. This follows from the fact that structural coeffect associates contextual requirements
with individual variables and preserves the connection by including explicit structural rules
(weakening, exchange and contraction).

The Chapters~\ref{ch:flat} and \ref{ch:structural} present the main novel technical contributions of this
thesis. In Chapter~\ref{ch:unified}, we develop the two calculi further by introducing a unified
presentation of the two (by parameterizing the calculus by the \emph{shape} of context) and we present
an alternative presentation that makes type inference easier.