%!TEX root = ../main.tex

\chapter{Unified coeffect language} 
\label{ch:unified} 

%===================================================================================================

\section{Introduction}

The main goal of this thesis is to provide a \emph{unified} calculus for tracking context 
dependence. We have not achieved this goal yet. In Chapter~\ref{ch:applications}, we identified 
two kinds of contextual properties that we further covered separately -- flat coeffects in 
Chapter~\ref{ch:flat} track whole-context properties and structural coeffects, covered in 
Chapter~\ref{ch:structural}, track per-variable properties. In this chapter, we unify
the two notions. We introduce a \emph{unified coeffect} calculus that generalizes the two systems
and can be instantiated to track both flat and structural properties (Section~\ref{sec:unified-unified}). 

Although the results presented in this thesis are mainly of a theoretical nature, we indeed 
believe that coeffects should be integrated in main-stream programming languages. In the second
part of this chapter, we outline one possible approach for practical implementations of coeffects 
(Section~\ref{sec:unified-impl}). Finally, we discuss an alternative approach to defining coeffect 
systems which highlights the relationship between our work and related work arising from modal logics 
(Section~\ref{sec:unified-meta}). 

% ==================================================================================================

\section{The unified coeffect calculus}
\label{sec:unified-unified}

The flat coeffect calculus (Figure~\ref{fig:flat-types}) and the structural coeffect calculus 
differ in a number of ways (Figure~\ref{fig:struct-types}). Understanding the differences is the 
key to reconciling the two systems:

\begin{itemize}
\item Structural coeffect calculus contains explicit rules for context manipulation
  (weakening, contraction, exchange). In flat coeffect calculus, these rules are not defined
  explicitly, but are admissible.

\item In structural coeffect calculus, the variable context is treated as a vector
  and is annotated with a vector of (scalar) coeffects. In flat coeffect calculus,
  the variable context is a set and is annotated with a single (scalar) coeffect.

\item In flat coeffect calculus, we distinguish between splitting of the context requirements
  and merging of context requirements ($\cpar$ and $\czip$, respectively). In structural
  coeffect calculus, the operations (which model splitting and appending vectors) are invertible 
  and so the structural coeffect algebra requires just $\atimes$.
\end{itemize}

\noindent
In the unified calculus presented in this section, we address the three differences as follows.
We use calculus with explicit rules for context manipulation. In systems that arise from flat
calculi, the rules can be applied freely without changing the coeffects. We generalize the 
structure of coeffect annotations using the notion of a ``container'' which can be specialized 
to obtain a single annotation or a vector of annotations. Finally, we distinguish between 
splitting and merging of context requirements (using the notation $\apar$ and $\azip$, 
respectively). For structural coeffect calculi, the two operators coincide, but for flat
coeffect calculi, they provide the needed flexibility.

\subsection{Shapes and containers}

Our notion of a \emph{coeffect container} is based on the idea of a container introduced by 
Abbott et al. \cite{types-containers}. Interestingly, the work on containers has later been linked
to comonads by Ahman et al. \cite{comonads-containers}. Intuitively a container describes data
types such as lists, trees or streams. A container is formed by shapes (\eg~lengths of lists).
For every shape, we can obtain a set of positions in the container (\eg~offsets in a list of a
specified length). More formally:

\begin{definition}
A \emph{container} $S \triangleleft P$ is given by a set $S$ of shapes and a shape-indexed family
$P : S \rightarrow \ident{Set}$ of positions.
\end{definition}

\noindent
Well-known examples of containers include lists, non-empty lists, (un\-boun\-ded) streams and 
singleton data type (which contains exactly one element). Two containers relevant to our work
are lists and singleton data types:

\begin{itemize}
\item The container representing lists is given by $S \triangleleft P$ where 
  shapes are integers $S = \ident{Nat}$ (lengths of a list). The set of positions for a 
  given length $n$ is a set of indices $P n = \{ 1 \ldots n \}$.

\item The contianer representing singleton data type is given by $S \triangleleft P$ where
  shapes are given by a singleton set $S = \{ \ast \}$ and the set of positions for the
  shape $\ast$ contains exactly one position $P \ast = \{ 0 \}$.
\end{itemize}

\noindent
In the unified coeffect calculus, the structure of coeffect annotations is defined by a 
container with additional operations (discussed later) that links it with the free-variable 
context $\Gamma$. 

\subsection{Structure of coeffects}
In structural coeffect calculus, the structure annotation was formed by a vector of coeffect
sclars. The unified coeffect calculus is similar, but a \emph{vector} is replaced with a 
\emph{container}. The primitive coeffect annotations in the unified calculus are formed by
a \emph{coeffect scalar}, which remains the same as in structural coeffect calculus
(Definition~\ref{def:structural-scalar}). In this section, we refer to it as
\emph{\cclrd{unified coeffect scalar}} (and we repeat the definition below). Then we
define \emph{\sclrd{unified coeffect containers}} which determines how coeffect scalar values 
are attached to the free-variable context. Finally, we define the \emph{\aclrd{unified coeffect 
algebra}} which consists of shape-indexed coeffect scalar values.

As in the structural coeffect calculus, the contexts in the unified calculus are annotated with 
shape-indexed coeffects, written as $\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e : \tau$; 
functions take just a single input parameter and so are annotated with scalar coeffect values 
$\sigma \xrightarrow{\cclrd{r}} \tau$.

\paragraph{Coeffect scalar.}
The following definition of the coeffect scalar structure repeats the Definition~\ref{def:structural-scalar}
from the previous chapter.

\begin{definition}
A \emph{\cclrd{unified coeffect scalar}} $(\C, \cseq, \cpar, \cunit, \czero, \cleq)$ is a set 
$\C$ together with elements $\cunit, \czero \in \C$, relation $\cleq$ and binary operations 
$\cseq, \cpar$ such that $(\C, \cseq, \cunit)$ and $(\C, \cpar, \czero)$ are monoids and
$(\C, \cleq)$ is a pre-order. That is, for all $r,s,t\in \C$:
%
\begin{equation*}
\begin{array}{ccr}
r \;\cseq\; (s \;\cseq\; t) = (r \;\cseq\; s) \;\cseq\; t  &
\cunit \;\cseq\; r = r = r \;\cseq\; \cunit &
\textnormal{(monoid)}   
\\
r \;\cpar\; (s \;\cpar\; t) = (r \;\cpar\; s) \;\cpar\; t &
\czero \;\cpar\; r = r = r \;\cpar\; \czero &
\textnormal{(monoid)}   
\\
\textnormal{if}~~r\; \cleq\; s ~~\textnormal{and}~~s\; \cleq\; t~~\textnormal{then}~~r\; \cleq\; t&
t\; \cleq\; t &
\textnormal{(pre-order)}   
\end{array}
\end{equation*}
\end{definition}

\noindent
As previously, the monoid $(\C,\cseq,\cunit)$ models sequential composition; the laws guarantee
an underlying category structre; $\cunit$ and $\czero$ represent an accessed and unused variable, 
respectively.

The $\cpar$ operation models combining of context requirements arising from multiple parts of a 
program. The meaning depends on the coeffect container. The operation can either combine requirements
of individual variables (structural) or requirements attached to the whole context of multiple
sub-exp\-ressions (flat).

\paragraph{Coeffect containers.}
The coeffect container is a container that determines how are scalar coeffect annotations attached 
to free-variable contexts. In addition to a container $\SHP$ with shapes and shape-indexed positions, the
coeffect container also provides a mapping that returns the shape of a free-variable context. The
mapping between the shape of the variable context and the shape of the coeffect annotation
is not necessarily bijective. For example, coeffect annotations in flat systems have just a single 
shape $\SH = \{ \ast \}$.

In the coeffect judgment $\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e : \tau$, the coeffect annotation
$\aclrd{\textbf{r}}$ is drawn from the set of coeffect scalars $\C$ indexed by the shape of $\Gamma$.
We write $\sclrd{s} = \slen{\Gamma}$ for the shape corresponding to $\Gamma$. The operation $\SP\sclrd{s}$
returns a \emph{set} of positions and so we can write $\aclrd{\textbf{r}} \in \SP\sclrd{s} \rightarrow \C$ 
as a mapping from positions (defined by the shape) to scalar coeffects. We usually write this as 
the exponent $\aclrd{\textbf{r}} \in \C^{\SP\sclrd{s}}$.

The coeffect container is also equipped with an operation that appends shapes (when we concatenate
variable contexts) and two special shapes in $\SH$ representing empty context and singleton context. 

\begin{definition}
A \emph{\sclrd{coeffect container}} structure $(\SHP, \stimes, \sempty, \sunit, \slen{-})$ 
comprises a container $\SHP$ with a binary operation $\stimes$ on $\SH$ for appending shapes, a 
mapping from free-variable contexts to shapes $\slen{\Gamma} \in \SH$, and elements $\sempty,\sunit \in
\SH$ such that $(\SH, \stimes, \sempty)$ is a monoid.

The elements $\sempty$ and $\sunit$ represent the shapes of empty and singleton free-variable contexts 
respectively. The $\stimes$ operation corresponds to concatentation of free-variable contexts. Given
$\Gamma_1$ and $\Gamma_2$ such that $\sclrd{s_1}=\slen{\Gamma_1}, \sclrd{s_2}=\slen{\Gamma_2}$, 
we require that $\sclrd{s_1}\,\stimes\,\sclrd{s_2}=\slen{\Gamma_1, \Gamma_2}$. 
\end{definition}

\noindent
As said earlier, we use two kinds of coeffect containers that describe the structure of vectors 
(for structural coeffects) and the shape of trivial singleton container (for flat coeffects): 

\begin{example}
Structural coeffect shape is defined as $\sclrd{(\SHP, {|}\textnormal{--}{|}, +, 0, 1)}$
where $\SH=\mathbb{N}$ and $\SP \sclrd{n}=\{ 1 \ldots n \}$. The shape mapping ${|}\Gamma{|}$ returns the 
number of variables in $\Gamma$. Empty and singleton contexts are annotated with $0$ and $1$, 
respectively, and shapes of combined contexts are added so that ${|}\Gamma_1, \Gamma_2{|} = 
{|}\Gamma_1{|} + {|}\Gamma_2{|}$. 

Therefore, a coeffect annotation is a \emph{vector} 
$\aclrd{\textbf{r}} \in \C^{\SP\sclrd{n}}$ and assigns a coeffect scalar $\aclrd{\textbf{r}}(i) \in \C$ 
for each position (corresponding to a variable $x_i$ in the context).
\end{example}

\begin{example}
Flat coeffect shape is defined as $\sclrd{(\SHP, {|}-{|}, \diamond, \sflat, \sflat)}$.
The container is defined as a singleton data type $\SH = \{\sflat \}$ and $\SP \sflat = \{ 0 \}$
with a constant function ${|}\Gamma{|}=\sflat$ and a trivial operation $\sflat\,\diamond\,\sflat = \sflat$. 

That is, there is a single shape
$\sflat$ with a single position and all free-variable contexts have the same singleton shape.
Therefore, a coeffect annotation is drawn from $\C^\{\sflat\}$ which is isomorphic to $\C$
and so a coeffect scalar $\cclrd{r}\in \C$ is associated with every free-variable context.
\end{example}

\newpage
\begin{example}
Similarly to the previous example, we can also define a coeffect container with \emph{no} positions,
\ie~$\sclrd{(\SHP, {|}-{|}, \diamond, \sflat, \sflat)}$ where $\SH = \{\sflat \}$, $\SP \sflat = \emptyset$,
${|}\Gamma{|}=\sflat$ and $\sflat\,\diamond\,\sflat = \sflat$. 

This reduces our system to the simply-typed $\lambda$-calculus with no context annotations, because
$\SP\sflat=\emptyset$ and so coeffect annotations would be from the set $\C^\emptyset$.
\end{example}


\paragraph{Unified coeffect algebra.}
The coeffect calculus annotates judgments with shape-indexed coeffect annotations.
The \emph{\aclrd{unified coeffect algebra}} combines a coeffect scalar and coeffect container
to define shape-indexed coeffects and operations for manipulating these. 

The definition here reconciles the third point discussed in Section~\ref{sec:unified-unified} --
the fact that flat coeffects use separate operations for splitting and merging ($\cpar$ and $\czip$)
while structural coeffects use tensor $\atimes$. In the unified calculus, we use two operators
that can, however, be coincide.

\begin{definition}
Given a \cclrd{unified coeffect scalar} $(\C, \cseq, \cpar, \cunit, \czero, \cleq)$ and a 
\sclrd{coeffect container} $(\SHP, \slen{-}, \stimes, \sempty, \sunit)$ a \emph{\aclrd{unified 
coeffect algebra}} extends the two structures with $(\azip, \apar, \azero)$ where $\azero$ is a 
coeffect annotation for the empty context and $\azip, \apar$ are families of operations that 
combine coeffect annotations indexed by shapes. That is $\forall \sclrd{n},\sclrd{m} \in \SH$:
%
\begin{equation*}
\apar_{\sclrd{m},\sclrd{n}}, \azip_{\sclrd{m},\sclrd{n}} ~:~ \C^{\SP \sclrd{m}} \times \C^{\SP \sclrd{n}} \rightarrow \C^{\SP (\sclrd{m}\,\stimes\,\sclrd{n})}
\end{equation*}
\end{definition}

\noindent
A coeffect algebra induces the following three additional operations:
%
\begin{equation*}
\begin{array}{rclcrcl}
 \alift{-} &\narrow{:}& \C \rightarrow \C^{\SP \sunit}  \\
 \alift{\cclrd{x}} &\narrow{=}& \lambda \sunit . \cclrd{x}   \\
\\[-0.5em]
 \aseq_{\sclrd{m}} &\narrow{:}&  \C \times \C^{\SP \sclrd{m}} \rightarrow \C^{\SP \sclrd{m}}   \\
 \cclrd{r}\, \aseq\, \aclrd{\textbf{s}} &\narrow{=}& \lambda \sclrd{s} . \cclrd{r}\, \cseq\, \aclrd{\textbf{s}}(\sclrd{s}) \\
\\[-0.5em]
 \alen{-} &\narrow{:}& \C^{\SP \sclrd{m}} \rightarrow \sclrd{m}\\
 \alen{\aclrd{\textbf{r}}} &\narrow{=}& \sclrd{m}
\end{array}
\end{equation*}
%
The $\alift{-}$ operation lifts a scalar coeffect to a shape-indexed coeffect that is indexed by 
the singleton context shape. The $\aseq_{\sclrd{m}}$ operation is a left multiplication of a 
vector by scalar. As we always use bold font for vectors and ordinary font for scalars (as well 
as distinct colour), using the same symbol is not ambiguous. We also tend to omit the subscript
$\sclrd{m}$ and write $\aseq$. 

Finally, we define $\alen{}$ as an operation that returns the shape of a given shape-indexed 
coeffect. The only purpose is to simplify notation, as we often need to specify that shapes of 
variable context and coeffect match, \eg~$\alen{\aclrd{\textbf{r}}} = \slen{\Gamma}$.

\paragraph{Splitting and merging coeffects.}
The operators $\apar$ and $\azip$ combine shape-indexed coeffects associated with two contexts. 
For example, assume we have $\Gamma_1$ and $\Gamma_2$ with coeffects $\aclrd{\textbf{r}} \in 
\C^{\SP\sclrd{m}}$ and $\aclrd{\textbf{s}} \in \C^{\SP\sclrd{n}}$. In the structural system, the 
context shapes $\sclrd{m}, \sclrd{n}$ denote the number of variables in the two contexts. The 
combined context $\Gamma_1, \Gamma_2$ has a shape $\sclrd{m}\,\stimes\,\sclrd{n}$ and the combined 
coeffects $\aclrd{\textbf{r}} \,\azip\, \aclrd{\textbf{s}}, \aclrd{\textbf{r}} \,\apar\, \aclrd{\textbf{s}} 
\in \C^{\SP(\sclrd{m} \stimes \sclrd{n})}$ are indexed by that shape.

For structural coeffect systems such as bounded reuse, both $\apar$ and $\azip$ are
just the tensor product $\times$ of vectors. For flat coeffect systems, the operations
can be defined independently, letting $\azip=\czip$ and $\apar=\cpar$.

The difference between $\azip$ and $\apar$ is clarified by the semantics (Sec\-tion~\ref{sec:unified-semantics}), 
where $\aclrd{\textbf{r}}\,\azip\,\aclrd{\textbf{s}}$ is an annotation of the \emph{codomain} of 
a morphism that merges the capabilities provided by two contexts (in the syntactic 
reading, splits the context requirements), while $\aclrd{\textbf{r}}\,\apar\,\aclrd{\textbf{s}}$ 
is an annotation of the \emph{domain} of a morphism that splits the capabilities of a single 
context into two parts (in the syntactic reading, merges their context requirements). 
Syntactically, this means that we always use $\azip$ in the rule \emph{assumptions} and 
$\apar$ in \emph{conclusions}. 

% --------------------------------------------------------------------------------------------------

\newcommand{\tystmt}[2]{ (\text{\footnotesize{#1}})~~{#2} }
\newcommand{\ctxtrans}[3]{ #2 \rightsquigarrow #1, #3 }
\newcommand{\ctxtransnl}[3]{ \begin{array}{l} #2 \rightsquigarrow\\ #1, #3 \end{array}}

\begin{figure}[t]

{\small a.) Syntax-driven typing rules:}
\begin{equation*}
\tyrule{var}
  { }
  {\coctx{x\!:\!\tau}{\alift{\cunit}} \vdash x : \tau }
\end{equation*}
\begin{equation*}
\tyrule{const}
  {c \!:\! \tau \in \Delta}
  {\coctx{()}{\azero} \vdash c : \tau }
\end{equation*}
\begin{equation*}
\tyrule{app}
  {\coctx{\Gamma_1}{\aclrd{\textbf{r}}} \vdash e_1 : \tau_1 \xrightarrow{\cclrd{t}} \tau_2 &
   \coctx{\Gamma_2}{\aclrd{\textbf{s}}} \vdash e_2 : \tau_1 }
  {\coctx{\Gamma_1, \Gamma_2}{\aclrd{\textbf{r}\;\apar\;(\cclrd{t} \,\aseq\, \aclrd{\textbf{s}})}} \vdash e_1~e_2 : \tau_2}
\end{equation*}
\begin{equation*}
\tyrule{abs}
  {\coctx{\Gamma, x\!:\!\tau_1}{\aclrd{\textbf{r}}\,\azip\,\alift{\cclrd{s}}} \vdash e : \tau_2}
  {\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash \lambda x.e : \tau_1 \xrightarrow{\cclrd{s}} \tau_2 }
\end{equation*}
\begin{equation*}
\tyrule{let}
  { \coctx{\Gamma_1}{\aclrd{\textbf{r}}} \vdash e_1 : \tau_1 &
    \coctx{\Gamma_2, x\!:\!\tau_1}{\aclrd{\textbf{s}}\;\azip\;\alift{\cclrd{t}}} \vdash e_2 : \tau_2}
  {\coctx{\Gamma_1, \Gamma_2}{(\cclrd{t} \,\aseq\, \aclrd{\textbf{r}}) \;\apar\; \aclrd{\textbf{s}}} \vdash \kvd{let}~x=e_1~\kvd{in}~e_2 : \tau_2 }
\end{equation*}

\vspace{1em}
{\small b.) Structural rules for context manipulation:}
\begin{equation*}
\tyrule{sub}
  {\coctx{\Gamma_1,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} \azip \alift{\cclrd{s'}} \azip \aclrd{\textbf{q}}} \vdash e : \tau}
  {\coctx{\Gamma_1,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} \apar \alift{\cclrd{s}} \apar \aclrd{\textbf{q}}} \vdash e : \tau}
\quad
(\cclrd{s'} \cleq \cclrd{s})
\end{equation*}
\begin{equation*}
\tyrule{weak}
  {\coctx{\Gamma}{ \aclrd{\textbf{r}} } \vdash e : \tau}
  {\coctx{\Gamma,x \!:\! \tau_1}{\aclrd{\textbf{r}} \apar \alift{ \czero }} \vdash e : \tau} 
\end{equation*}
\begin{equation*}
\tyrule{exch}
  {\coctx{\Gamma_1,x\!:\!\tau_1,y\!:\!\tau_2,\Gamma_2}{\aclrd{\textbf{r}} \azip \alift{\cclrd{s}} \azip \alift{\cclrd{t}} \azip \aclrd{\textbf{q}}} \vdash e : \tau}
  {\coctx{\Gamma_1,y\!:\!\tau_2,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} \apar \alift{\cclrd{t}} \apar \alift{\cclrd{s}} \apar \aclrd{\textbf{q}}} \vdash e : \tau}
\quad
\begin{array}{l}
 \slen{\Gamma_1} = \alen{\aclrd{\textbf{r}}}\\[-0.25em]
 \slen{\Gamma_2} = \alen{\aclrd{\textbf{s}}}
\end{array}
\end{equation*}
\begin{equation*}
\hspace{2.5em} 
\tyrule{contr}
  {\coctx{\Gamma_1,y\!:\!\tau_1,z\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} \azip \alift{\cclrd{s}} \azip \alift{\cclrd{t}} \azip \aclrd{\textbf{q}}} \vdash e : \tau}
  {\coctx{\Gamma_1,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} \apar \alift{\cclrd{s} \,\cpar\, \cclrd{t}} \apar \aclrd{\textbf{q}}} \vdash \subst{e}{z,y}{x} : \tau}
~
\begin{array}{l}
 \slen{\Gamma_1} = \alen{\aclrd{\textbf{r}}}\\[-0.25em]
 \slen{\Gamma_2} = \alen{\aclrd{\textbf{s}}}
\end{array}
\end{equation*}

\caption{Type system for the unified coeffect calculus}
\label{fig:unif-types}
\end{figure}

% --------------------------------------------------------------------------------------------------

\subsection{Unified coeffect type system}

The unified coeffect system in Figure~\ref{fig:unif-types} resembles the structural type system
shown in Figure~\ref{fig:struct-types}. Rather than explaining the rules one-by-one, we focus on
the key differences between the two.

The type system for the unified coeffect calculus is parameterized by a coeffect scalar 
$(\C, \cseq, \cpar, \cunit, \czero, \cleq)$ together with a coeffect algebra $(\azip, \apar, \azero)$ 
and the derived constructs $\alift{-}$, $\alen{-}$ and $\aseq$. 

As in the structural system, free-variable contexts $\Gamma$ are treated as vectors modulo duplicate
use of variables -- the associativity is built-int. The order of variables matters, but can be changed 
using the structural rules. The context annotations $\aclrd{\textbf{r}}, \aclrd{\textbf{s}}, \aclrd{\textbf{t}} \in \C^\SH$ 
are shape-indexed coeffects (rather than simple vectors as before). As before, functions are
annotated with coeffects scalars. % $\cclrd{r}, \cclrd{s}, \cclrd{t} \in \C$.

\paragraph{Differences from structural system.} 

% => \azero for constants 
% => \azip in assumptions (let, abs), \apar in conclusions (let, app)
% => the same also happened in structural rules
%      --> how does that make contraction etc. permissible?
% => <s,r> -> <s> x <r>




Constants (\emph{const}) and variable access (\emph{var}) annotate the context with special
values. Empty unused context is annotated with $\azero
\in \C^\sempty$, while singleton context 
is annotated with $\aunit \in \C^\sunit$.  Note that the shapes
$\sempty, \sunit$ match the shape of the variable contexts.

Lambda abstraction \emph{splits} the context requirements using $\azip$ into a coeffect 
$\aclrd{R}$ and a coeffect $\alift{\cclrd{s}}$ of a shape $\sunit$ (semantically, it \emph{merges}
capabilities provided by the declaration-site and call-site contexts). In structural systems such
as bounded reuse, $\apar$ is not symmetric and so this gives us a coeffect associated with the bound variable.

The (\emph{app}) rule follows the patterns seen
earlier -- it uses the scalar-vector multiplication ($\cclrd{t}\,\aseq\,\aclrd{S}$) on 
coeffects associated with $\Gamma_2$.
Using the syntactic reading, it then \emph{merges} context requirements for $\Gamma_1$ and $\Gamma_2$.
In the dual semantic reading,
it \emph{splits} the provided context into two parts passed to the sub-expressions.

The typing of let-binding (\emph{let}) corresponds to the typing of an expression $(\lambda x.e_2)~e_1$.
Syntactically, the context requirements are first split using $\azip$ and then re-combined
using $\apar$. 

\paragraph{Structural rules.}
The coeffect-annotated context can be transformed using structural rules that are
not syntax-directed. These are captured by (\emph{ctx}), which uses a helper judgment representing
context transformations $\ctxtrans{ \coctx{\Gamma}{R} }{ \coctx{\Gamma'}{R'} }{\theta}$.
The rule models that a context used in the rule conclusion $\coctx{\Gamma'}{R'}$ can be transformed
to a context required by the assumptions $\coctx{\Gamma}{R}$ (using the semantic bottom-up reading).
In the rule, $\theta$ is a variable substitution generated by the transformation, which is 
used in the (\emph{contr}) rule.

Exchange and contraction decompose and reconstruct coeffect annotations 
using $\azip_{\sclrd{m},\sclrd{n}}$ (in assumption) and $\apar_{\sclrd{m},\sclrd{n}}$ (in conclusion). 
The shape subscripts are omitted, but we require the shapes to match using $\sclrd{m} = \slen{\Gamma_1}$
and $\sclrd{n} = \slen{\Gamma_2}$. 

The (\emph{weak}) rule drops an ignored variable annotated with $\aweak$ (compare with (\emph{var})
annotated using $\aunit$). The (\emph{exch}) rule switches the values 
while (\emph{contr}) combines them using $\cpar$ to represent sharing of the context.
Finally, (\emph{sub}) represents sub-coeffecting that can be applied (point-wise) to any
individual coeffect.

% --------------------------------------------------------------------------------------------------

\subsection{Structural coeffects}
\label{sec:unified-structural}

The coeffect system uses a general notion of context shape, but
it has been designed with structural and flat systems in
mind. The structural system is new in this paper and so we
look at it first.

Recall the coeffect shapes that characterise structural systems: the shape is formed by natural
numbers (with addition) modelling the number of variables in the
context. The coeffect algebra is therefore formed by the free monoid
(vectors) over a coeffect scalar. This means that the system keeps a vector
of basic coeffect annotations -- one for each variable. An empty
context (\eg{}, in the (\emph{const}) rule) is annotated with an empty
vector.

\begin{definition}
Given a coeffect scalar $(\C, \cseq, \cpar, \cunit, \czero, \cleq)$ a \emph{structural
coeffect system} has: 
\begin{itemize}{}
\item[--] Coeffect shape $\sclrd{(\mathbb{N}, {|}\textnormal{--}{|}, +, 0, 1)}$ formed by natural numbers
\item[--] Coeffect algebra $\aclrd{(\times, \times, \epsilon)}$ where $\times$ and $\epsilon$ are
  shape-indexed versions of the binary operation and the unit of a free monoid over $\C$.
  That is $\times : \C^{\sclrd{n}} \times \C^{\sclrd{m}} \rightarrow \C^{\sclrd{n + m}}$ appends vectors
  (lists) and $\epsilon : \C^{\sclrd{0}}$ represents empty vectors (lists)
\end{itemize}
\end{definition}

\noindent
The definition is valid since the shape operations form a monoid
$\sclrd{(\mathbb{N}, +, 0)}$ and $\slen{\textnormal{--}}$ (calculating the length of
a list) is a monoid homomorphism from the free monoid to the monoid of
shapes.

\paragraph{Examples.} 
Defining a concrete structural coeffect system is easy, we just provide the coeffect scalar structure and the rest is free.

\begin{itemize}
\item
To recreate the system for bounded reuse, we use coeffect scalars formed by
$(\mathbb{N}, \ast, +, 1, 0, \leq)$. As in the system of Figure~\ref{fig:bounded-coeff},
\emph{used} variables are annotated with $1$ and \emph{unused} with $0$. Contraction adds the number
of uses via $+$ and application (sequencing) multiplies the uses.

\item
\emph{Dataflow} uses natural numbers (of past values), but differently: $(\mathbb{N}, +, \mathsf{max}, 0, 0, \leq)$.
Variables are initially annotated with $0$ (and can be incremented using the \kvd{prev} keyword).
Annotations of a shared variable are combined by taking maximum (of past values needed) and
sequencing uses $+$.

\item
Another use of the system is to track \emph{variable liveness}. The annotations are formed by
$\C=\{ \mathsf{D}, \mathsf{L} \}$ where $\mathsf{L}$ represents a \emph{live} (used) variable
and $\mathsf{D}$ represents a \emph{dead} (unused) variable. The scalars are given as
$(\C, \sqcap, \sqcup, \mathsf{L}, \mathsf{D}, \sqsubseteq)$. 

In sequential composition ($\sqcap$), a variable is live only if it is required by both of the 
computations ($\mathsf{L} \sqcap \mathsf{L} = \mathsf{L}$), otherwise it is marked as 
dead ($\mathsf{D}$). A computation is not evaluated if its result is not needed.
A shared variable ($\sqcup$) is live if either of the uses is live 
($\mathsf{D} \sqcup \mathsf{D} = \mathsf{D}$, otherwise $\mathsf{L}$).
\end{itemize}

\noindent
Structural liveness is a practically useful, precise version of an example from our earlier
work, which was a flat system overapproximating liveness to the entire
context~\cite{petricek2013coeffects}.

% --------------------------------------------------------------------------------------------------

\subsection{Flat coeffects}
\label{sec:unified-flat}

The same general coeffect system can be used to define systems that track whole-context coeffects
as in the implicit parameters example 
(Section~\ref{sec:intro-coeffects-impl}). Flat coeffect systems are
characterised by a singleton set of shapes, such as ${ \{ \sflat \} }$. In
this setting, the context annotations $\C^{ \sflat }$ are
equivalent to coeffect scalars $\C$.

In addition to the coeffect scalar structure, we also need to define $\apar$ and $\azip$.
Our examples of flat coeffects use $\cpar$ (merging of scalar coeffects) for $\apar$ (merging of shaped 
coeffect annotations). However, the $\azip$ operation needs to be provided explicitly.

\begin{definition}
Given a coeffect scalar $(\C, \cseq, \cpar, \cunit, \czero, \cleq)$ and a binary 
$\cclrd{\wedge} : \C \times \C \rightarrow \C$ such that $(\cclrd{r \wedge s}) \,\cleq\, (\cclrd{r}\,\cpar\,\cclrd{s})$, we define:
\begin{itemize}{}
\item[--] Flat coeffect shape $\sclrd{(\{ \sflat \}, \emph{const} \, \sflat, \diamond, \sflat, \sflat)}$ where 
  $\sflat \diamond \sflat = \sflat$
\item[--] Flat coeffect algebra $(\cclrd{\wedge}, \cpar, \czero)$, \ie{}, the $\apar = \cpar$ and $\azero = 
\czero$ with the additional binary operation $\azip = \wedge$. 
\end{itemize}
\end{definition}

\noindent
The requirement $(\cclrd{r \wedge s}) \;\cleq\; (\cclrd{r}\,\cpar\,\cclrd{s})$ guarantees 
exchange and contraction preserve the coeffect of the assumption in the conclusion. Thus, flat coeffect
calculi do not require substructural-style rules.
 
\paragraph{Examples.}
Implicit parameters are the prime example of a flat coeffect system, but other examples
include rebindable resources \cite{app-distributed-acute} and Haskell type classes \cite{orchard2013thesis}.

In the \emph{implicit parameters} system (Section~\ref{sec:intro-coeffects-impl}), 
the co\-effect scalars are sets of names with types 
$\C = \mathcal{P}(\ident{Name} \times \ident{Types}) $. Variables
are always annotated with $\emptyset$ and coeffects are combined or split using set union $\cup$. Thus
the system is given by coeffect scalar structure $(\mathcal{P}(\ident{Name} \times \ident{Types}), \cup, \cup, \emptyset, \emptyset, \subseteq)$
with $\cclrd{\wedge} = \cup$.

\begin{remark}
We previously described flat systems for \emph{liveness} and \emph{dataflow}~\cite{petricek2013coeffects}.
Turning a structural system to flat requires finding $\wedge$ that 
underapproximates the capabilities of combined contexts. For dataflow, this is given by the \textsf{min} function as
$\mathsf{min}(\cclrd{r},\cclrd{s}) \,\cleq\, \mathsf{max}(\cclrd{r},\cclrd{s})$.

In flat \emph{dataflow}, we annotate the
entire context with the maximal number of past elements required
overall. We use the same coeffect scalars $(\mathbb{N}, +, \mathsf{max}, 0, 0, \leq)$
as in the structural version, but with
$\cclrd{\wedge} = \ident{min}$. Abstraction (which is the only rule using $\wedge$) becomes:
%%
\[
\tyrule{abs}
  { \coctx{\Gamma, x\!:\!\sigma}{\ident{min}(\cclrd{r}, \cclrd{s})} \vdash e : \tau }
  { \coctx{\Gamma}{\cclrd{r}} \vdash \lambda x . e : \sigma \xrightarrow{\cclrd{s}} \tau }
\]
%%
Both the declaration-site and the call-site need to provide at least
the number of past values required by the body. The overapproximation means that both $\cclrd{r}$
and $\cclrd{s}$ can be greater than actually required.
For dataflow, we could annotate
both contexts with the same coeffect,
but that would require treating $\azip$ as a partial function.
\end{remark}

\subsection{Semanitcs}
\label{sec:unified-semantics}

Not really - but sketch.

%===================================================================================================

\section{Semi-lattice formulation}
\label{sec:unified-semilattice}

\subsection{Semi-lattice formulation}

\begin{equation*}
\begin{array}{lcll}
 \ident{counit}_{\cunit} &\narrow{:}& 
    \ctyp{\cunit}{\alpha} \rightarrow \alpha \\
 \ident{cobind}_{\cclrd{r}, \cclrd{s}} &\narrow{:}& 
    (\ctyp{\cclrd{r}}{\alpha} \rightarrow \beta) \rightarrow (\ctyp{\cclrd{r}\cseq\cclrd{s}}{\alpha} \rightarrow \ctyp{\cclrd{s}}{\beta}) \\
\ident{merge}_{\cclrd{r},\cclrd{s}} &\narrow{:}& 
    \ctyp{\cclrd{r}}{\alpha} \times \ctyp{\cclrd{s}}{\beta} \rightarrow \ctyp{\cclrd{r}\czip\cclrd{s}}{(\alpha \times \beta)} \\
\ident{split}_{\cclrd{r},\cclrd{s}} &\narrow{:}& 
    \ctyp{\cclrd{r}\cpar\cclrd{s}}{(\alpha \times \beta)} \rightarrow \ctyp{\cclrd{r}}{\alpha} \times \ctyp{\cclrd{s}}{\beta} \\
\ident{lift}_{\cclrd{r},\cclrd{s}} &\narrow{:}& 
    \ctyp{\cclrd{r}}{\alpha} \rightarrow \ctyp{\cclrd{s}}{\alpha} & 
    (\cclrd{s}\,\cleq\,\cclrd{r})
\end{array}
\end{equation*}

Change to

\begin{equation*}
\begin{array}{lcll}
 \ident{counit}_{\cunit} &\narrow{:}& 
    \ctyp{\cunit}{\alpha} \rightarrow \alpha \\
 \ident{cobind}_{\cclrd{r}, \cclrd{s}} &\narrow{:}& 
    (\ctyp{\cclrd{r}}{\alpha} \rightarrow \beta) \rightarrow (\ctyp{\cclrd{r}\cseq\cclrd{s}}{\alpha} \rightarrow \ctyp{\cclrd{s}}{\beta}) \\
\ident{merge}_{\cclrd{r},\cclrd{s},\cclrd{t}} &\narrow{:}& 
    \ctyp{\cclrd{r}}{\alpha} \times \ctyp{\cclrd{s}}{\beta} \rightarrow \ctyp{\cclrd{t}}{(\alpha \times \beta)} &
    (\cclrd{t}\,\cleq\,\cclrd{r}, \cclrd{t}\,\cleq\,\cclrd{s}) \\
\ident{split}_{\cclrd{r},\cclrd{s},\cclrd{t}} &\narrow{:}& 
    \ctyp{\cclrd{t}}{(\alpha \times \beta)} \rightarrow \ctyp{\cclrd{r}}{\alpha} \times \ctyp{\cclrd{s}}{\beta} &
    (\cclrd{r}\,\cleq\,\cclrd{t}, \cclrd{s}\,\cleq\,\cclrd{t}) \\
\ident{lift}_{\cclrd{r},\cclrd{s}} &\narrow{:}& 
    \ctyp{\cclrd{r}}{\alpha} \rightarrow \ctyp{\cclrd{s}}{\alpha} & 
    (\cclrd{s}\,\cleq\,\cclrd{r})
\end{array}
\end{equation*}

Gives us..

\begin{figure}[t]
\begin{equation*}
\tyrule{var}
  {x : \tau \in \Gamma}
  {\coctx{\Gamma}{\cunit} \vdash x : \tau }
\end{equation*}
\begin{equation*}
\tyrule{const}
  {c : \tau \in \Delta}
  {\coctx{\Gamma}{\czero} \vdash c : \tau }
\end{equation*}
\begin{equation*}
\tyrule{sub}
  {\coctx{\Gamma}{\cclrd{r'}} \vdash e : \tau }
  {\coctx{\Gamma}{\cclrd{r}} \vdash e : \tau }\quad\quad(\cclrd{r'} \cleq \cclrd{r})
\end{equation*}
\begin{equation*}
\tyrule{app}
  {\coctx{\Gamma}{\cclrd{r}} \vdash e_1 : \tau_1 \xrightarrow{\cclrd{t}} \tau_2 &
   \coctx{\Gamma}{\cclrd{s}} \vdash e_2 : \tau_1 }
  {\coctx{\Gamma}{\cclrd{r} \;\cpar\; (\cclrd{s} \,\cseq\, \cclrd{t})} \vdash e_1~e_2 : \tau_2}
\end{equation*}
\begin{equation*}
\tyrule{abs}
  {\coctx{\Gamma, x:\tau_1}{\cclrd{r}\;\czip\;\cclrd{s}} \vdash e : \tau_2}
  {\coctx{\Gamma}{\cclrd{r}} \vdash \lambda x.e : \tau_1 \xrightarrow{\cclrd{s}} \tau_2 }
\end{equation*}
\begin{equation*}
\tyrule{let}
  { \coctx{\Gamma}{\cclrd{r}} \vdash e_1 : \tau_1 &
    \coctx{\Gamma, x:\tau_1}{\cclrd{s}} \vdash e_2 : \tau_2}
  {\coctx{\Gamma}{\cclrd{s} \;\cpar\; (\cclrd{s} \,\cseq\, \cclrd{r})} \vdash \kvd{let}~x=e_1~\kvd{in}~e_2 : \tau_2 }
\end{equation*}

\caption{Type system for the flat coeffect calculus}
\label{fig:flat-types2}
\end{figure}

q
\newpage
a
\newpage
a
\newpage


\subsection{Type inference algorithm}

% ==================================================================================================


% =================================================================================================
%                                                                   
%      ####                         #       #                   ##   
%      #   #                        #                            #   
%      #   #  # ##    ###    ###   ####    ##     ###    ###     #   
%      ####   ##  #      #  #   #   #       #    #   #      #    #   
%      #      #       ####  #       #       #    #       ####    #   
%      #      #      #   #  #   #   #  #    #    #   #  #   #    #   
%      #      #       ####   ###     ##    ###    ###    ####   ###  
%                                                                
% =================================================================================================

\section{Towards practical coeffects}
\label{sec:unified-impl}

As discussed earlier, the main focus of this thesis is the development of the much needed 
\emph{theory of context-aware computations} and so discussing the details of a practical 
implementation of coeffect tracking is beyond the scope of the thesis. However, this section
briefly outlines one possible pathway towards this goal.

Many of the examples of contextual computation that we discussed earlier have been implemented as 
a single-purpose programming language feature (\eg~implicit parameters \cite{app-implicit-parameters} 
or distributed computations \cite{app-distributed-ml5,app-distributed-links}). However, 
the main contribution of this thesis is that it captures
\emph{multiple} different notions of context-aware computations using just a \emph{single}
common abstraction. For this reason, we advocate that future practical implementations of
coeffects should not be single-purpose language features, but instead reusable abstractions that
can be instantiated with a concrete \emph{coeffect algebra} specified by the user.

In order to do this, programming languages need to provide two features; one that allows 
embedding of context-aware computations themselves in programs (akin to the ``do'' notation
in Haskell) and one that allows tracking of the contextual information in the type system.

% -------------------------------------------------------------------------------------------------

\subsection{Embedding contextual computations}

The embedding of \emph{contextual} computations in programming languages can learn from better 
explored emedding of \emph{effectful} computations. In purely functional programming languages
such as Haskell, effectful computations are embedded by \emph{implementing} them and inserting the
necessary (monadic) plumbing. This is made easier by the ``do'' notation \cite{other-haskell98} 
that inserts the monadic operations automatically.

The recently proposed ``codo'' notation \cite{comonads-codo} provides a similar plumbing for
context-aware computations based on comonads. The notation is close to the semantics of our 
flat coeffect calculus (Chapter~\ref{ch:flat}). Extending the ``codo'' notation to support calculi based 
on the structural coeffect calculus (Chapter~\ref{ch:structural}) is an interesting futrue work -- 
this requires explicitly manipulating individual context variables and application of structural
rules, which is not needed in flat coeffects.

In ML-like languages, effects (and many coeffects) are built-in into the language semantics, 
but they can still use a special notation for explicitly marking effectful (coeffectful) 
blocks of code. In F\#, this is done using \emph{computation expressions}  \cite{app-computation-zoo}
that differ from the ``do'' notation in two ways. First, they support wider range of 
constructs, making it possible to wrap existing F\# code in a block without other changes.
Second, they support other abstractions including monads, applicative functors and monad
transformers. It would be interesting to see if computation expressions can be extended to
handle computations based on flat/structural indexed comonads.

More lightweight syntax for effectful computation can be obtained using
techniques that automatically insert the necessary monadic plumbing (wihtout a
special syntax). This has been done in the context of effecful computations \cite{monads-lightweight-ml}
and similar approach would be worth exploring for coeffects. 

% -------------------------------------------------------------------------------------------------

\subsection{Coeffect annotations as types}

The other aspect of practical implementation of coeffects is tracking the context requirements
(coeffect annotations) in the type system. To achieve this (without resorting to a single-purpose
language feature) the type system needs to be able to capture various kinds of coeffect algebras. 
The structures used in this thesis include sets (with union or interesection), natural numbers (with 
addition, maximum, minimum and multiplication), two-point lattice (for liveness) and free monoids 
(vectors of annotations).

The work on embedding effect systems in Haskell \cite{effects-embedding} shows that the
recent additions to the Haskell type system provide enough poer to implement structures such
as sets at the type level. Using these to embed coeffect systems in Haskell is one fruitful 
future direction for applied coeffects.  

In dependently-typed programming languages such as Agda \cite{other-agda} or Idris \cite{other-idris},
the embedding of coeffects can be implemented more directly. However, we believe that coeffect
tracking does not require full dependent types and can be made accessible in more main-stream
languages. Dependent ML \cite{types-dependent-ml} provides an interesting example of a language
with some dependent typing which is still close to its non-dependently-typed predecessor ML.

Another approach for embedding computations into the type system has been pioneered by F\#
\emph{type providers} \cite{app-inforich}. Technically, type providers are compiler extensions 
that generate types based on external data sources or other information in order to provide easy 
access to data or services. A similar approach could be used for embedding \emph{algberas} such
as coeffect algebras into the type system. A \emph{algebra provider} would be a library that 
specifies the objects of the algebra, equational laws and generalization rules for type inference.
This could provide an easy to use way of embedding coeffect tracking in pragmatic languages
such as F\#. It is worth noting that the mechanism could also subsume F\# units of measure
\cite{types-units-of-measure}, which could be provided via one such \emph{algebra provider}.



% =================================================================================================
%                                                                                             
%    #   #          #                    ##                                                    
%    #   #          #                     #                                                    
%    ## ##   ###   ####    ###            #     ###   # ##    ## #  #   #   ###    ## #   ###  
%    # # #  #   #   #         #  #####    #        #  ##  #  #  #   #   #      #  #  #   #   # 
%    #   #  #####   #      ####           #     ####  #   #   ##    #   #   ####   ##    ##### 
%    #   #  #       #  #  #   #           #    #   #  #   #  #      #  ##  #   #  #      #     
%    #   #   ###     ##    ####          ###    ####  #   #   ###    ## #   ####   ###    ###  
%                                                            #   #                #   #        
%                                                             ###                  ###         
% =================================================================================================

\section{Coeffect meta-language}
\label{sec:unified-meta} 

In Section~\ref{sec:path-sem-langs}, we discussed two ways of using monads in programming
language semantics introduced by Moggi \cite{monad-notions}. The first approach is to use
monads in the \emph{semantics} of an effectful language. The second approach is to extend the
language with (additional) monadic constructs that can then be used for writing effectful
monads explicitly.

In this thesis, we focused on the first approach. In both flat and structural coeffect calculi,
the term language is that of simply-typed $\lambda$-calculus, and we used (flat or structural)
indexed comonads to give the semantics for the language and to derive type system for it.

In this section, we briefly discuss the alternative approach. That is, we embed indexed
comonads into a $\lambda$-calculus as additional constructs. To do that, we introduce the
type constructor $\ctyp{\cclrd{r}}{\tau}$ which represents a value $\tau$ wrapped in additional
context (semantically, this corresponds to an indexed comonad) and we add language constructs
that correspond to the operations of indexed comonads.

This section provides a brief sketch of coeffect meta-language to highlight the relationship
between coeffects and important related work on contextual modal type theory (CMTT) \cite{logic-cmtt}.
Developing the system further is an interesting future research direction.

% -------------------------------------------------------------------------------------------------

\subsection{Coeffects and contextual modal type theory}

As discussed in Section~\ref{sec:path-sem-contextdep}, context-aware computations are related
to modal logics -- comonads have been used to model the $\square$ modality and as a basis for
meta-languages that include $\square$ as a type constructor
\cite{logic-intuitionistic-modal,logic-modal-reconstruction,logic-intuitionistic-modal,logic-cmtt}.
Nanevski et al. \cite{logic-cmtt} extend an S4 term language to a contextual modal type theory (CMTT).
From the perspective of this thesis, CMTT can be viewed as a \emph{meta-language} version of our
coeffect calculus.

\paragraph{Context in CMTT and coeffects.}
Aside from the fact that coeffect calculi use comonads for \emph{semantics} and CMTT embeds
comonads (the $\square$ modality) into the meta-language, there are two important differences.

Firstly, the \emph{context} in CMTT is a set of variables required by a computation, which
makes CMTT useful for meta-programming and staged computations. In coeffect calculi, the context
requirements are formed by a coeffect algebra, which is more general and can capture
variable contexts, but also integers, two-point lattices, \emph{etc.}

Secondly, CMTT uses different intuitive understanding of the comonad (type constructor) and
the associated operations. In categorical semantics of coeffect calculi, the $\ctyp{\cclrd{r}}{\tau}$
constructor refers to a value of type $\tau$ \emph{together} with additional context specified
by $\cclrd{r}$ (\eg~list of past values or additional resources). In contrast in 
CMTT\footnote{To avoid using different notations, we write $\ctyp{\Psi}{\tau}$ instead of the 
original $[\Psi]{\tau}$} the type $\ctyp{\Psi}{\tau}$ models a value that \emph{requires} the 
context $\Psi$ in order to produce value $\tau$. This also changes the interpretation of the 
two operations of a comonad:
\begin{equation*}
\begin{array}{rcl}
 \ident{counit} &\narrow{:}& \ctyp{\cunit}{\alpha} \rightarrow \alpha\\
 \ident{cobind} &\narrow{:}& (\ctyp{\cclrd{r}}{\alpha} \rightarrow \beta) \rightarrow 
    \ctyp{\cclrd{r}\cseq\cclrd{s}}{\alpha} \rightarrow \ctyp{\cclrd{s}}{\beta}
\end{array}
\end{equation*}
Both readings are possible, but they give quite different meanings to the operations:

\begin{itemize}
\item \emph{Coeffect interpretation.} The \ident{counit} operation extracts a value 
  and does not require any additional context; the \ident{cobind} operation requires
  context $\cclrd{r}\,\cseq\,\cclrd{s}$, uses the part specified by $\cclrd{r}$ to 
  evaluate the function, ending with a value $\beta$ together with remaining context
  $\cclrd{s}$.
\item \emph{CMTT interpretation.} The \ident{counit} operation evaluates a computation 
  that requires no additional context to obtain a $\alpha$ value; given a function that
  turns a computation requiring context $\cclrd{r}$ into a value $\beta$, the \ident{cobind}
  operation can turn a computation that requires context $\cclrd{r}\,\cseq\,\cclrd{s}$ 
  into a computation that requires just $\cclrd{s}$ and contains $\beta$ (a part of the
  context requirements is eliminated by the function).
\end{itemize}

\noindent
Although the different reading does not affect formal properties of the systems, it is important
to understand the difference when discussing the two systems. 

The sketch of a coeffect meta-language in the following section attempts to bridge the gap
between coeffects and CMTT. Just like CMTT, it embeds comonads as language constructs, but
it annotates them with a (flat) coeffect algebra, thus it generalizes CMTT which tracks only
sets of variables. Future work on the coeffect meta-language would thus be an interesting 
development for both coeffect systems and CMTT.

% -------------------------------------------------------------------------------------------------

\subsection{Coeffect meta-language}

The coeffect meta-langauge could be designed using both flat and structural indexed comonads.
For simplicity, this section only discusses the flat variant. The syntax of types and terms
of the langauge includes the type constructor $\ctyp{\cclrd{r}}{\tau}$ and four expression forms:
%
\begin{equation*}
\begin{array}{rcl}
 \tau &\narrow{::=}& \alpha \sep \tau_1 \rightarrow \tau_2 \sep \ctyp{\cclrd{r}}{\tau}\\
 e &\narrow{::=}& v \sep \lambda x.e \sep e_1~e_2 \sep !e    \\[-0.25em]
  &        \sep& \kvd{let\;box}~x=e_1~\kvd{in}~e_2           \\[-0.25em]
  &        \sep& \kvd{split}~e_1~\kvd{into}~x,y~\kvd{in}~e_2 \\[-0.25em]
  &        \sep& \kvd{merge}~e_1, e_2~\kvd{into}~x~\kvd{in}~e_2 
\end{array}
\end{equation*}
%
The $!e$ and $\kvd{let\;box}$ constructs correspond to the \ident{counit} and \ident{cobind}
operation of the comonad. To define meta-langauge for flat indexed comonads, we also include 
\kvd{split} and \kvd{merge} that embed the corresponding operations. 

\paragraph{Types for coeffect meta-language.}
The type system for the language is shown in Figure~\ref{fig:conclusions-cml}. The first part
shows the usual typing rules for simply-typed $\lambda$-calculus. For simplicity, we omit typing 
rules for pairs, but those need to be present as the \kvd{merge} operation works on tuples.

The second part of the typing rules is more interesting. The (\emph{counit}) operation extracts
a value from a comonadic context and corresponds to variable access in coeffect calculi. The
\kvd{let\;box} construct (\emph{cobind}) takes an input $e_1$ with context $\cclrd{r}\,\cseq\,\cclrd{s}$
and a computation that turns a variable $x$ with a context $\cclrd{r}$ into a value $\tau_2$.
The result is a computation that produces a $\tau_2$ value with the remaining context specified
by $\cclrd{s}$. Note that the expression $e_2$ and $e_1$ corresponds to the first and second
arguments of the \ident{cobind} operation. The keyword \kvd{let\;box} is chosen following 
CMTT\footnote{The rule is similar to the \ident{letbox} rule for ICML \cite[p. 14]{logic-cmtt},
although it differs because of our generalization of comonads where \ident{bind} composes
coeffect annotations rather than requiring the same annotation everywhere.}.

The \kvd{split} and \kvd{merge} constructs follow a similar pattern. They both apply some 
transformation on one or two values in a context and then add the new value as a fresh variable
to the variable context. For simplicity, we omit sub-coeffecting, but it could be easily added 
following the pattern used elsewhere.

% -------------------------------------------------------------------------------------------------

\begin{figure}[t]

{\small a.) Typing rules for the simply typed $\lambda$-calculus}

\begin{equation*}
\tyrule{var}
  {x : \tau \in \Gamma}
  {\Gamma \vdash x : \tau }
\end{equation*}
\begin{equation*}
\tyrule{app}
  {\Gamma \vdash e_1 : \tau_2 \rightarrow \tau_1 &
   \Gamma \vdash e_2 : \tau_2 }
  {\Gamma \vdash e_1~e_2 : \tau_1 }
\end{equation*}
\begin{equation*}
\tyrule{abs}
  {\Gamma, x:\tau_1 \vdash e : \tau_2}
  {\Gamma \vdash \lambda x.e : \tau_1 \rightarrow \tau_2 }
\end{equation*}

\vspace{1em}
{\small b.) Additional typing rules arising from \emph{flat indexed comonads}}

\begin{equation*}
\tyrule{cobind}
  {\Gamma \vdash e_1 : \ctyp{\cclrd{r}\,\cseq\,\cclrd{s}}{\tau_1} & \Gamma, x : \ctyp{\cclrd{r}}{\tau_1} \vdash e_2 : \tau_2 }
  {\Gamma \vdash \kvd{let\;box}~x=e_1~\kvd{in}~e_2 : \ctyp{\cclrd{s}}{\tau_2}}
\end{equation*}
\begin{equation*}
\tyrule{counit}
  {\Gamma \vdash e : \ctyp{\cunit}{\tau}}
  {\Gamma \vdash !e : \tau}
\end{equation*}
\begin{equation*}
\tyrule{split}
  {\Gamma \vdash e_1 : \ctyp{\cclrd{r}\,\cpar\,\cclrd{s}}{\tau_1} &
   \Gamma, x:\ctyp{\cclrd{r}}{\tau_1}, y:\ctyp{\cclrd{s}}{\tau_1} \vdash e_2 : \tau_2 }
  {\Gamma \vdash \kvd{split}~e_1~\kvd{into}~x,y~\kvd{in}~e_2 : \tau_2 }
\end{equation*}
\begin{equation*}
\tyrule{merge}
  {\Gamma \vdash e_1 : \ctyp{\cclrd{r}}{\tau_1} &
   \Gamma \vdash e_2 : \ctyp{\cclrd{s}}{\tau_2} \\
   \Gamma, x:\ctyp{\cclrd{r}\,\czip\,\cclrd{s}}{(\tau_1 \times \tau_2)} \vdash e_2 : \tau_3 }
  {\Gamma \vdash \kvd{merge}~e_1, e_2~\kvd{into}~x~\kvd{in}~e_2 : \tau_3 }
\end{equation*}

\caption{Type system for the (flat) coeffect meta-language}
\label{fig:conclusions-cml}
\end{figure}

% -------------------------------------------------------------------------------------------------

\subsection{Embedding flat coeffect calculus}

The \emph{meta-language} approach of embedding comonads in a language is more general than the
\emph{semantics} approach. This thesis focuses on a narrower use that better guides the design of
a type system for context-aware programming languages. 

However, it is worth noting that 
(flat) coeffect calculus can be embedded in the meta-language described above. This may be 
desirable, \eg~when using the meta-language for reasoning about context-aware computations. 
We briefly consider the embedding as it illuminates the relationship between coeffects and
CMTT (although it is not possible to embed coeffect calculi in CMTT because of the more general
annotations structure).

Given a typing judgement $\coctx{\Gamma}{\cclrd{r}} \vdash e : \tau$ in a flat coeffect calculus,
we define $\sem{\coctx{\Gamma}{\cclrd{r}} \vdash e : \tau}_v$ as its emebdding in the coeffect
meta-language. Note that the translation is indexed by $v$, which is a name of variable used 
to represent the entire variable context of the source language. The translation is defined in
Figure~\ref{fig:conclusions-embed}. The embedding resembles the semantics discussed in 
Section~\ref{sec:flat-semantics}. This is not surprising as the meta-language directly mirrors
the operations of a monad.

% -------------------------------------------------------------------------------------------------

\begin{figure}[t]
\begin{equation*}
\begin{array}{l}
 \sem{ \coctx{\Gamma}{\cunit}\vdash x_i : \tau_i }_v = \pi_i (!v) \\[0.25em]
 \sem{ \coctx{\Gamma}{\cclrd{r}\;\cpar\;(\cclrd{s}\,\cseq\,\cclrd{t})} \vdash e_1~e_2 : \tau_2 }_v =\\[-0.25em]
   \qquad \kvd{split}~v~\kvd{into}~v_s, v_{rt}~\kvd{in} \\[-0.25em]
   \qquad \sem{ \coctx{\Gamma}{\cclrd{s}} \vdash e_1 : \tau_1 \xrightarrow{\cclrd{t}} \tau_2 }_{v_s}
      ~(\kvd{let\;box}~v_r = v_{rt}~\kvd{in}~\sem{ \coctx{\Gamma}{\cclrd{r}} \vdash e_2 : \tau_1}_{v_r}) \\[0.25em]
 \sem{ \coctx{\Gamma}{\cclrd{r}} \vdash \lambda x.e:\tau_1 \xrightarrow{\cclrd{s}} \tau_2 }_v = \lambda x. \\[-0.25em]
   \qquad \kvd{merge}~v,x~\kvd{into}~v_{rs}~\kvd{in}~\sem{ \coctx{(\Gamma,x:\tau_1)}{\cclrd{r}\,\czip\,\cclrd{s}} \vdash e : \tau_2 }_{v_{rs}}
\end{array}
\end{equation*}
\caption{Embedding flat coeffect calculus in coeffect meta-language }
\label{fig:conclusions-embed}
\end{figure}


\section{Conclusions}
