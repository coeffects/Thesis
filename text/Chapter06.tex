%!TEX root = ../main.tex

\chapter{Unified coeffect language} 
\label{ch:unified} 

%===================================================================================================

\section{Introduction}

%===================================================================================================

\section{Semi-lattice formulation}
\label{sec:unified-semilattice}

\subsection{Semi-lattice formulation}
\subsection{Type inference algorithm}

% ==================================================================================================

\newcommand{\tystmt}[2]{ (\text{\footnotesize{#1}})~~{#2} }
\newcommand{\ctxtrans}[3]{ #2 \rightsquigarrow #1, #3 }
\newcommand{\ctxtransnl}[3]{ \begin{array}{l} #2 \rightsquigarrow\\ #1, #3 \end{array}}

\newcommand{\SH}{ {\textcolor{sclr}{\mathcal{S}}} }
\newcommand{\sempty}{ {\textcolor{sclr}{ \hat{0}}} }
\newcommand{\sunit}{ {\textcolor{sclr}{\hat{1}}} }
\newcommand{\stimes}{ {\textcolor{sclr}{\diamond}} }
\newcommand{\sflat}{\star}

\newcommand{\amerge}{ \textcolor{aclr}{ \mathbin{\rotatebox[origin=c]{-90}{$\ltimes$}} } }
\newcommand{\asplit}{ \textcolor{aclr}{ \mathbin{\rotatebox[origin=c]{90}{$\ltimes$}} } }
\newcommand{\azero}{ \textcolor{aclr}{\bot} }
\newcommand{\aunit}{ \alift{\cunit} } %\textcolor{aclr}{\textnormal{U}} }
\newcommand{\aweak}{ \alift{\czero} } % \textcolor{aclr}{\textnormal{I}} }

\newcommand{\fcons}{ \times } 
\newcommand{\fempty}{\epsilon}


\section{The unified coeffect calculus}

\subsection{Structure of coeffects}

We describe the algebraic structure of coeffects in three
steps. First, we define a \emph{\cclrd{coeffect scalar}} structure 
which defines the basic building blocks of coeffect information;
then we define \emph{\sclrd{coeffect shapes}} which determines how
coeffect scalar values are related to the free-variable context. 
Finally, we define the \emph{\aclrd{coeffect
    algebra}} which consists of shape-indexed coeffect scalar values.

For example, in bounded reuse the coeffect scalar structure
comprised natural numbers $\cclrd{\mathbb{N}}$ with $\cclrd{+}$ and
$\cclrd{\ast}$ operators. The shape for bounded reuse is the length of the
free-variable context and so the coeffect annotation is a vector of matching length.
Finally, the coeffect algebra specifies how vectors are
concatenated and split in abstraction and application. 

In the coeffect system of the calculus, contexts are annotated with shape-indexed coeffects (\eg{}, vectors)  as in
$\coctx{\Gamma}{\aclrd{R}} \vdash e : \tau$. However, functions take just a single 
input parameter and so are annotated with scalar coeffect values as in $\sigma \xrightarrow{\cclrd{r}} \tau$.

\paragraph{Coeffect scalar.}
Coeffect scalar structures are equipped with two operations. In bounded reuse, those 
were $\cclrd{\ast}$ for sequencing (in function application) and $\cclrd{+}$ for context 
sharing (in contraction). Additional structure is needed for variable access and sub-coeffecting.

\begin{definition}
\emph{\cclrd{Coeffect scalar}} $(\C, \cseq, \cpar, \cunit, \czero, \cleq)$ is a set $\C$
together with elements $\cunit,\czero \in \C$, relation $\cleq$ and binary operations 
$\cseq, \cpar$ such that $(\C, \cseq, \cunit)$ and $(\C, \cpar, \czero)$ are monoids
and $(\C, \cleq)$ is a pre-order. The following distributivity axioms are required:
\begin{align*}
(\cclrd{r}\, \cpar\, \cclrd{s}) \;\cseq\; \cclrd{t} & = (\cclrd{r} \,\cseq\, \cclrd{t}) \;\cpar\; (\cclrd{s}\, \cseq\, \cclrd{t}) \\
\cclrd{t} \;\cseq\; (\cclrd{r}\, \cpar\, \cclrd{s}) & = (\cclrd{t} \,\cseq\, \cclrd{r}) \;\cpar\; (\cclrd{t}\, \cseq\, \cclrd{s})
\end{align*}
\end{definition}

\noindent
The operation $\cseq$ must form a monoid with $\cunit$ to guarantee an underlying 
category in the semantics. 
It models sequential composition with variable access
($\cunit$) as the identity. The other element ($\czero$) is used for
variables that are not accessed. The operation $\cpar$ combines coeffects
for contexts used in multiple places (contraction). 
The notation is inspired by the bounded reuse example, which uses coeffect scalar structure
$(\cclrd{\mathbb{N}}, \ast, +, 1,0, \cclrd{\leq})$, but be aware that $\cseq$ and $\cpar$ do
not always mean $\ast$ and $+$.

The context annotations can be viewed as \emph{containers} of scalar coeffects.
For structural coeffects, the container is a vector, while for flat coeffects, it is
a trivial singleton container. We take inspiration from the work of Abbott \emph{et al.}~\cite{types-containers}
which describes containers in terms of \emph{shapes} and a set of \emph{positions} in each shape.

\paragraph{Coeffect shapes.}
The coeffect system is parameterised by a set of shapes $\SH$. A coeffect annotation 
is indexed by a shape $\sclrd{s} \in \SH$ calculated from the shape of the free-variable vector. The correspondence is not necessarily 
bijective. For example, flat coeffect systems have just a single shape $\SH = \{ \ast \}$.

In the coeffect judgment $\coctx{\Gamma}{\aclrd{R}} \vdash e : \tau$, the coeffect annotation
$\aclrd{R}$ is drawn from the set of coeffect scalars $\C$ indexed by the shape of $\Gamma$.
We write $\aclrd{s} = \slift{\Gamma}$ for the shape corresponding to $\Gamma$. We define shapes by a 
\emph{set} of positions and so we can write $\aclrd{R} \in \sclrd{s} \rightarrow \C$ as a
mapping from positions (defined by the shape) to scalar coeffects. We usually write this as 
the exponent $\aclrd{R} \in \C^{\sclrd{s}}$.

The set of shapes is equipped with an operation that combines shapes (when we combine 
variable contexts), an operation that computes shape from the free-variable contexts, 
and two special shapes in $\SH$ representing empty context and singleton context. 

\begin{definition}
  A \emph{\sclrd{coeffect shape}} structure $(\SH, \slift{\textnormal{--}}, \stimes,
  \sempty, \sunit)$ comprises a set $\SH$ with a binary operation
  $\stimes$ on $\SH$ for shape composition, a mapping from contexts to
  shapes $\slift{\Gamma} \in \SH$, and elements $\sempty,\sunit \in
  \SH$ such that $(\SH, \stimes, \sempty)$ is a monoid. The 
  elements $\sempty$ and $\sunit$ represent the shapes of empty and
  singleton free-variable contexts respectively.
\end{definition}

\noindent
As said earlier, we use two kinds of shape structures that describe the shape
of vectors and the shape of trivial singleton container: 

\begin{itemize}
\item
Structural coeffect shape is defined as $\sclrd{(\mathbb{N}, {|}\textnormal{--}{|}, +, 0, 1)}$.
We treat numbers as sets $0 = \{\}, 1=\{ \emptyset \}, 2=\{ \emptyset, 1\}, 3=\{\emptyset, 1, 2 \} \ldots$ 
(so that a number is a set of positions). The shape mapping ${|}\Gamma{|}$ returns the number
of variables in $\Gamma$. Empty and singleton contexts are annotated with $0$ and $1$, respectively,
and shapes of combined contexts are added so that ${|}\Gamma_1, \Gamma_2{|} = {|}\Gamma_1{|} + {|}\Gamma_2{|}$.
Therefore, a coeffect annotation is a \emph{vector} $\aclrd{R} \in
\C^{\sclrd{n}}$ and assigns a coeffect scalar $\aclrd{R}(i) \in \C$ for each
variable $x_i$ in the context.

\item
Flat coeffect shape is defined as $\sclrd{(\{\sflat \}, \mathsf{const}\,\,\sflat, \diamond, \sflat, \sflat)}$ where
$\sflat\,\diamond\,\sflat = \sflat$ and $\star=\{\emptyset\}$. That is, there is a single shape
$\sflat$ with a single position and all free-variable contexts have the same singleton shape.
Therefore, a coeffect annotation is drawn from $\C^{\sflat}$ which is iso\-morphic to $\C$
and so a coeffect scalar $\cclrd{r}\in \C$ is associated with every free-variable context.
\end{itemize}

\noindent
Using a shape with \emph{no} positions reduces our system to the simply-typed $\lambda$-calculus with no context annotations.
Trees could be used to build a system akin to bunched typing \cite{substruct-bunched}.

\paragraph{Coeffect algebra.}
The coeffect calculus annotates judgments with 
shape-indexed (or, \emph{shaped}) coeffects.
The \emph{\aclrd{coeffect
    algebra}} structure combines a coeffect scalar and coeffect shape structures
to define shaped coeffects and operations for combining these.
In Section~\ref{sec:intro-coeffects}, shaped coeffects were combined
by the tensor $\times$ in structural examples and
$\cup$ in the implicit parameters example. To capture the examples so far and
those described previously~\cite{petricek2013coeffects}, we distinguish two
operators for combining shaped coeffects. 

\begin{definition}
  Given a \cclrd{coeffect scalar} $(\C, \cseq, \cpar, \cunit, \czero,
  \cleq)$ and a \sclrd{coeffect shape} $(\SH, \slift{\textnormal{--}}, \stimes,
  \sempty, \sunit)$ a \emph{\aclrd{coeffect algebra}} extends the two
  structures with $(\amerge, \asplit, \azero)$ where $\azero \in
  \C^{\sempty}$ is a coeffect annotation for the empty context and
  $\amerge, \asplit$ are families of operations that combine coeffect
  annotations indexed by shapes. That is $\forall \sclrd{n},\sclrd{m}
  \in \SH$:
\[
\asplit_{\sclrd{m},\sclrd{n}}, \amerge_{\sclrd{m},\sclrd{n}} ~:~ \C^{\sclrd{m}} \times \C^{\sclrd{n}} \rightarrow \C^{\sclrd{m}\,\stimes\,\sclrd{n}}
\]
\end{definition}

\noindent
A coeffect algebra induces the following two additional operations:
\[
\begin{array}{rclrcl}
\alift{\textnormal{--}} &\narrow{:}& \C \rightarrow \C^{\sunit}          \quad\quad
   & \aseq_{\sclrd{m}} &\narrow{:}&  \C \times \C^{\sclrd{m}} \rightarrow \C^{\sclrd{m}}  
\\ 
\alift{\cclrd{x}} &\narrow{=}& \lambda \sunit . \cclrd{x}  
   & \cclrd{r}\ \aseq\ \aclrd{S} &\narrow{=}& \lambda \sclrd{s} . \cclrd{r}\ \cseq\ (\aclrd{S}(\sclrd{s}))
\end{array}
\]
$\alift{\textnormal{--}}$ lifts a scalar coeffect 
to a shaped coeffect indexed by the singleton context shape. 
The $\aseq_{\sclrd{m}}$ operation is a left multiplication of a vector by scalar.
As we always use lower-case for scalars and upper-case for vectors, using the same
symbol is not ambiguous. We also tend to omit the subscript
$\sclrd{m}$ and write just $\aseq$.

The operators $\asplit$ and $\amerge$ combine shaped
coeffects associated with two contexts. For example,
assume we have $\Gamma_1$ and $\Gamma_2$ with coeffects 
$\aclrd{R} \in \C^{\sclrd{m}}$ and $\aclrd{S} \in \C^{\sclrd{n}}$. In
the structural system, the context shapes $\sclrd{m}, \sclrd{n}$
denote the number of variables in the two contexts. The combined
context $\Gamma_1, \Gamma_2$ has a shape $\sclrd{m}\,\stimes\,\sclrd{n}$ and
the combined coeffects $\aclrd{R} \,\amerge\, \aclrd{S}, \aclrd{R} \,\asplit\, \aclrd{S} \in \C^{\sclrd{m} \stimes \sclrd{n}}$
are indexed by that shape.

For structural coeffect systems such as bounded reuse, both $\asplit$ and $\amerge$ are
just the tensor product $\times$ of vectors. However, we need to distinguish them for flat coeffect 
systems discussed later. 

The difference is explained by the semantics (Section~\ref{sec:semantics}), where
$\aclrd{R}\,\amerge\,\aclrd{S}$ is an annotation of the codomain of 
a morphism that merges the capabilities provided by two contexts (in the syntactic 
reading, splits the context requirements); $\aclrd{R}\,\asplit\,\aclrd{S}$ is an annotation of
the domain of a morphism that splits the capabilities of a single context into two parts (in the
syntactic reading, merges their context requi\-rements). Syntactically, this means that we always use
$\amerge$ in the rule \emph{assumptions} and $\asplit$ in \emph{conclusions}. For now, it suffices to use the 
bounded reuse intuition and read the operations as tensor products.

% --------------------------------------------------------------------------------------------------


\begin{figure}[t]
$\boxed{
\coctx{\Gamma}{R} \vdash e : \tau
}$
\[
\begin{array}{c}
\tyrule{const}{\;}
  { \coctx{ () }{ \azero } \vdash c : \iota }
\quad\quad
\tyrule{var}{\;}
  { \coctx{ (x:\tau) }{ \aunit } \vdash x : \tau }
\\[1.8em]
\tyrule{abs}
  { \coctx{\Gamma, x : \sigma}{\aclrd{R}\; \amerge \, \alift{\cclrd{s}}} \vdash e : \tau }
  { \coctx{\Gamma}{\aclrd{R}} \vdash \lambda x . e : \sigma \xrightarrow{\cclrd{s}} \tau }
\\[1.8em]
\tyrule{app}
  { \coctx{\Gamma_1}{\aclrd{R}} \vdash e_1 : \tau \xrightarrow{\cclrd{t}} \sigma &
    \coctx{\Gamma_2}{\aclrd{S}} \vdash e_2 : \tau }
  {\coctx{\Gamma_1, \Gamma_2}{ \aclrd{R} \;\asplit\; (\cclrd{t} \,\aseq\, \aclrd{S}) } \vdash e_1~e_2 : \sigma } 
\\[1.8em]
\tyrule{let}
  { \coctx{\Gamma_1}{\aclrd{S}} \vdash e_1 : \sigma & 
    \coctx{\Gamma_2, x:\sigma}{\aclrd{R}\; \amerge\; \alift{\cclrd{t}}} \vdash e_2 : \tau  }
  { \coctx{\Gamma_1, \Gamma_2}{\aclrd{R}\; \asplit\; (\cclrd{t} \,\aseq\, \aclrd{S}) } \vdash \kvd{let}~x=e_1~\kvd{in}~e_2 : \tau }
\\[1.8em]
\tyrule{ctx}
  { \coctx{\Gamma}{\aclrd{R}} \vdash e : \tau & \ctxtrans{ \coctx{\Gamma}{\aclrd{R}} }{ \coctx{\Gamma'}{\aclrd{R'}} }{\theta}}
  { \coctx{\Gamma'}{\aclrd{R'}} \vdash \theta e : \tau }
\end{array}
\]

$\boxed{
\ctxtrans{ \coctx{\Gamma}{R} }{ \coctx{\Gamma'}{R'} }{\theta}
}$

\[
\tystmt{weak}
  { \quad\quad 
    \ctxtrans{ \coctx{\Gamma}{\aclrd{R}} }{ \coctx{\Gamma, x:\tau}{\aclrd{R}\; \asplit\; \aweak } }{\emptyset}
    \quad\quad\quad }
\]
\[ 
\tystmt{exch}
  { \ctxtransnl{ \coctx{\Gamma_1, x:\tau, y:\sigma, \Gamma_2}{\aclrd{R} \,\amerge\, \alift{\cclrd{s}} \,\amerge\, \alift{\cclrd{t}} \,\amerge\, \aclrd{Q}} }
               { \quad \coctx{\Gamma_1, y:\sigma, x:\tau, \Gamma_2}{\aclrd{R} \,\asplit\, \alift{\cclrd{t}} \,\asplit\, \alift{\cclrd{s}} \,\asplit\, \aclrd{Q}} }{\emptyset} }
\]
\[
\tystmt{contr}
  { \ctxtransnl{ \coctx{\Gamma_1, y:\tau, z:\tau, \Gamma_2}{\aclrd{R} \,\amerge\, \alift{\cclrd{s}} \,\amerge\, \alift{\cclrd{t}} \,\amerge\, \aclrd{Q} } }
               { \quad \coctx{\Gamma_1, x:\tau, \Gamma_2}{\aclrd{R}\, \asplit\, \alift{\cclrd{s}\, \cpar\, \cclrd{t}} \,\asplit\, \aclrd{Q}} }{[y,z \mapsto x]}}
\]
\[
\tystmt{sub}
  { \ctxtransnl{ \coctx{\Gamma_1, x:\tau,\Gamma_2}{\aclrd{R} \,\amerge\, \alift{\cclrd{s}} \,\amerge\, \aclrd{T} } }
               { \quad \coctx{\Gamma_1, x:\tau, \Gamma_2}{\aclrd{R}\, \asplit\, \alift{\cclrd{s'}} \,\asplit\, \aclrd{T}} }{\emptyset} }
\quad(\cclrd{s} \;\cleq\; \cclrd{s'} )                 
\]
\caption{The general coeffect calculus}
\vspace{-1em}
\label{fig:unified-coeffects}
\end{figure}

% --------------------------------------------------------------------------------------------------

\subsection{General coeffect type system}

In the previous section, we developed an algebraic structure capable of
capturing different concrete context-dependent properties discussed in
Section~\ref{sec:intro-coeffects}. Now, we use the structure to
define the general coeffect calculus in
Figure~\ref{fig:coeffects-general}.

Coeffect annotations on free-variable contexts
are shape-indexed coeffects $\aclrd{R}, \aclrd{S}, \aclrd{T} \in \C^\SH$ 
and function types are annotated with
coeffects scalars $\cclrd{r}, \cclrd{s}, \cclrd{t} \in \C$.  The
rules manipulate coeffect annotations using the operations provided by
coeffect algebra $(\amerge, \asplit, \azero)$ and the derived
constructs $\alift{\textnormal{--}}$ and $\aseq$. Free-variable contexts $\Gamma$
are treated as vectors modulo duplicate use of variables 
-- the associativity is built-in. The order of
variables matters, but can be changed using the structural rules. To
make the system easier to follow, structural rules are expressed
using a separate judgment.

\paragraph{Typing rules.} 
Constants (\emph{const}) and variable access (\emph{var}) annotate the context with special
values. Empty unused context is annotated with $\azero
\in \C^\sempty$, while singleton context 
is annotated with $\aunit \in \C^\sunit$.  Note that the shapes
$\sempty, \sunit$ match the shape of the variable contexts.

Lambda abstraction \emph{splits} the context requirements using $\amerge$ into a coeffect 
$\aclrd{R}$ and a coeffect $\alift{\cclrd{s}}$ of a shape $\sunit$ (semantically, it \emph{merges}
capabilities provided by the declaration-site and call-site contexts). In structural systems such
as bounded reuse, $\asplit$ is not symmetric and so this gives us a coeffect associated with the bound variable.

The (\emph{app}) rule follows the patterns seen
earlier -- it uses the scalar-vector multiplication ($\cclrd{t}\,\aseq\,\aclrd{S}$) on 
coeffects associated with $\Gamma_2$.
Using the syntactic reading, it then \emph{merges} context requirements for $\Gamma_1$ and $\Gamma_2$.
In the dual semantic reading,
it \emph{splits} the provided context into two parts passed to the sub-expressions.

The typing of let-binding (\emph{let}) corresponds to the typing of an expression $(\lambda x.e_2)~e_1$.
Syntactically, the context requirements are first split using $\amerge$ and then re-combined
using $\asplit$. 

\paragraph{Structural rules.}
The coeffect-annotated context can be transformed using structural rules that are
not syntax-directed. These are captured by (\emph{ctx}), which uses a helper judgment representing
context transformations $\ctxtrans{ \coctx{\Gamma}{R} }{ \coctx{\Gamma'}{R'} }{\theta}$.
The rule models that a context used in the rule conclusion $\coctx{\Gamma'}{R'}$ can be transformed
to a context required by the assumptions $\coctx{\Gamma}{R}$ (using the semantic bottom-up reading).
In the rule, $\theta$ is a variable substitution generated by the transformation, which is 
used in the (\emph{contr}) rule.

Exchange and contraction decompose and reconstruct coeffect annotations 
using $\amerge_{\sclrd{m},\sclrd{n}}$ (in assumption) and $\asplit_{\sclrd{m},\sclrd{n}}$ (in conclusion). 
The shape subscripts are omitted, but we require the shapes to match using $\sclrd{m} = \slift{\Gamma_1}$
and $\sclrd{n} = \slift{\Gamma_2}$. 

The (\emph{weak}) rule drops an ignored variable annotated with $\aweak$ (compare with (\emph{var})
annotated using $\aunit$). The (\emph{exch}) rule switches the values 
while (\emph{contr}) combines them using $\cpar$ to represent sharing of the context.
Finally, (\emph{sub}) represents sub-coeffecting that can be applied (point-wise) to any
individual coeffect.

% --------------------------------------------------------------------------------------------------

\subsection{Structural coeffects}
\label{sec:unified-structural}

The coeffect system uses a general notion of context shape, but
it has been designed with structural and flat systems in
mind. The structural system is new in this paper and so we
look at it first.

Recall the coeffect shapes that characterise structural systems: the shape is formed by natural
numbers (with addition) modelling the number of variables in the
context. The coeffect algebra is therefore formed by the free monoid
(vectors) over a coeffect scalar. This means that the system keeps a vector
of basic coeffect annotations -- one for each variable. An empty
context (\eg{}, in the (\emph{const}) rule) is annotated with an empty
vector.

\begin{definition}
Given a coeffect scalar $(\C, \cseq, \cpar, \cunit, \czero, \cleq)$ a \emph{structural
coeffect system} has: 
\begin{itemize}{}
\item[--] Coeffect shape $\sclrd{(\mathbb{N}, {|}\textnormal{--}{|}, +, 0, 1)}$ formed by natural numbers
\item[--] Coeffect algebra $\aclrd{(\fcons, \fcons, \fempty)}$ where $\fcons$ and $\fempty$ are
  shape-indexed versions of the binary operation and the unit of a free monoid over $\C$.
  That is $\fcons : \C^{\sclrd{n}} \times \C^{\sclrd{m}} \rightarrow \C^{\sclrd{n + m}}$ appends vectors
  (lists) and $\fempty : \C^{\sclrd{0}}$ represents empty vectors (lists)
\end{itemize}
\end{definition}

\noindent
The definition is valid since the shape operations form a monoid
$\sclrd{(\mathbb{N}, +, 0)}$ and $\slift{\textnormal{--}}$ (calculating the length of
a list) is a monoid homomorphism from the free monoid to the monoid of
shapes.

\paragraph{Examples.} 
Defining a concrete structural coeffect system is easy, we just provide the coeffect scalar structure and the rest is free.

\begin{itemize}
\item
To recreate the system for bounded reuse, we use coeffect scalars formed by
$(\mathbb{N}, \ast, +, 1, 0, \leq)$. As in the system of Figure~\ref{fig:bounded-coeff},
\emph{used} variables are annotated with $1$ and \emph{unused} with $0$. Contraction adds the number
of uses via $+$ and application (sequencing) multiplies the uses.

\item
\emph{Dataflow} uses natural numbers (of past values), but differently: $(\mathbb{N}, +, \mathsf{max}, 0, 0, \leq)$.
Variables are initially annotated with $0$ (and can be incremented using the \kvd{prev} keyword).
Annotations of a shared variable are combined by taking maximum (of past values needed) and
sequencing uses $+$.

\item
Another use of the system is to track \emph{variable liveness}. The annotations are formed by
$\C=\{ \mathsf{D}, \mathsf{L} \}$ where $\mathsf{L}$ represents a \emph{live} (used) variable
and $\mathsf{D}$ represents a \emph{dead} (unused) variable. The scalars are given as
$(\C, \sqcap, \sqcup, \mathsf{L}, \mathsf{D}, \sqsubseteq)$. 

In sequential composition ($\sqcap$), a variable is live only if it is required by both of the 
computations ($\mathsf{L} \sqcap \mathsf{L} = \mathsf{L}$), otherwise it is marked as 
dead ($\mathsf{D}$). A computation is not evaluated if its result is not needed.
A shared variable ($\sqcup$) is live if either of the uses is live 
($\mathsf{D} \sqcup \mathsf{D} = \mathsf{D}$, otherwise $\mathsf{L}$).
\end{itemize}

\noindent
Structural liveness is a practically useful, precise version of an example from our earlier
work, which was a flat system overapproximating liveness to the entire
context~\cite{petricek2013coeffects}.

% --------------------------------------------------------------------------------------------------

\subsection{Flat coeffects}
\label{sec:unified-flat}

The same general coeffect system can be used to define systems that track whole-context coeffects
as in the implicit parameters example 
(Section~\ref{sec:intro-coeffects-impl}). Flat coeffect systems are
characterised by a singleton set of shapes, such as ${ \{ \sflat \} }$. In
this setting, the context annotations $\C^{ \sflat }$ are
equivalent to coeffect scalars $\C$.

In addition to the coeffect scalar structure, we also need to define $\asplit$ and $\amerge$.
Our examples of flat coeffects use $\cpar$ (merging of scalar coeffects) for $\asplit$ (merging of shaped 
coeffect annotations). However, the $\amerge$ operation needs to be provided explicitly.

\begin{definition}
Given a coeffect scalar $(\C, \cseq, \cpar, \cunit, \czero, \cleq)$ and a binary 
$\cclrd{\wedge} : \C \times \C \rightarrow \C$ such that $(\cclrd{r \wedge s}) \,\cleq\, (\cclrd{r}\,\cpar\,\cclrd{s})$, we define:
\begin{itemize}{}
\item[--] Flat coeffect shape $\sclrd{(\{ \sflat \}, \emph{const} \, \sflat, \diamond, \sflat, \sflat)}$ where 
  $\sflat \diamond \sflat = \sflat$
\item[--] Flat coeffect algebra $(\cclrd{\wedge}, \cpar, \czero)$, \ie{}, the $\asplit = \cpar$ and $\azero = 
\czero$ with the additional binary operation $\amerge = \wedge$. 
\end{itemize}
\end{definition}

\noindent
The requirement $(\cclrd{r \wedge s}) \;\cleq\; (\cclrd{r}\,\cpar\,\cclrd{s})$ guarantees 
exchange and contraction preserve the coeffect of the assumption in the conclusion. Thus, flat coeffect
calculi do not require substructural-style rules.
 
\paragraph{Examples.}
Implicit parameters are the prime example of a flat coeffect system, but other examples
include rebindable resources \cite{app-distributed-acute} and Haskell type classes \cite{orchard2013thesis}.

In the \emph{implicit parameters} system (Section~\ref{sec:intro-coeffects-impl}), 
the co\-effect scalars are sets of names with types 
$\C = \mathcal{P}(\ident{Name} \times \ident{Types}) $. Variables
are always annotated with $\emptyset$ and coeffects are combined or split using set union $\cup$. Thus
the system is given by coeffect scalar structure $(\mathcal{P}(\ident{Name} \times \ident{Types}), \cup, \cup, \emptyset, \emptyset, \subseteq)$
with $\cclrd{\wedge} = \cup$.

\begin{remark}
We previously described flat systems for \emph{liveness} and \emph{dataflow}~\cite{petricek2013coeffects}.
Turning a structural system to flat requires finding $\wedge$ that 
underapproximates the capabilities of combined contexts. For dataflow, this is given by the \textsf{min} function as
$\mathsf{min}(\cclrd{r},\cclrd{s}) \,\cleq\, \mathsf{max}(\cclrd{r},\cclrd{s})$.

In flat \emph{dataflow}, we annotate the
entire context with the maximal number of past elements required
overall. We use the same coeffect scalars $(\mathbb{N}, +, \mathsf{max}, 0, 0, \leq)$
as in the structural version, but with
$\cclrd{\wedge} = \ident{min}$. Abstraction (which is the only rule using $\wedge$) becomes:
%%
\[
\tyrule{abs}
  { \coctx{\Gamma, x\!:\!\sigma}{\ident{min}(\cclrd{r}, \cclrd{s})} \vdash e : \tau }
  { \coctx{\Gamma}{\cclrd{r}} \vdash \lambda x . e : \sigma \xrightarrow{\cclrd{s}} \tau }
\]
%%
Both the declaration-site and the call-site need to provide at least
the number of past values required by the body. The overapproximation means that both $\cclrd{r}$
and $\cclrd{s}$ can be greater than actually required.
For dataflow, we could annotate
both contexts with the same coeffect,
but that would require treating $\amerge$ as a partial function.
\end{remark}

% ==================================================================================================


\section{Conclusions}
