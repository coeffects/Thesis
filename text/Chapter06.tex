\chapter{The structural coeffect calculus}
\label{ch:structural}

In Chapter~\ref{ch:applications}, we discussed two notions of context. Context-aware programming
languages that capture whole-context properties were generalized by the \emph{flat coeffect
calculus} in Chapters~\ref{ch:flat} and \ref{ch:semantics}. Here, we consider per-variable
contextual properties and we introduce the \emph{structural coeffect calculus}.

The flat coeffect system captures a number of interesting use-cases (implicit parameters, liveness
and dataflow), but provides relatively imprecise approximation and weak syntactical properties.
Some of those examples can be also seen as per-variable properties. For those, structural coeffect
systems give a more precise information about the context. However, we also look at other applications
that arise from the work on sub-structural logics, a pathway to coeffects discussed in
Section~\ref{sec:path-logic}.

We mirror the development for flat coeffect calculus and develop a small calculus with a type system
that captures per-variable contextual properties. We outline its categorical semantics and use it as
a basis for a translation that turns well-typed programs in context-aware languages into well-typed
programs in a simple target functional language. We prove syntactic safety for a sample target
language, showing that ``well-typed context-aware programs do not get stuck''.

\paragraph{Chapter structure and contributions}
\begin{itemize}
\item We present a \emph{structural coeffect calculus} as a type system that is parameterized
  by a \emph{structural coeffect algebra} (Section~\ref{sec:struct-calculus}. We show how the
  system captures fine-grained liveness and dataflow information, as well as a calculus for bounded
  reuse (checking how many times is a variable accessed).

\item We present a syntax-directed version of the calculus that is used to obtain unique typing
  derivation for programs in structural coeffect calculus (Section~\ref{sec:struct-unique}).
  Unlike in flat systems, the procedure for choosing a unique typing derivation is common to all
  structural systems.

\item We discuss the equational theory of the calculus. For structural coeffects, the substitution
  lemma holds for all instances of the calculus. Thus, we prove the type-preservation property
  for all structural calculi for both call-by-name and call-by-value (Section~\ref{sec:struct-syntax}).

\item We extend indexed comonads introduced in the previous chapter to \emph{structural indexed
  comonads} and use them to provide the semantics of structural coeffect calculus
  (Section~\ref{sec:struct-semantics}). As with the flat version, the theory serves as a motivation
  for syntactic translational semantics.

\item We give a \emph{translational semantics} (Section~\ref{sec:struct-transl}) that translates
  programs from the structural coeffect calculus into a simple functional language with
  uninterpreted comonadically-inspired primitivies. We give concrete operational semantics for the
  target language for one of our sample langauges and show that well-typed programs, produced by
  translation from the coeffect calculus do not get stuck.
\end{itemize}


% ==================================================================================================
%
%    ###
%     #  #    # ##### #####   ####  #####  #    #  ####  ##### #  ####  #    #
%     #  ##   #   #   #    # #    # #    # #    # #    #   #   # #    # ##   #
%     #  # #  #   #   #    # #    # #    # #    # #        #   # #    # # #  #
%     #  #  # #   #   #####  #    # #    # #    # #        #   # #    # #  # #
%     #  #   ##   #   #   #  #    # #    # #    # #    #   #   # #    # #   ##
%    ### #    #   #   #    #  ####  #####   ####   ####    #   #  ####  #    #
%
% ==================================================================================================

\section{Introduction}
\label{sec:structural-intro}

Compared to Chapter~\ref{ch:flat}, structural coeffect calculi we consider are more homogeneous and
so finding the common pattern is easier. However, the systems are more complicated as they need to
keep annotations attached to individual variables and thus require explicit structural rules. Before
looking at the system, we briefly consider the most important related work.

%---------------------------------------------------------------------------------------------------

\subsection{Related work}

In the previous chapter, we discussed the correspondence between coeffects and effects (and
between comonads and monads). As noted in Section~\ref{sec:applications-strucutre-vec}, the
$\lambda$-calculus is asymmetric in that an expression has multiple inputs (variables in the
context), but just a single result (the resulting value) and so monads and effects have no notion
directly corresponding to structural coeffect systems.

The work in this chapter is more closely related to sub-structural type systems \cite{substruct-attpl-intro}.
Sub-structural systems remove some or all of \emph{weakening}, \emph{contraction} and
\emph{exchange} rules. In contrast, our systems keep all three structural rules, but use them to
manipulate the coeffect annotations in a way that matches the variable manipulations.

Our work follows the ``language semantics'' style in that we provide a structural semantics to
the terms of ordinary $\lambda$-calculus. By contrast the most closely related work has been done in
the meta-language style, which extends the terms and types of a language with constructs for explicitly
manipulating the context. This includes Contextual Modal Type Theory (CMTT) \cite{logic-cmtt}, where variables
may be of a type $A[\Psi]$ denoting a value of type $A$ that requires context $\Psi$. In CMTT,
$A[\Psi]$ is a first-class type, while structural coeffect systems do not expose coeffect
annotations as stand-alone types (indexed comonads only appear in the semantics).

Our structural coeffect systems annotate the whole variable context with a \emph{vector} of annotations.
For example, a context with variables $x$ and $y$ annotated with $\cclrd{s}$ and $\cclrd{t}$,
respectively is written as $\coctx{x\!:\!\tau_1,y\!:\!\tau_2}{\alift{\cclrd{s},\cclrd{t}}}$.
A benefit of this approach is that the typing judgements have the same structure as those of the
flat coeffect calculus. As discussed in Chapter~\ref{ch:unified}, this makes it possible to unify
the two systems.


% =================================================================================================
%
%     #####
%    #     #   ##   #       ####  #    # #      #    #  ####
%    #        #  #  #      #    # #    # #      #    # #
%    #       #    # #      #      #    # #      #    #  ####
%    #       ###### #      #      #    # #      #    #      #
%    #     # #    # #      #    # #    # #      #    # #    #
%     #####  #    # ######  ####   ####  ######  ####   ####
%
% =================================================================================================

\section{Structural coeffect calculus}
\label{sec:struct-calculus}

In the structural coeffect calculus, a vector of variables forming the free-variable context is
annotated with a vector of primitive (scalar) coeffect annotations. These annotations differ
for different coeffect calculi and their properties are captured by the definition of \emph{structural
coeffect scalar} below. The scalar annotations can be \eg~integers (how many past values we
need) or values of a two-point lattice specifying whether a variable is live or not.

Scalar annotations are written as $\cclrd{r}, \cclrd{s}, \cclrd{t}$ (following the style used in
the previous chapter). Functions always have exactly one input variable and so they are annotated
with a single coeffect scalar. Thus the expressions and types of structural coeffect calculi are the
same as in the previous chapter. The only difference is that $\cclrd{r}, \cclrd{s}, \cclrd{t}$ now
range over values of a \emph{structural coeffect scalar} rather than over values of a \emph{flat
coeffect algebra} (the definitions are related, but not the same).
%
\begin{equation*}
\begin{array}{rcl}
e &::=& x n \sep \sep \lambda x:\tau.e \sep e_1~e_2 \sep \kvd{let}~x = e_1~\kvd{in}~e_2\\
\tau &::=& \ident{num} \sep \tau_1 \xrightarrow{\cclrd{r}} \tau_2
\end{array}
\end{equation*}
%
In the previous chapter, the free variable context $\Gamma$ was treated as a set. In the
structural coeffect calculus, the order of variables matters. Thus we treat a free variable
context as a vector with a uniqueness condition. We also write $\xlen{-}$ for the length
of the vector:
%
\begin{equation*}
\begin{array}{rcl}
 \Gamma &\narrow{=}& \langle x_1\!:\!\tau_1, \ldots, x_n\!:\!\tau_n \rangle \qquad \textnormal{such that}~~\forall i, j ~.~ i \neq j \implies x_i \neq x_j\\
 \xlen{\Gamma} &\narrow{=}& n
\end{array}
\end{equation*}
%
For readability, we use the usual notation $x_1\!:\!\tau_1, \ldots, x_1\!:\!\tau_1 \vdash e : \tau$ for
typing judgements, but the free variable context should be understood as a vector.
Furthermore, the notation $\Gamma_1, \Gamma_2$ is here seen as the tensor product.
Given $\Gamma_1 = \langle x_1\!:\!\tau_1, \ldots, x_n\!:\!\tau_n \rangle $ and
$\Gamma_2 = \langle x_{n+1}\!:\!\tau_{n+1}, \ldots, x_m\!:\!\tau_m \rangle $ then
$\Gamma_1, \Gamma_2 = \Gamma_1 \times \Gamma_2 = \langle x_1\!:\!\tau_1, \ldots, x_m\!:\!\tau_m \rangle$.

Free variable contexts are annotated with vectors of structural coeffect scalars. We write vectors
of coeffects as $\alift{\cclrd{r_1}, \ldots, \cclrd{r_n}}$. Meta-variables ranging over vectors are
written as $\aclrd{\textbf{r}}, \aclrd{\textbf{s}}, \aclrd{\textbf{t}}$ (using bold face
and colour to distinguish them from scalar meta-variables) and the length of a coeffect vector
is written as $\alen{\aclrd{\textbf{r}}}$. The structure for working with vectors
of coeffects is provided by the definition of \emph{structural coeffect algebra} discussed next.

% -------------------------------------------------------------------------------------------------

\subsection{Structural coeffect algebra}

The \emph{structural coeffect scalar} structure is similar to \emph{flat coeffect algebra} with the
exception that it drops the $\czip$ operation. It only provides a monoid $(\C, \cseq, \cunit)$
modelling sequential composition of computations and a monoid $(\C, \cpar, \czero)$ representing
pointwise composition, as well as a relation $\cleq$ that defines sub-coeffecting.

\begin{definition}
\label{def:structural-scalar}
A \emph{\cclrd{structural coeffect scalar}} $(\C, \cseq, \cpar, \cunit, \czero, \cleq)$ is a set
$\C$ together with elements $\cunit, \czero \in \C$, binary operations $\cseq, \cpar$ such that
$(\C, \cseq, \cunit)$ and $(\C, \cpar, \czero)$ are monoids and a binary relation $\cleq$ such
that $(\C, \cleq)$ is a pre-order. That is, for all $r,s,t\in \C$:
%
\begin{equation*}
\begin{array}{ccr}
r \;\cseq\; (s \;\cseq\; t) = (r \;\cseq\; s) \;\cseq\; t  &
\cunit \;\cseq\; r = r = r \;\cseq\; \cunit &
\textnormal{(monoid)}
\\
r \;\cpar\; (s \;\cpar\; t) = (r \;\cpar\; s) \;\cpar\; t &
\czero \;\cpar\; r = r = r \;\cpar\; \czero &
\textnormal{(monoid)}
\\
\textnormal{if}~~r\; \cleq\; s ~~\textnormal{and}~~s\; \cleq\; t~~\textnormal{then}~~r\; \cleq\; t&
t\; \cleq\; t &
\textnormal{(pre-order)}
\\
\end{array}
\end{equation*}
%
The following distributivity axioms hold:
\begin{align*}
\quad (\cclrd{r}\, \cpar\, \cclrd{s}) \;\cseq\; \cclrd{t} & = (\cclrd{r} \,\cseq\, \cclrd{t}) \;\cpar\; (\cclrd{s}\, \cseq\, \cclrd{t}) \\
\quad \cclrd{t} \;\cseq\; (\cclrd{r}\, \cpar\, \cclrd{s}) & = (\cclrd{t} \,\cseq\, \cclrd{r}) \;\cpar\; (\cclrd{t}\, \cseq\, \cclrd{s})
\end{align*}
%
In addition, we require the following two properties of $\czero, \cpar$ and $\cleq$:
\begin{equation*}
\begin{array}{l}
 \quad \cclrd{r}\,\cleq\,\cclrd{r'} \; \Rightarrow \; \forall\cclrd{s}.\;(\cclrd{r}\,\cseq\,\cclrd{s})\;\cleq\;(\cclrd{r'}\,\cseq\,\cclrd{s}) \\
 \quad \czero\;\cleq\;(\czero\,\cseq\,\cclrd{r})
\end{array}
\end{equation*}
\end{definition}

\noindent
The structural coeffect scalar structure resembles flat coeffect algebra, but it differs in a
number of important ways:
%
\begin{itemize}
\item The $\cpar$ operation of structural coeffect scalar is not required to be idempotent. In structural
  systems, we can track individual variable accesses and not requiring idempotence allows interesting
  systems such as the one for bounded reuse (Section~\ref{sec:struct-semantics-examples}).

\item In the flat coeffect calculus, we used the $\czip$ operation to merge the annotations of contexts
  available from the declaration site and the call site or, in the syntactic reading, to split the
  context requirements. In structural systems, this is handled directly by vectors and so $\czip$
  is no longer needed.

\item We now require two properties that relate the ordering $\cleq$ with coeffects composed
  via $\cpar$ and with $\czero$. These were previously required for bottom-pointed substitution lemma
  (Lemma~\ref{thm:cbn-substitution-bot}). Here, we require them for all structural coeffects as it holds
  for all our examples; it is needed for the structural version of the substitution lemma
  (Lemma~\ref{thm:structural-substitution}).
\end{itemize}

\noindent
In the structural coeffect calculus, the scalar coeffect structure is supplemented by a vector
structure. Combining and splitting of coeffects becomes just vector concatenation or splitting,
respectively; these are provided by the tensor product. The operations on vectors are indexed by
integers representing the lengths of the vectors. The additional structure required by the type
system for structural coeffect calculi is given by the following definition.

\begin{definition}
A \emph{\aclrd{structural coeffect algebra}} is formed by a structural coeffect scalar
$(\C, \cseq, \cpar, \cunit, \czero, \cleq)$ equipped with the following additional structures:

\begin{itemize}
\item Coeffect vectors $\aclrd{\textbf{r}}, \aclrd{\textbf{s}}, \aclrd{\textbf{t}}$, ranging over
  structural coeffect scalars indexed by vector lengths $\sclrd{m}, \sclrd{n} \in \sclrd{\mathbb{N}}$.

\item An operation that constructs a vector from scalars indexed by the vector length
  $\alift{-}_{\sclrd{n}} : \C \times \ldots \times \C \rightarrow \C^{\sclrd{n}}$
  and an operation that returns the vector length such that
  $\alen{\aclrd{\textbf{r}}} = \sclrd{n}$ for $\aclrd{\textbf{r}} : \C^{\sclrd{n}}$

\item A pointwise extension of the $\cseq$ operator written as $\cclrd{t} \,\aseq\, \aclrd{\textbf{s}}$
  such that\\ $\cclrd{t} \,\aseq\, \alift{\cclrd{r_1}, \ldots, \cclrd{r_n}} =
    \alift{\cclrd{t} \,\cseq\,\cclrd{r_1}, \ldots, \cclrd{t} \,\cseq\,\cclrd{r_n}}$.

\item An indexed tensor product $\atimes_{\sclrd{n},\sclrd{m}} : \C^{\sclrd{n}} \times \C^{\sclrd{m}} \rightarrow \C^{\sclrd{n}+\sclrd{m}}$
  that is used in both directions -- for vector concatenation and for splitting --
  which is defined as $\alift{\cclrd{r_1}, \ldots, \cclrd{r_n}}
     \atimes_{\sclrd{n}, \sclrd{m}} \alift{\cclrd{s_1}, \ldots, \cclrd{s_m}}
   = \alift{\cclrd{r_1}, \ldots, \cclrd{r_n}, \cclrd{s_1}, \ldots, \cclrd{s_m}}$
\end{itemize}
\end{definition}

\noindent
The fact that the tensor product $\atimes_{\sclrd{n},\sclrd{m}}$ is indexed by the lengths
of the two vectors means that we can use it unambiguously for both concatenation of vectors
and for splitting of vectors, provided that the lengths of the resulting vectors are known.
In the following text, we usually omit the indices and write just
$\aclrd{\textbf{r}} \atimes \aclrd{\textbf{s}}$, because the lengths of the coeffect vectors
can be determined from the lengths of the matching free variable context vectors.
More generally, we could see the the coeffect annotations as \emph{containers}
\cite{types-containers}. This approach is used in Chapter~\ref{ch:unified} to unify flat
and structural systems.

%---------------------------------------------------------------------------------------------------

\begin{figure}[t]
{\small a.) Syntax-driven typing rules:}
\begin{equation*}
\tyrule{var}
  { }
  {\coctx{x\!:\!\tau}{\alift{\cunit}} \vdash x : \tau }
\end{equation*}
\begin{equation*}
\tyrule{const}
  { }
  {\coctx{()}{\alift{}} \vdash n : \ident{num} }
\end{equation*}
\begin{equation*}
\tyrule{app}
  {\coctx{\Gamma_1}{\aclrd{\textbf{r}}} \vdash e_1 : \tau_1 \xrightarrow{\cclrd{t}} \tau_2 &
   \coctx{\Gamma_2}{\aclrd{\textbf{s}}} \vdash e_2 : \tau_1 }
  {\coctx{\Gamma_1, \Gamma_2}{\aclrd{\textbf{r}\;\atimes\;(\cclrd{t} \,\aseq\, \aclrd{\textbf{s}})}} \vdash e_1~e_2 : \tau_2}
\end{equation*}
\begin{equation*}
\tyrule{abs}
  {\coctx{\Gamma, x\!:\!\tau_1}{\aclrd{\textbf{r}}\,\atimes\,\alift{\cclrd{s}}} \vdash e : \tau_2}
  {\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash \lambda x:\tau_1.e : \tau_1 \xrightarrow{\cclrd{s}} \tau_2 }
\end{equation*}
\begin{equation*}
\tyrule{let}
  { \coctx{\Gamma_1}{\aclrd{\textbf{r}}} \vdash e_1 : \tau_1 &
    \coctx{\Gamma_2, x\!:\!\tau_1}{\aclrd{\textbf{s}}\;\atimes\;\alift{\cclrd{t}}} \vdash e_2 : \tau_2}
  {\coctx{\Gamma_1, \Gamma_2}{(\cclrd{t} \,\aseq\, \aclrd{\textbf{r}}) \;\atimes\; \aclrd{\textbf{s}}} \vdash \kvd{let}~x=e_1~\kvd{in}~e_2 : \tau_2 }
\end{equation*}

\vspace{1em}
{\small b.) Structural rules for context manipulation:}
\begin{equation*}
\tyrule{weak}
  {\coctx{\Gamma}{ \aclrd{\textbf{r}} } \vdash e : \tau}
  {\coctx{\Gamma,x \!:\! \tau_1}{\aclrd{\textbf{r}} \atimes \alift{ \czero }} \vdash e : \tau}
\end{equation*}
\begin{equation*}
\tyrule{exch}
  {\coctx{\Gamma_1,x\!:\!\tau_1,y\!:\!\tau_2,\Gamma_2}{\aclrd{\textbf{r}} \atimes \alift{\cclrd{s},\cclrd{t}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}
  {\coctx{\Gamma_1,y\!:\!\tau_2,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} \atimes \alift{\cclrd{t},\cclrd{s}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}
\quad
\begin{array}{l}
 \xlen{\Gamma_1} = \alen{\aclrd{\textbf{r}}}\\[-0.25em]
 \xlen{\Gamma_2} = \alen{\aclrd{\textbf{s}}}
\end{array}
\end{equation*}
\begin{equation*}
\hspace{2.5em}
\tyrule{contr}
  {\coctx{\Gamma_1,y\!:\!\tau_1,z\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} \atimes \alift{\cclrd{s},\cclrd{t}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}
  {\coctx{\Gamma_1,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} \atimes \alift{\cclrd{s} \,\cpar\, \cclrd{t}} \atimes \aclrd{\textbf{q}}} \vdash \subst{e}{z,y}{x} : \tau}
~
\begin{array}{l}
 \xlen{\Gamma_1} = \alen{\aclrd{\textbf{r}}}\\[-0.25em]
 \xlen{\Gamma_2} = \alen{\aclrd{\textbf{s}}}
\end{array}
\end{equation*}

\vspace{1em}
{\small c.) Non-syntax-directed subcoeffecting rule:}
\begin{equation*}
\tyrule{sub}
  {\coctx{\Gamma_1,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} \atimes \alift{\cclrd{s'}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}
  {\coctx{\Gamma_1,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} \atimes \alift{\cclrd{s}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}
\quad
(\cclrd{s'} \cleq \cclrd{s})
\end{equation*}

\figcaption{Type system for the structural coeffect calculus}
\label{fig:struct-types}
\end{figure}

%---------------------------------------------------------------------------------------------------

\subsection{Structural coeffect types}
\label{sec:struct-calculus-types}

The type system for the structural coeffect calculus is similar to sub-structural type systems
in how it handles free variable contexts. The \emph{syntax-driven} rules do not implicitly allow
weakening, exchange or contraction -- this is done by checking the types of sub-expressions
in disjoint parts of the free variable context. Unlike in sub-structural logics, our system
does allow weakening, exchange and contraction, but via explicit \emph{structural} rules that
perform corresponding transformation on the coeffect annotation.

\paragraph{Syntax-driven rules.}
The syntax-driven rules of the type system are shown in Figure~\ref{fig:struct-types} (a).
The variable access rule (\emph{var}) annotates the corresponding variable as being accessed
using $\cunit$. Note that, as in sub-structural systems, the free variable context contains
\emph{only} the accessed variable. Other variables can be introduced using explicit weakening.
Constants (\emph{const}) are type checked in an empty variable context, which is annotated with
an empty vector of coeffect annotations.

The (\emph{abs}) rule assumes that the free variable context of the body can be split into
a potentially empty \emph{declaration site} and a singleton context containing the bound
variable. The corresponding splitting is performed on the coeffect vector, uniquely associating
the annotation $\cclrd{s}$ with the bound variable $x$. This means that the typing rule removes
non-determinism of the type inference present in flat coeffect systems.

In (\emph{app}), the sub-expressions $e_1$ and $e_2$ use free variable contexts $\Gamma_1, \Gamma_2$
with coeffect vectors $\aclrd{\textbf{r}}, \aclrd{\textbf{s}}$, respectively. The function
value is annotated with a coeffect scalar $\cclrd{t}$.
The coeffect annotation of the composed expression is obtained by combining the annotations
associated with variables in $\Gamma_1$ and $\Gamma_2$. Variables in $\Gamma_1$ are only
used to obtain the function value, resulting in coeffects $\aclrd{\textbf{r}}$. The
variables in $\Gamma_2$ are used to obtain the argument value, which is then sequentially
composed with the function, resulting in $\cclrd{t}\,\aseq\,\aclrd{\textbf{s}}$.

\paragraph{Structural rules.}
The rules shown in Figure~\ref{fig:struct-types} (b) are not syntax-directed and
allow different transformation of the free variable context. They correspond to the
transformations known as \emph{weakening}, \emph{exchange} and \emph{contraction}
from sub-structural systems.

Rule (\emph{weak}) allows adding a variable to the context, extending the coeffect
vector with $\czero$ to mark it as unused, (\emph{exch}) provides a way to rearrange variables
in the context, performing the same reordering on the coeffect vector. Finally recall that
variables in the free variable context are required to be \emph{unique}. The (\emph{contr}) rule
allows re-using a variable. We can type check sub-expressions using two separate variables and
then unify them using substitution. The resulting variable is annotated with $\cpar$ and it
is the only place in the structural coeffect system where context requirements are combined
(semantically, this is where the available context is shared).

\paragraph{Subcoeffecting.}
Finbally, Figure~\ref{fig:struct-types} (c) shows the subcoeffecting rule (\emph{sub}).
As with the flat coeffect calculus, we include it mainly to guide the understanding of the
system, but we treat it as an additional rule and do not discuss it in the subsequent theory.
The rule would be needed in languages with conditionals and other language features. It is
worth noting that allowing subcoeffecting on coeffect scalars belonging to individual variables
is sufficient for structural systems.

%---------------------------------------------------------------------------------------------------

\subsection{Understanding structural coeffects}

The type system for structural coeffects appears more complicated when compared to the flat
version, but it is in many ways simpler -- it removes the ambiguity arising from the use
of $\czip$ in lambda abstraction and, as discussed in Section~\ref{sec:struct-syntax}, has
a cleaner equational theory.

\paragraph{Flat and structural context.} In flat systems, lambda abstraction splits context
requirements using $\czip$ and application combines them using $\cpar$. In the structural
version, both of these are replaced with $\atimes$. The $\czip$ operation is not needed, but
$\cpar$ is still used in the (\emph{contr}) rule.

This suggests that $\czip$ and $\cpar$ serve two roles in flat coeffects. First, they are used
as over-approximations and under-approximations of $\atimes$. This is demonstrated by the
(\emph{approximation}) requirement introduced in Section~\ref{sec:flat-syntax-cbv}, which requires that
$\cclrd{r}\,\czip\,\cclrd{t}\;\cleq\;\cclrd{r}\,\cpar\,\cclrd{t}$. Semantically, flat abstraction
combines two values representing the available context, potentially discarding parts of it
(under-approximation), while flat application splits the available context (a single value),
potentially duplicating parts of it (over-approxi\-mation)\footnote{Because of this duality, earlier
version of coeffect systems \cite{coeffects-icalp13} used $\wedge$ and $\vee$.}.

Secondly, the operator $\cpar$ is used when the semantics passes a given context to multiple
sub-expressions. In flat systems, the context is shared in (\emph{app}) and (\emph{pair}), because
the sub-expressions may share variables. In structural systems, the sharing is isolated into an
explicit contraction rule.

\paragraph{Let binding.}
The other aspect that makes structural systems simpler is that they remove the need for
separate let binding. As discussed in Section~\ref{sec:flat-exts-let}, flat calculi include
let binding that gives a \emph{more precise} typing than combination of abstraction and
application. Structural coeffect systems avoid this issue.

\begin{remark}[Let binding]
\label{thm:structural-letbinding}
In a structural coeffect calculus, the typing of $\kvd{let}~x=e_1~\kvd{in}~e_2$ can be
seen as a derived rule, \ie~its typing is equivalent to the typing of the expression
$(\lambda x.e_2)~e_1$.

\end{remark}
\begin{proof}
Consider the following typing derivation for $(\lambda x.e_2)~e_1$. Note that
in the last step, we apply (\emph{exch}) repeatedly to swap $\Gamma_1$ and $\Gamma_2$.
%
\begin{equation*}
\inference
  { \begin{array}{l}\coctx{\Gamma_1}{\aclrd{\textbf{r}}} \vdash e_1 : \tau_1\vspace{-1.6em}\end{array} &
    \inference
      { \coctx{\Gamma_2, x\!:\!\tau_1}{\aclrd{\textbf{s}}\;\atimes\;\alift{\cclrd{t}}} \vdash e_2 : \tau_2 }
      { \coctx{\Gamma_2}{\aclrd{\textbf{s}}} \vdash \lambda x.e_2 : \tau_1 \xrightarrow{\cclrd{t}} \tau_2} \vspace{0.2em} }
  { \inference
      { \coctx{\Gamma_2, \Gamma_1}{\aclrd{\textbf{s}} \;\atimes\; (\cclrd{t} \,\aseq\, \aclrd{\textbf{r}})} \vdash (\lambda x.e_2)~e_1 : \tau_2 }
      { \coctx{\Gamma_1, \Gamma_2}{(\cclrd{t} \,\aseq\, \aclrd{\textbf{r}}) \;\atimes\;  \aclrd{\textbf{s}} } \vdash (\lambda x.e_2)~e_1 : \tau_2 } }
\end{equation*}

\noindent
The assumptions and conclusions match those of the (\emph{let}) rule.
\end{proof}


%---------------------------------------------------------------------------------------------------

\subsection{Examples of structural coeffects}

The structural coeffect calculus above can be instantiated to obtain the 3 structural coeffect calculi
presented in Section~\ref{sec:applications-structural}. Two of them -- structural dataflow and
structural liveness provide a more precise tracking of properties that can be tracked using
flat systems. Formally, any flat coeffect algebra can be turned into a structural coeffect scalar
(by dropping the $\czip$ operator), but this does not always give us a meaningful system -- for
example, implicit parameters could be attached to individual variables, but, to our knowledge, this
has not been used in any practical system.

On the other hand, some of the structural systems do not have a flat equivalent, typically
because there is no appropriate $\czip$ operator that could be added to form the flat coeffect
scalar. This is the case, for example, for the bounded variable use.

\begin{example}[Structural liveness]
The structural coeffect scalar for liveness is formed by
$(\mathcal{L}, \sqcap, \sqcup, \ident{L}, \ident{D}, \sqsubseteq)$, where $\mathcal{L}=\{ \ident{L}, \ident{D} \}$ is
the same two-point lattice as in the flat version, that is $\ident{D} \sqsubseteq \ident{L}$
with a join $\sqcup$ and a meet $\sqcap$.
\end{example}

\begin{example}[Structural dataflow]
In dataflow, context is annotated with natural numbers and the structural coeffect scalar is formed
by $(\mathbb{N}, +, \mathit{max}, 0, 0, \leq)$.
\end{example}

\noindent
For the two examples that have both flat and structural version, obtaining the structural coeffect
algebra is easy. As shown by the examples above, we simply omit the $\czip$ operation. The laws
required by a structural coeffect algebra are the same as those required by the flat version
and so the above definitions are both valid. Similar construction can be used for the
\emph{optimized dataflow} example from Section~\ref{sec:flat-calculus-examples}.

It is important to note that this gives us a systems with \emph{different} properties. The
information are now tracked per-variable rather than for entire contexts. For dataflow,
we also need to adapt the typing rule for the \kvd{prev} construct. Here, we write $\aclrd{+}$
for a pointwise extension of the $+$ operator, such that
$\alift{\cclrd{r_1}, \ldots, \cclrd{r_n}} \aclrd{+} k = \alift{\cclrd{r_1} + k, \ldots, \cclrd{r_n} + k}$.
%
\begin{equation*}
\tyrule{prev}
  { \coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e : \tau }
  { \coctx{\Gamma}{\aclrd{\textbf{r}} \,\aclrd{+}\, 1} \vdash \kvd{prev}~e : \tau }
\end{equation*}
%
The rule appears similar to the flat one, but there is an important difference. Because of the
structural nature of the type system, it only increments the required number of values for
variables that are used in the expression $e$. Annotations of other variables can be left
unchanged.

Before looking at the semantics and equational properties of structural coeffect systems,
we consider bounded variable use, which is an example of structural system that does not
have a flat counterpart.

\begin{example}[Bounded variable reuse]
The structural coeffect algebra for tracking bounded variable use is given by
$(\mathbb{N}, \ast, +, 1, 0, \leq)$
\end{example}

\noindent
Similarly to the structural calculus for dataflow, the calculus for bounded variable reuse
annotates each variable with an integer. However, the integer denotes how many times is the variable
\emph{accessed} rather than how many \emph{past values} are needed. The resulting type system is
the one shown in Figure~\ref{fig:applications-struct-live} in Chapter~\ref{ch:applications}.



% ==================================================================================================
%
%       #
%      # #   #    # #####   ####  # #    # # ##### #   #
%     #   #  ##  ## #    # #    # # #    # #   #    # #
%    #     # # ## # #####  #      # #    # #   #     #
%    ####### #    # #    # #  ### # #    # #   #     #
%    #     # #    # #    # #    # # #    # #   #     #
%    #     # #    # #####   ####  #  ####  #   #     #
%
% ==================================================================================================


\begin{figure}[t]
\begin{equation*}
\tyrule{var}
  { }
  {\coctx{x\!:\!\tau}{\alift{\cunit}} \vdash x : \tau }
\end{equation*}
\begin{equation*}
\tyrule{const}
  { }
  {\coctx{()}{\alift{}} \vdash n : \ident{num} }
\end{equation*}
\begin{equation*}
\tyrule{app}
  {\coctx{\Gamma_1}{\aclrd{\textbf{r}}} \vdash e_1 : \tau_1 \xrightarrow{\cclrd{t}} \tau_2 \\
   \coctx{\Gamma_2}{\aclrd{\textbf{s}}} \vdash e_2 : \tau_1 }
  {\coctx{\Gamma}{\aclrd{\textbf{c}}} \vdash e_1~e_2 : \tau_2}
\quad \coctx{\Gamma}{\aclrd{\textbf{c}}} = \ident{mergevars}(\cclrd{t}, \coctx{\Gamma_1}{\aclrd{\textbf{r}}}, \coctx{\Gamma_2}{\aclrd{\textbf{s}}})
\end{equation*}
\begin{equation*}
\tyrule{abs}
  {\coctx{\Gamma_1}{\aclrd{\textbf{t}}} \vdash e : \tau_2}
  {\coctx{\Gamma_2}{\aclrd{\textbf{r}}} \vdash \lambda x:\tau_1.e : \tau_1 \xrightarrow{\cclrd{s}} \tau_2 }
\quad (\coctx{\Gamma_2}{\aclrd{\textbf{r}}}), \tau_1, \cclrd{s} = \ident{findvar}_x(\coctx{\Gamma_1}{\aclrd{\textbf{t}}})
\end{equation*}

\vspace{1em}
\begin{equation*}
\begin{array}{l}
\ident{exch}_x(\coctx{\Gamma}{\aclrd{\textbf{t}}})~=~(\coctx{\Gamma_1,\Gamma_2}{\aclrd{\textbf{t}_1} \atimes \aclrd{\textbf{t}_2}}), \tau, \cclrd{s} \quad \textnormal{where} \\
\qquad \xlen{\Gamma_1} = \alen{\aclrd{\textbf{t}_1}}~\textnormal{and}~\xlen{\Gamma_2} = \alen{\aclrd{\textbf{t}_2}} \\[-0.25em]
\qquad x\!:\!\tau \in \Gamma~\textnormal{and}~
  \coctx{\Gamma}{\aclrd{\textbf{t}}} = \coctx{\Gamma_1, x\!:\!\tau, \Gamma_2}{\aclrd{\textbf{t}_1} \atimes \alift{\cclrd{s}} \atimes \aclrd{\textbf{t}_2}}
\\[0.5em]
\ident{findvar}_x(\coctx{\Gamma}{\aclrd{\textbf{t}}})~=~ (\coctx{\Gamma}{\aclrd{\textbf{t}}}), \tau, \czero \qquad (\textnormal{otherwise})
\\[1em]
\ident{mergevars}(\cclrd{t}, \coctx{\Gamma_1}{\aclrd{\textbf{r}}}, \coctx{\Gamma_2}{\aclrd{\textbf{s}}})~=~
  \coctx{\Gamma'_1, \Gamma'_2, \Gamma}{\aclrd{\textbf{r}'}\atimes(\cclrd{t} \,\aseq\, \aclrd{\textbf{s}'}) \atimes \aclrd{\textbf{c}} } \quad \textnormal{where}\\
\qquad \coctx{\Gamma_1}{\aclrd{\textbf{r}}} =
    \coctx{x_1\!:\!\tau_1, \ldots, x_n\!:\!\tau_n}{\alift{\cclrd{r_1}, \ldots, \cclrd{r_n}}} \\
\qquad \coctx{\Gamma_2}{\aclrd{\textbf{s}}} =
    \coctx{y_1\!:\!\tau'_1, \ldots, y_m\!:\!\tau'_n}{\alift{\cclrd{s_1}, \ldots, \cclrd{s_m}}} \\
\qquad \coctx{\Gamma}{\aclrd{\textbf{c}}} =
    \coctx{z_1\!:\!\tau''_1, \ldots, z_k\!:\!\tau''_k}{\alift{\cclrd{c_1}, \ldots, \cclrd{c_k}}} \\[-0.25em]
\qquad\quad \textnormal{such that}~\forall l\in \{1 \ldots k\}~\exists i,j.~(z_l\!:\!\tau''_l = x_i\!:\!\tau_i = y_j\!:\!\tau'_j) \\[-0.25em]
\qquad\qquad \textnormal{and}~\cclrd{c_l} = \cclrd{r_i} \;\cpar\; (\cclrd{t} \,\cseq\, \cclrd{s_j}) \\
\qquad \coctx{\Gamma_1}{\aclrd{\textbf{r}}} =
    \coctx{x_1\!:\!\tau_1, \ldots, x_n\!:\!\tau_n}{\alift{\cclrd{r_1}, \ldots, \cclrd{r_n}}}
    ~\textnormal{such that}~x_i\!:\!\tau_i \notin \Gamma \\
\qquad \coctx{\Gamma_2}{\aclrd{\textbf{s}}} =
    \coctx{y_1\!:\!\tau'_1, \ldots, y_m\!:\!\tau'_n}{\alift{\cclrd{s_1}, \ldots, \cclrd{s_m}}}
    ~\textnormal{such that}~y_i\!:\!\tau'_i \notin \Gamma \\
\end{array}
\end{equation*}

\figcaption{Syntax-directed type system for the structural coeffect calculus}
\label{fig:struct-syntax-types}
\end{figure}

%---------------------------------------------------------------------------------------------------

\section{Choosing a unique typing}
\label{sec:struct-unique}

In the structural coeffect calculus, the lambda abstraction rule does not introduce ambiguity
in the typing. This is in contrast with flat coeffect systems (most importantly, the one for
implicit parameters), where lambda abstraction allowed arbitrary splitting of context requirements.
In structural coeffect systems, the context requirements placed on the call-site (attached to
the function type) are those of the bound variable.

However, the type system for structural coeffect calculus in Figure~\ref{fig:struct-types}
introduces another kind of ambiguity due to the fact that non syntax-directed structural rules
can be applied repeatedly and in arbitrary order. As with the semantics for flat coeffect calculus
in Chapter~\ref{ch:semantics}, we define the semantics of the structural coeffect calculus over
a \emph{typing derivation} and so the meaning of a program depends on the typing derivation chosen.
In this section, we specify how to choose the desired \emph{unique} typing derivation.

%---------------------------------------------------------------------------------------------------

\subsection{Syntax-directed type system}

In order to choose a unique typing derivation, we follow the example of sub-structural type systems
\cite{substruct-attpl-intro} and introduce a syntax-directed version of the type system (also called
\emph{algorithmic}). This replaces the non-syntax-directed rules for weakening, exchange and
contraction with additional logic in places where contexts are combined. Given a typing derivation
in the syntax-directed type system, we can then produce a matching typing derivation in the original
type system.

The syntax-directed version of the type system is shown in Figure~\ref{fig:struct-syntax-types}.
The typing rules for variables (\emph{var}) and constants (\emph{const}) are the same as before.
The two interesting rules are lambda abstraction and application.

\paragraph{Lambda abstraction.}
In lambda abstraction (\emph{abs}) in Figure~\ref{fig:struct-types}, we assume that the bound
varible is the last variable of the context. In the syntax-directed system, we do not make the
same assumption. Instead, we use an auxiliary relation $\ident{findvar}_x$ that takes a typing
context $\coctx{\Gamma}{\aclrd{\textbf{t}}}$ and returns a context with the variable $x$ removed
together with its type and coeffect.

The $\ident{findvar}_x$ relation is defined by two disjoint cases. If the variable $x$ is not
present in the context, the context is returned as is and the returned coeffect is $\czero$.
This case corresponds to the (\emph{weak}) structural rule. If the variable is not found in the
context, the relation does not place any restrictions on the type of the variable and so $\tau$
can be any type (this is the only reason why $\ident{findvar}$ is a relation rather than a function).
If the variable $x$ appears in the context then $\ident{findvar}_x$ removes it together with its
corresponding coeffect annotation and returns it as the result.

\paragraph{Function application.} In the (\emph{app}) rule in Figure~\ref{fig:struct-types}, we
assume that the variable contexts of the two sub-expressions can be merged. This requires that they
contain disjoint variables, which can be always obtained by exchange and contraction. In the
syntax-driven systenm, we merge coeffects of shared variables explicitly. This is done in the
\ident{mergevars} function.

The \ident{mergevars} function returns context consisting of three parts. Parts $\Gamma_1$
and $\Gamma_2$ represent variables that appear only in the first or the second context; part
$\Gamma$ contains common variables. The coeffect annotations corresponding to $\Gamma_1$ are
the original annotations from $\aclrd{\textbf{r}}$; the coeffects corresponding to $\Gamma_2$
are composed with the coeffect of the function value $\cclrd{t} \,\aseq\, \aclrd{\textbf{s}'}$
as in the original (\emph{app}) rule. Finally, for shared variables, the coeffect is
obtained by point-wise composition (as in contraction) of the coeffect for the two contexts
$\cclrd{r_i} \;\cpar\; (\cclrd{t} \,\cseq\, \cclrd{s_j})$. The first coeffect corresponds to the
context requirements in the sub-expression $e_1$ and the second coeffect corresponds to the
function argument $e_2$ sequentially composed with the coeffect $\cclrd{t}$ of the function
(as in ordinary application rule).


%---------------------------------------------------------------------------------------------------

\subsection{Properties}

The syntax-directed type checking presented in the previous section gives a unique typing derivation
that can be automatically turned into a valid typing derivation of the original type system
presented in Figure~\ref{fig:struct-types}. This gives us a unique typing derivation for the
structural coeffect calculus. As with the unique typing derivation for the flat coeffect system,
this is used to give semantics of terms of the structural coeffect calculus. We also note that
a well-typed program in the original type system has a typing derivation in the syntax-driven
version.

As when discussing uniqueness of typing for flat coeffect systems (Section~\ref{sec:flat-unique}),
we first give the inversion lemma (Lemma~\ref{thm:struct-invert}) and then prove the
uniqueness of typing theorem (Theorem~\ref{thm:struct-unique}).

\begin{lemma}[Inversion lemma for syntax-directed structural coeffects]
\label{thm:struct-invert}
For the type system defined in Figure~\ref{fig:struct-syntax-types}:
%
\begin{enumerate}
\raggedright
\item If $\coctx{\Gamma}{\aclrd{\textbf{c}}} \vdash x : \tau$ then $\Gamma = x\!:\!\tau$ and $\aclrd{\textbf{c}} = \alift{\cunit}$.
\item If $\coctx{\Gamma}{\aclrd{\textbf{c}}} \vdash n : \tau$ then $\Gamma = ()$ and $\tau = \ident{num}$ and $\aclrd{\textbf{c}} = \alift{}$.
\item If $\coctx{\Gamma}{\aclrd{\textbf{c}}} \vdash e_1~e_2 : \tau_2$
  then there is some $\Gamma_1, \Gamma_2, \tau_1$ and some $\cclrd{t}, \aclrd{\textbf{r}}, \aclrd{\textbf{s}}$ \\ such that
  $\coctx{\Gamma_1}{\aclrd{\textbf{r}}} \vdash e_1 : \tau_1 \xrightarrow{\cclrd{t}} \tau_2$ and
  $\coctx{\Gamma_2}{\aclrd{\textbf{s}}} \vdash e_2 : \tau_1$ and also
  $\coctx{\Gamma}{\aclrd{\textbf{c}}} = \ident{mergevars}(\cclrd{t}, \coctx{\Gamma_1}{\aclrd{\textbf{r}}}, \coctx{\Gamma_2}{\aclrd{\textbf{s}}})$.
\item If $\coctx{\Gamma}{\aclrd{\textbf{c}}} \vdash \lambda x\!:\!\tau_1.e : \tau$
  then there is some $\Gamma', \tau_2$ and some $\cclrd{s}, \aclrd{\textbf{t}}$ such that
  $\coctx{\Gamma'}{\aclrd{\textbf{t}}} \vdash e : \tau_2$ and
  $\tau = \tau_1 \xrightarrow{\cclrd{s}} \tau_2$ and also
  $(\coctx{\Gamma}{\aclrd{\textbf{c}}}), \tau_1, \cclrd{s} = \ident{findvar}_x(\coctx{\Gamma_1}{\aclrd{\textbf{t}}})$.
\end{enumerate}
\end{lemma}
\begin{proof}
Follows from the individual rules given in Figure~\ref{fig:struct-syntax-types}.
\end{proof}

\begin{theorem}[Uniqueness of syntax-directed structural coeffects]
\label{thm:struct-unique}
In the syntax-directed type system for structural coeffects defined in Figure~\ref{fig:struct-syntax-types},
when $\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e : \tau$ and
$\coctx{\Gamma}{\aclrd{\textbf{r}'}} \vdash e : \tau'$ then $\tau = \tau'$ and $\aclrd{\textbf{r}} = \aclrd{\textbf{r}'}$.
\end{theorem}
\begin{proof}
Suppose that (A) $\coctx{\Gamma}{\aclrd{\textbf{c}}} \vdash e : \tau$ and
(B) $\coctx{\Gamma}{\aclrd{\textbf{c}'}} \vdash e : \tau'$. We show by induction over the typing
derivation of $\coctx{\Gamma}{\aclrd{\textbf{c}}} \vdash e : \tau$ that $\tau = \tau'$ and $\aclrd{\textbf{c}}=\aclrd{\textbf{c}'}$.

\vspace{0.5em}\noindent\hangindent=0.6cm
Case (\emph{abs}): $e = \lambda x\!:\!\tau_1.e_1$. Then $\tau = \tau_1 \xrightarrow{\cclrd{c}} \tau_2$
  for some $\tau_2$ and $\coctx{\Gamma'}{\aclrd{\textbf{t}}} \vdash e : \tau_2$ for some $\Gamma', \aclrd{\textbf{t}}$
  and also $(\coctx{\Gamma}{\aclrd{\textbf{c}}}), \tau_1, \cclrd{s} = \ident{findvar}_x(\coctx{\Gamma'}{\aclrd{\textbf{t}}})$.
  By case (4) of Lemma~\ref{thm:struct-invert}, the final rule of the derivation (B) must
  have also been (\emph{abs}) and this derivation has a sub-derivation with a conclusion
  ${\coctx{\Gamma}{\aclrd{\textbf{c}'}} \vdash e : \tau_2'}$.
  By the induction hypothesis $\tau_2 = \tau_2'$ and $\aclrd{\textbf{c}}=\aclrd{\textbf{c}'}$ and therefore
  also so $\tau = \tau'$. Although $\ident{findvar}_x$ is a relation, it allows only one possible result
  (because the type of the bound variable matches the type annotation).

\vspace{0.5em}\noindent\hangindent=0.7cm
Cases (\emph{var}), (\emph{const}) are direct consequence of Lemma~\ref{thm:struct-invert}.

\vspace{0.5em}\noindent\hangindent=0.7cm
Casea (\emph{app}) similarly to (\emph{abs}).
\end{proof}

\noindent
As noted earlier, unique typing derivations obtained using the type system given in
Figure~\ref{fig:struct-syntax-types} can be automatically turned into typing derivations
of the original (non-syntax-directed) structural coeffect type system in Figure~\ref{fig:struct-types}.
The following remark provides the details.

\begin{remark}[Admisibility of unique typing for implicit parameters]
\label{thm:flat-impl-admis}
  If $\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e : \tau$ (using the rules in
  Figure~\ref{fig:struct-syntax-types}) then there is a uniqye typing derivation
  using the typing rules from Figure~\ref{fig:struct-types} with a conclusion
  $\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e : \tau$ obtained by induction over
  the original typing derivation as folows:

\vspace{0.5em}\noindent\hangindent=0.6cm
Case (\emph{var}), (\emph{const}): The resulting typing derivation uses the corresponding
  rule of the non-syntax-directed type system.

\vspace{0.5em}\noindent\hangindent=0.6cm
Case (\emph{abs}): Take the typing derivation for the sub-expression $e$. If the variable $x$
  does not appear in $\Gamma_1$, apply (\emph{weak}) followed by (\emph{abs}). Otherwise
  assume $\Gamma_1 = x_1\!:\!\tau_1,\ldots,x_n\!:\!\tau_n$ and $x=x_i$. Apply (\emph{exch})
  repeatedly on variables $x_i, x_{i+1}$ then $x_i, x_{i+2}$ and so on until it is applied
  on $x_i, x_n$. At this point, $x_i$ is the last variable of the vector and we can apply
  (\emph{abs}). This produces the same consequent as the one in the original typing derivation.

\vspace{0.5em}\noindent\hangindent=0.6cm
Case (\emph{app}): Take the typing derivations for the sub-expressions $e_1$ and $e_2$ in
  free-variable contexts $\Gamma_1$ and $\Gamma_2$. For each variable $x$ that appears in both
  $\Gamma_1$ and $\Gamma_2$, rename the variable to a fresh name $x'$ in $e_1$ and to another
  fresh name $x''$ in $e_2$ and their typing derivations. Now we have disjoint contexts and
  we can apply (\emph{app}) on the target derivations.

\vspace{0.5em}\noindent\hspace{0.6cm}\hangindent=0.6cm
  Next, apply (\emph{exch}) until $x'$ and $x''$ are last two variables in the vector and apply
  (\emph{contr}), renaming both $x'$ and $x''$ to the original name $x$. Repeat this step for
  all variables that were renamed. The resulting variable context is $\Gamma$ and the resulting
  coeffect annotation is the same as in the original typing derivation.
\end{remark}


% ==================================================================================================
%
%     #####
%    #     # #   # #    # #####   ##    ####  ##### #  ####
%    #        # #  ##   #   #    #  #  #    #   #   # #    #
%     #####    #   # #  #   #   #    # #        #   # #
%          #   #   #  # #   #   ###### #        #   # #
%    #     #   #   #   ##   #   #    # #    #   #   # #    #
%     #####    #   #    #   #   #    #  ####    #   #  ####
%
% ==================================================================================================

\section{Syntactic equational theory}
\label{sec:struct-syntax}

The properties of the structural coeffect algebra guarantee that certain equational properties
hold in all instances of the structural coeffect calculus. In this section, we look at these common
properties that we get ``for free'' from the structural coeffect calculus. We start the discussion
by briefly considering the key aspects that make the equational theory of flat and structural
coeffects different.

\subsection{From flat coeffects to structural coeffects}
\label{sec:struct-syntax-intro}

When discussing syntactic reductions for the flat calculus in Section~\ref{sec:flat-syntax},
we noted that call-by-name reduction does not, in general, preserve typing  for all
flat coeffect calculi. In the structural coeffect calculus, $\beta$-reduction and also $\eta$-expansion
preserve typing for all instances of the calculus. Using the terminology of Pfenning and Davies
\cite{logic-modal-reconstruction}, the structural coeffect calculus satisfies both the \emph{local
soundness} and the \emph{local completeness} properties.

\paragraph{Substitution for flat coeffects.}
The less obvious (\emph{top-pointed}) variant of the substitution lemma for flat coeffects
(Lemma~\ref{thm:cbn-substitution-bot}) required all operations of the flat coeffect algebra
to coincide. This enables substitution to preserve the type of expressions, because all
additional requirements arising as the result of the substitution can be associated with the
declaration context. For example, consider the following example where implicit parameter
$\ident{?offset}$ is substituted for the variable $y$:
%
\begin{equation*}
\begin{array}{rclcll}
 \coctx{y\!:\!\ident{int}}{\cclrd{\emptyset}} &\narrow{\vdash}& \lambda x.y + \ident{?total} &\narrow{:}&
   \ident{int} \xrightarrow{\cclrd{ \{ \ident{?total} \} }} \ident{int} & \qquad(\textit{before}) \\
\coctx{()}{\cclrd{ \{ \ident{?offset} \} }} &\narrow{\vdash}& \lambda x.\ident{?offset} + \ident{?total} &\narrow{:}&
  \ident{int} \xrightarrow{\cclrd{ \{ \ident{?total} \} }} \ident{int} & \qquad(\textit{after})
\end{array}
\end{equation*}
%
The typing judgement obtained in (\emph{after}) preserves the type of the expression (function
value) from the original typing (\emph{before}). This is possible thanks to the non-determinism
involved in the typing rule for lambda abstraction -- as all operators of the flat coeffect
algebra used here are $\cup$, we can place the additional requirement on the outer context.
Note that this is not the \emph{only} possible typing, but it is a \emph{permissible} typing.

Here, the flat coeffect calculus gives us typing with limited \emph{precision}, but
enough \emph{flexibility} to prove the substitution lemma.

\paragraph{Substitution for structural coeffects.}
In contrast, the substitution lemma (Lemma~\ref{thm:structural-substitution}, shown later on
page~\pageref{thm:structural-substitution}) for structural coeffects can be proven because
structural coeffect systems provide enough \emph{precision} to identify exactly with which
variable should a context requirement be associated.

The following example shows a situation similar to the previous one. Here, we use
structural dataflow calculus (writing $\kvd{prev}~e$ to obtain previous value of the
expression $e$) and we substitute $w+z$ for $y$:
%
\begin{equation*}
\begin{array}{rclcll}
 \coctx{y\!:\!\ident{int}}{ \alift{\cclrd{2}} }
  &\narrow{\vdash}& \lambda x.\kvd{prev}~(x + \kvd{prev}~y) &\narrow{:}&
   \ident{int} \xrightarrow{\cclrd{ 1 }} \ident{int} & \quad(\textit{before}) \\
\coctx{w\!:\!\ident{int}, z\!:\!\ident{int}}{\cclrd{2}\cclrd{\ast}\alift{\cclrd{1},\cclrd{1}}}
  &\narrow{\vdash}& \lambda x.\kvd{prev}~(x + \kvd{prev}~(w+z))) &\narrow{:}&
   \ident{int} \xrightarrow{\cclrd{ 1 }} \ident{int} & \quad(\textit{after}) \\
\coctx{w\!:\!\ident{int}, z\!:\!\ident{int}}{\alift{\cclrd{2},\cclrd{2}}}
  &\narrow{\vdash}& \lambda x.\kvd{prev}~(x + \kvd{prev}~(w+z))) &\narrow{:}&
   \ident{int} \xrightarrow{\cclrd{ 1 }} \ident{int} & \quad(\textit{final})
\end{array}
\end{equation*}
%
The type of the function does not change, because the structural type system associates
the annotation $\cclrd{1}$ with the bound variable $x$ and the substitution does not
affect how the variable $x$ is used.

The other aspect demonstrated in the example is how the coeffect of the substituted
variable affects the free-variable context of the substituted expression. Here, the
original variable $y$ is annotated with $\cclrd{2}$ and we substitute it for an
expression $w+z$ with free variables $w,z$ annotated with $\alift{\cclrd{1}, \cclrd{1}}$.
The substitution applies the operation $\aseq$ (modelling sequential composition) to
the annotation of the new context -- in the above example
$\cclrd{2}\cclrd{\ast}\alift{\cclrd{1}, \cclrd{1}}=\alift{\cclrd{2}, \cclrd{2}}$.

\subsection{Holes and substitution lemma}
\label{sec:struct-syntactic-subst}

As demonstrated in the previous section, reduction (and substitution) in the structural coeffect
calculus may need to replace a \emph{single} variable with a \emph{vector} of variables.
More importantly, because the system uses explicit contraction, we may also need to substitute
for multiple variables in the variable context at the same time.

Consider the expression $\lambda x.x+x$. It is type-checked by type-checking $x_1 + x_2$,
contracting $x_1$ and $x_2$ and then applying lambda abstraction. During the reduction of
$(\lambda x.x+x)~(y+z)$ we need to substitute $y_1+z_1$ for $x_1$ and $y_2+z_2$ for $x_2$.
This is similar to substitution lemma in other structural variants of $\lambda$-calculus,
such as the bunched typing system \cite{substruct-bunched}. To express the substitution
lemma later in this section, we first define the notion of a \emph{context with holes}:

\begin{definition}[Context with holes]
A \emph{context with holes} is a context such as $\coctx{x_1\!:\!\tau_1, \ldots, x_k\!:\!\tau_k}{\alift{\cclrd{r_1}, \ldots, \cclrd{r_k}}}$,
where some of the variable typings $x_i\!:\!\tau_i$ and corresponding coeffects $\cclrd{r_i}$
are replaced by \emph{holes} written as $-$.

\begin{equation*}
~\Delta[\,\coctx{-}{-}\,]_n = \Delta[\,\underbrace{\coctx{-}{-} \,|\, \ldots \,|\, \coctx{-}{-}}_{ n-\textit{times} } \,]
\end{equation*}
\begin{equation*}
\begin{array}{lcl}
 \Delta[\,\coctx{-}{-}\,]_n &\narrow{:=}&
   \coctx{-, \Gamma}{\alift{-} \atimes \aclrd{\textbf{s}} }
   \qquad \textnormal{where}~\coctx{\Gamma}{\aclrd{\textbf{s}}} \in \Delta[\,\coctx{-}{-}\,]_{n-1} \\
 \Delta[\,\coctx{-}{-}\,]_n &\narrow{:=}&
   \coctx{x\!:\!\tau, \Gamma}{\alift{\cclrd{r}} \atimes \aclrd{\textbf{s}} }
   \qquad \textnormal{where}~\coctx{\Gamma}{\aclrd{\textbf{s}}} \in \Delta[\,\coctx{-}{-}\,]_n \\
 \Delta[\,\coctx{-}{-}\,]_0 &\narrow{:=}&
   \coctx{()}{\alift{}}
\end{array}
\end{equation*}
\end{definition}

\noindent
A context with $n$ holes may either start with a hole, followed by a context with $n-1$ holes, or it may
start with a variable followed by a context with $n$ holes. Note that the definition ensures that
the locations of variable holes correspond to the locations of coeffect annotation holes. Given a context
with holes, we can fill the holes with other contexts using the \emph{hole filling} operation and
obtain an ordinary coeffect-annotated context.

\begin{definition}[Hole filling] Given a context with $n$ holes $\coctx{\Delta}{\textbf{s}} \in
\Delta[\,\coctx{-}{-}\,]_n$, the hole filling operation written as
$\coctx{\Delta}{\textbf{s}}[\,\coctx{\Gamma_1}{\aclrd{\mathbf{r_1}}} \,|\, \ldots \,|\, \coctx{\Gamma_n}{\aclrd{\mathbf{r_n}}} \,]$,
which replaces the holes by the specified variables and corresponding coeffect annotations, is defined as:
%
\begin{equation*}
\begin{array}{rcl}
 \coctx{-, \Delta}{\alift{-} \atimes \textbf{s} }
    ~[\,\coctx{\Gamma_1}{\aclrd{\textbf{r}_1}} \,|\, \coctx{\Gamma_2}{\aclrd{\textbf{r}_2}} \,|\, \ldots \,] &\narrow{=}&
      \coctx{\Gamma_1, \Gamma_2}{\aclrd{\textbf{r}_1} \atimes \aclrd{\textbf{r}_2} } \\
 && \qquad \hspace{-9.3em} \textnormal{where}~\coctx{\Gamma_2}{\aclrd{\textbf{r}_2}} =
     \coctx{\Delta}{\textbf{s}}[\, \coctx{\Gamma_2}{\aclrd{\textbf{r}_2}} \,|\, \ldots \,]
\\[0.5em]
 \coctx{x_1\!:\!\tau, \Delta}{\alift{\cclrd{r_1}} \atimes \textbf{s} }
    ~[\,\coctx{\Gamma_1}{\aclrd{\textbf{r}_1}} \,|\, \coctx{\Gamma_2}{\aclrd{\textbf{r}_2}} \,|\, \ldots \,] &\narrow{=}&
      \coctx{x_1\!:\!\tau, \Gamma_2}{\alift{\cclrd{r_1}} \atimes \aclrd{\textbf{r}_2} } \\
 && \qquad \hspace{-9.3em} \textnormal{where}~\coctx{\Gamma_2}{\aclrd{\textbf{r}_2}} =
     \coctx{\Delta}{\textbf{s}}[\,\coctx{\Gamma_1}{\aclrd{\textbf{r}_1}} \,|\, \coctx{\Gamma_2}{\aclrd{\textbf{r}_2}} \,|\, \ldots \,]
\\[0.5em]
 \coctx{()}{\alift{}}~[~] &\narrow{=}& \coctx{()}{\alift{}}
\end{array}
\end{equation*}
\end{definition}

\noindent
When we substitute an expression with coeffects $\aclrd{\textbf{t}}$ (associated with variables $\Gamma$)
for a variable that has coeffects $\cclrd{s}$, the resulting coeffects of $\Gamma$ need to
combine $\aclrd{\textbf{t}}$ and $\cclrd{s}$. Unlike in the flat coeffect systems, the structural
substitution does not require all coeffect algebra operations to coincide and so the combination
is more interesting than in the bottom-pointed substitution for flat coeffects, where it used
the only available operator (Lemma~\ref{thm:cbn-substitution-bot}).

Substitution can be seen as a form of sequencing, \ie~the term $\subst{e_1}{x}{e_2}$ should have
the same type as the term $\kvd{let}~x=e_2~\kvd{in}~e_1$. In other words, we first need to obtain the
value of the expression (requiring $\aclrd{\textbf{t}}$) and then use it in context with
requirements $\cclrd{s}$. Thus the free variables of the expression \emph{after} substitution
are annotated with $\cclrd{s} \,\aseq\, \aclrd{\textbf{t}}$, using the (scalar-vector extension)
of the sequential composition operator $\cseq$.

An operational reading of the resulting coeffect annotation is that, to evaluate each of the variables
annotated with coeffects in the vector $\aclrd{\textbf{t}}$, we first need to evaluate the substituted
expression with coeffects $\cclrd{s}$, followed by the rest of the expression with coeffects specified
by $\aclrd{\textbf{t}}$.

\begin{lemma}[Multi-nary substitution]
\label{thm:structural-substitution}
Given an expression with multiple holes filled by variables $x_i\!:\!\tau_i$ with coeffects $\cclrd{s_k}$:
%
\begin{equation*}
\coctx{\Gamma}{\aclrd{\textbf{r}}}~[\,\coctx{x_1\!:\!\tau_1}{\alift{\cclrd{s_1}}} \,|\, \ldots \,|\,
  \coctx{x_k\!:\!\tau_k}{\alift{\cclrd{s_k}}}\,] \vdash e_r : \tau_r
\end{equation*}
%
and a expressions $e_i$ with free-variable contexts $\Gamma_i$ annotated with $\aclrd{\mathbf{t_i}}$:
%
\begin{equation*}
\coctx{\Gamma_1}{\aclrd{\textbf{t}_1}} \vdash e_1 : \tau_1
\quad \ldots \quad
\coctx{\Gamma_k}{\aclrd{\textbf{t}_k}} \vdash e_k : \tau_k
\end{equation*}
%
then substituting the expressions $e_i$ for variables $x_i$ results in an expression with a context
where the original holes are filled by contexts $\Gamma_i$ with coeffects $\cclrd{s_i} \aseq \aclrd{\mathbf{t_i}}$:
%
\begin{equation*}
\coctx{\Gamma}{\aclrd{\textbf{r}}}~[\,\coctx{\Gamma_1}{\cclrd{s_1}\aseq\,\aclrd{\textbf{t}_1}} \,|\, \ldots \,|\,
  \coctx{\Gamma_k}{\cclrd{s_k}\aseq\,\aclrd{\textbf{t}_k}}\,] \vdash \subst{\subst{e_r}{x_1}{e_1}\ldots}{x_k}{e_k} : \tau_r
\end{equation*}
\end{lemma}
\begin{proof}
By induction over $\vdash$, using the multi-nary aspect of the substitution
in the proof of the contraction case (see Appendix~\ref{sec:appendix-struct-cbn}).
\end{proof}

\subsection{Reduction and expansion}

In the Chapter~\ref{ch:flat}, we discussed call-by-value separately from call-by-name, because the
proof of call-by-value substitution has fewer prerequisites. In this section, we consider full
$\beta$-reduction, which encompasses both call-by-value and call-by-name. We also show that
$\eta$-expansion preserves the types. Both of the properties hold for a system with any
structural coeffect algebra.

\paragraph{Reduction theorem.} In a full $\beta$-reduction,
written as $\rightarrow_\beta$, we can replace the redex $(\lambda x.e_2)~e_1$ by the
expression $\subst{e_r}{x}{e_s}$ anywhere inside a term. The subject reduction theorem
guarantees that this does not change the type of the term.

\begin{theorem}[Type preservation]
In a structural coeffect system with a structural coeffect algebra formed by
$(\C, \cseq, \cpar, \cunit, \czero, \cleq)$ and operations $\alift{-}$ and $\aseq$,
if $\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e : \tau$
and $e \rightarrow_{\beta} e'$ using the full $\beta$-reduction then
$\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e' : \tau$.
\end{theorem}
\begin{proof}
Consider the typing derivation for the redex $(\lambda x.e_r)\,e_s$ before the reduction
(note that this is similar to the typing of let binding discussed in Remark~\ref{thm:structural-letbinding},
but we do not swap the two parts of the free-variable context):
%
\begin{equation*}
\inference
  { \begin{array}{l}\coctx{\Gamma_s}{\aclrd{\textbf{s}}} \vdash e_s : \tau_s\vspace{-2em}\end{array} &
    \inference
      { \coctx{\Gamma_r, x\!:\!\tau_s}{\aclrd{\textbf{r}}\;\atimes\,\alift{\cclrd{t}}} \vdash e_r : \tau_r }
      { \coctx{\Gamma_r}{\aclrd{\textbf{r}}} \vdash \lambda x.e_r : \tau_s \xrightarrow{\cclrd{t}} \tau_r} \vspace{0.2em} }
  { \coctx{\Gamma_r, \Gamma_s}{\aclrd{\textbf{r}} \;\atimes\; (\cclrd{t} \,\aseq\, \aclrd{\textbf{s}})} \vdash (\lambda x.e_r)~e_s : \tau_r }
\end{equation*}
%
For the substitution lemma, we first rewrite the typing judgement for $e_r$, \ie~
$\coctx{\Gamma_r, x\!:\!\tau_s}{\aclrd{\textbf{r}}\;\atimes\,\alift{\cclrd{t}}} \vdash e_r : \tau_r$
as a context with a single hole filled by the $x$ variable:
$\coctx{\Gamma_r, -}{\aclrd{\textbf{r}}\;\atimes\,-}~[\,\coctx{x\!:\!\tau_s}{\alift{\cclrd{t}}}\,] \vdash e_r : \tau_r$.
Now we can perform the substitution using Lemma~\ref{thm:structural-substitution}:
%
\begin{equation*}
\inference
  { \coctx{\Gamma_r, -}{\aclrd{\textbf{r}}\;\atimes-}~[\,\coctx{x\!:\!\tau_s}{\alift{\cclrd{t}}}\,] \vdash e_r : \tau_r &
    \coctx{\Gamma_s}{\aclrd{\textbf{s}}} \vdash e_s : \tau_s }
  { \inference
      { \coctx{\Gamma_r, -}{\aclrd{\textbf{r}}\;\atimes-}~[\,\coctx{\Gamma_s}{\cclrd{t}\,\aseq\,\aclrd{\textbf{s}} }\,] \vdash \subst{e_r}{x}{e_s} : \tau_r }
      { \coctx{\Gamma_r, \Gamma_s}{\aclrd{\textbf{r}}\,\atimes\,(\cclrd{t}\,\aseq\,\aclrd{\textbf{s}})} \vdash \subst{e_r}{x}{e_s} : \tau_r } }
\end{equation*}
%
The last step applies the hole filling operation, showing that substitution preserves
the type of the term.
\end{proof}

\noindent
Because of the vector (free monoid) structure of coeffect annotations $\aclrd{\textbf{r}}$,
$\aclrd{\textbf{s}}$, and $\alift{\cclrd{t}}$, these are uniquely associated with $\Gamma_r$,
$\Gamma_s$, and $x$ respectively. Therefore, substituting $e_s$ (which has coeffects
$\aclrd{\textbf{s}}$) for $x$ introduces the context requirements specified by $\aclrd{\textbf{s}}$
which are composed with the requirements $\cclrd{t}$ associated with $x$, \ie~the variable being
substituted.

\paragraph{Expansion theorem.}
Structural coeffect systems also exhibit $\eta$-equality, therefore satisfying both
\emph{local soundness} and \emph{local completeness} as required by Pfenning and Davies
\cite{logic-modal-reconstruction}. Informally, this means that abstraction does not introduce
too much, and application does not eliminate too much.

\begin{theorem}[$\eta$-expansion]
In a structural coeffect system with a structural coeffect algebra formed by
$(\C, \cseq, \cpar, \cunit, \czero, \cleq)$ and operations $\alift{-}$ and $\aseq$,
if $\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e : \tau$
and $e \rightarrow_{\eta} e'$ using the full $\eta$-reduction then
$\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e' : \tau$.
\end{theorem}
\begin{proof}
The following derivation shows that $\lambda x.f~x$ has the same type and coeffects as
the original expression $f$:
\begin{equation*}
\inference
  { \inference
    { \coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash f : \tau_1 \xrightarrow{\cclrd{s}} \tau_2 &
      \coctx{x\!:\!\tau_1}{\alift{\cunit}} \vdash x:\tau_1 }
    { \coctx{\Gamma, x\!:\!\tau_1}{\aclrd{\textbf{r}} \;\atimes\;(\cclrd{s}\,\aseq\,\alift{\cunit}) } \vdash f~x : \tau_2 } }
  { \inference
    { \coctx{\Gamma, x\!:\!\tau_1}{\aclrd{\textbf{r}} \;\atimes\,\alift{\cclrd{s}} } \vdash f~x : \tau_2 }
    { \coctx{\Gamma}{ \aclrd{\textbf{r}} } \vdash \lambda x.f~x : \tau_1 \xrightarrow{\cclrd{s}} \tau_2 } }
\end{equation*}
%
The second step uses the fact that
$\cclrd{s} \,\aseq\, \alift{\cunit} = \alift{\cclrd{s} \,\cseq\, \cunit} = \alift{\cclrd{s}}$
arising from the monoid $(\C, \cseq, \cunit)$ of the scalar coeffect structure.
\end{proof}

\noindent
The $\eta$-expansion property discussed in this section highlights another difference
between coeffects and effects. The $\eta$-equality property does not hold for many notions
of effect. For example, in a language with output effects, $e = (\textsf{print \texttt{"hi"}}; (\lambda x . x))$
has different effects to its $\eta$-converted form $\lambda x . e\,x$ because the immediate
effects of $e$ are hidden by the purity of $\lambda$-abstraction. In the coeffect calculus,
the (\emph{abs}) rule allows immediate contextual requirements of $e$ to ``float outside''
of the enclosing $\lambda$. Furthermore, the free monoid nature of $\atimes$ in structural
coeffect systems allows the exact immediate requirements of $\lambda x . e x$ to match
those of $e$.



% ==================================================================================================
%
%    #######
%       #    #    # ######  ####  #####  #   #
%       #    #    # #      #    # #    #  # #
%       #    ###### #####  #    # #    #   #
%       #    #    # #      #    # #####    #
%       #    #    # #      #    # #   #    #
%       #    #    # ######  ####  #    #   #
%
% ==================================================================================================

\section{Categorical motivation}
\label{sec:struct-semantics}

To define the semantics of structural coeffect calculus, we follow the same approach as for flat
coeffect calculus in Chapter~\ref{ch:semantics}. In this section, we define categorical semantics
for the calculus in terms of \emph{structural indexed comonad}, which is an extension of the
\emph{indexed comonad} structure. Similarly to \emph{flat indexed comonad}, the structural variant
adds operations that are needed to embed full $\lambda$-calculus, this time with per-variable contexts.

We use the semantics to guide the \emph{categorically-inspired translation} discussed in
Section~\ref{sec:struct-transl}, which translates context-aware programs from the structural coeffect
calculus to a simple target functional language with uninterpreted comonadically-inspired primitives
(that correspond to operations of the structural indexed comonads). We then give operational
semantics for a concrete context-aware language by giving the domain-specific reduction rules for
the comonadically-inspired primitives. As an example, we use this to prove syntactic type safety
of structural dataflow language in Section~\ref{sec:struct-transl-safety}.

% --------------------------------------------------------------------------------------------------

\subsection{Semantics of vectors}

Recall that in the flat coeffect calculus, the context is interpreted as a product and so a typing
judgement $\coctx{x_1\!:\!\tau_1, \ldots, x_n\!:\!\tau_n}{\cclrd{r}} \vdash e : \tau$ is interpreted as a
morphism $\ctyp{\cclrd{r}}{(\tau_1 \times \ldots \times \tau_n)} \rightarrow \tau$. In this model,
we can freely transform the value contained in the context modelled using an indexed comonad
$\ctyp{\cclrd{r}}$.

Previously, we defined the $\ident{map}$ function (in terms of $\ident{cobind}$ and $\ident{counit}$),
which transforms the value inside the context without affecting the coeffect annotation. Thus,
we can use $\ident{map}_{\cclrd{r}}~\pi_i$ to transform a context containing product of variables
$\ctyp{\cclrd{r}}{(\tau_1 \times \ldots \times \tau_n)}$ into a context containing a single value
$\ctyp{\cclrd{r}}{\tau_i}$. This changes the carried value without affecting the coeffect $\cclrd{r}$.

The ability to freely transform the variable structure is not desirable in the model of
structural coeffect systems. Our aim is to guarantee (by construction) that the structure of
the coeffect annotations matches the structure of variables. To achieve this, we model vectors
using a structure distinct from ordinary products which we denote $-\xtimes-$.
For example, the judgement $\coctx{x_1\!:\!\tau_1, \ldots, x_n\!:\!\tau_n}{\alift{\cclrd{r_1},\ldots,\cclrd{r_n}}} \vdash e : \tau$
is modelled as a morphism $\ctyp{\alift{\cclrd{r_1},\ldots,\cclrd{r_n}}}{(\tau_1 \xtimes \ldots \xtimes \tau_n)} \rightarrow \tau$.
We assume that the operator is equipped with necessary associativity transformations allowing us
to use it freely on more than two values.

The operator is a bifunctor, but it is \emph{not} a product in the categorical sense. In particular,
there is no way to turn $\tau_1 \xtimes \ldots \xtimes \tau_n$ into $\tau_i$ (the structure does
not have projections) and so there is also no way of turning
$\ctyp{\alift{\cclrd{r_1},\ldots,\cclrd{r_n}}}{(\tau_1 \xtimes \ldots \xtimes \tau_n)}$ into
$\ctyp{\alift{\cclrd{r_1},\ldots,\cclrd{r_n}}}{\tau_i}$, which would break the correspondence
between coeffect annotations and variable structure.

The structure created using $-\xtimes-$ can be manipulated only using operations provided by
the \emph{structural indexed comonad}, which operate over variable contexts contained in an
indexed comonad $\ctyp{\aclrd{\textbf{r}}}$ and are designed to preserve the correspondence
between vectors and annotations.

In what follows, we model (finite) vectors of length $n$ as $\tau_1 \xtimes \ldots \xtimes \tau_n$.
As mentioned, we assume that the use of the operator can be freely re-associated. For example, when
calling an operation that requires input of the form
$(\tau_1 \xtimes \ldots \xtimes \tau_i) \xtimes (\tau_{i+1} \xtimes \ldots \xtimes \tau_n)$,
we use an argument $(\tau_1 \xtimes \ldots \xtimes \tau_n)$ and assume that the
appropriate transformation is inserted.

% --------------------------------------------------------------------------------------------------

\subsection{Indexed comonads, revisited}

The semantics of structural coeffect calculus reuses the definition of \emph{indexed comonad} with
a minimal change. The additional structure that is required for context manipulation (merging and
splitting) is different and is here provided by the \emph{structural indexed comonad} structure that
we introduce in this section.

Recall the definition from Section~\ref{sec:semantics-flat-idx}, which defines an indexed como\-nad
over a monoid $(\C, \cseq, \cunit)$ as a triple $(\ctyp{\cclrd{r}{}}, \ident{counit}_{\cunit},
\ident{cobind}_{\cclrd{r}, \cclrd{s}})$. The triple consists of a family of object mappings $\ctyp{\cclrd{r}{}}$,
and two mappings that involve context-dependent morphisms of the form $\ctyp{\cclrd{r}} \tau_1 \rightarrow \tau_2$.

In the structural coeffect calculus, we work with morphisms of the form $\ctyp{\cclrd{r}} \tau_1 \rightarrow \tau_2$
representing function values (appearing in the language), but also of the form
$\ctyp{\alift{\cclrd{r_1},\ldots,\cclrd{r_n}}}{(\tau_1 \xtimes \ldots \xtimes \tau_n)} \rightarrow \tau$,
modelling expressions in a context. To capture this, we need to revisit the definition and use
\emph{coeffect vectors} in some of the operations.

\begin{definition}
Given a monoid $(\C, \cseq, \cunit)$ with a pointwise extension of the $\cseq$ operator to a vector
(written as $\cclrd{t}\,\aseq\,\aclrd{\textbf{s}}$) and an operation lifting scalars to vectors
$\alift{-}$, an \emph{indexed comonad} over a category $\catc$ is a triple
$(\ctyp{\cclrd{r}{}}, \ident{counit}_{\cunit}, \ident{cobind}_{\cclrd{s}, \aclrd{\textbf{r}}})$:

\begin{compactitem}
\item $\ctyp{\aclrd{\textbf{r}}}{}$ for all $\aclrd{\textbf{r}} \in \bigcup_{\sclrd{m}\in \sclrd{\mathbb{N}}} \C^{\sclrd{m}}$ is a family of object mappings
\item $\ident{counit}_{\cunit}$ is a mapping $\ctyp{\alift{\cunit}}{\alpha} \rightarrow \alpha$
\item $\ident{cobind}_{\cclrd{s}, \aclrd{\textbf{r}}}$ is a mapping $(\ctyp{\aclrd{\textbf{r}}}{\alpha} \rightarrow \beta)
  \rightarrow (\ctyp{\cclrd{s}\aseq\aclrd{\textbf{r}}}{\alpha} \rightarrow \ctyp{\alift{\cclrd{s}}}{\beta})$
\end{compactitem}
\end{definition}

\noindent
The object mapping $\ctyp{\aclrd{\textbf{r}}}$ is now indexed by a vector rather than by a scalar
$\ctyp{\cclrd{r}}$ as in the previous chapter. This new definition supersedes the old one, because a
flat coeffect annotation can be seen as singleton vectors.

The operation $\ident{counit}_{\cunit}$ operates on a vector of length one. This means that it will always
return a single value rather than a vector created using $-\xtimes-$. The $\ident{cobind}_{\cclrd{s}, \aclrd{\textbf{r}}}$
operation is, perhaps surprisingly, indexed by a coeffect vector and a coeffect scalar. This asymmetry
is explained by the fact that the input function ($\ctyp{\aclrd{\textbf{r}}}{\alpha} \rightarrow \beta$)
takes a vector of variables, but always produces just a single value. Thus the resulting function
also takes a vector of variables, but always returns a context with a vector containing just one value.
In other words, $\alpha$ may contain $\xtimes$, but $\beta$ may not, because the coeffect calculus has
no way of constructing values containing $\xtimes$.

% --------------------------------------------------------------------------------------------------

\subsection{Structural indexed comonads}
\label{sec:struct-semantics-idxc}

The flat indexed comonad structure extends indexed comonads with operations
$\ident{merge}_{\cclrd{r},\cclrd{s}}$ and $\ident{split}_{\cclrd{r},\cclrd{s}}$ that combine or
split the additional (flat) context and are annotated with the flat coeffect operations $\czip$
and $\cpar$, respectively.

In the structural version, the corresponding operations operate convert between a (wrapped) vector
of values represented using $\xtimes$ and ordinary pairs of contexts containing parts of the vector.
The vectors of coeffect annotations are split or merged using $\atimes$ of the structural coeffect
algebra, in a way that mirrors the wrapped vectors (variable structure).

The following definition includes $\ident{dup}_{\cclrd{r}, \cclrd{s}}$ which models
duplication of a variable in a context needed for the semantics of contraction:

\begin{definition}
Given a structural coeffect algebra formed by $(\C, \cseq, \cpar, \cunit, \czero, \cleq)$
with operations $\alift{-}$ and $\aseq$, a \emph{structural indexed comonad} is an indexed comonad over
the monoid $(\C, \cseq, \cunit)$ equipped with families of operations $\ident{merge}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}$,
$\ident{split}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}$ and $\ident{dup}_{\cclrd{r}, \cclrd{s}}$ where:
%
\begin{compactitem}
\item $\ident{merge}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}$ is a family of mappings
  $\ctyp{\aclrd{\textbf{r}}}{\alpha} \times \ctyp{\aclrd{\textbf{s}}}{\beta} \rightarrow \ctyp{\aclrd{\textbf{r}}\atimes\aclrd{\textbf{s}}}{(\alpha \xtimes \beta)}$
\item $\ident{split}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}$ is a family of mappings
  $\ctyp{\aclrd{\textbf{r}}\atimes\aclrd{\textbf{s}}}{(\alpha \xtimes \beta)} \rightarrow \ctyp{\aclrd{\textbf{r}}}{\alpha} \times \ctyp{\aclrd{\textbf{s}}}{\beta}$
\item $\ident{dup}_{\cclrd{r}, \cclrd{s}}$ is a family of mappings
  $\ctyp{\alift{\cclrd{r} \cpar \cclrd{s}}}{\alpha} \rightarrow \ctyp{\alift{\cclrd{r}, \cclrd{s}}}{(\alpha \xtimes \alpha)}$
\end{compactitem}
%
Here, the following equalities must hold:
\begin{equation*}
\ident{merge}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}} \circ \ident{split}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}} ~\equiv~ \ident{id} \qquad\qquad
\ident{id} ~\equiv~ \ident{split}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}} \circ \ident{merge}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}
\end{equation*}

\end{definition}

\noindent
These operations differ from those of the flat indexed comonad in that the \ident{merge} and
\ident{split} operations are required to be inverse functions and to preserve the additional
information about the context. This was not required for the flat system where the operations
could under-approximate or over-approximate. Note that the operations use $\xtimes$ to combine
or split the contained values. This means that they operate on free-variable vectors rather than
on ordinary products.

The \ident{dup} mapping is a new operation that was not required for a flat calculus. It
takes a variable context with a single variable annotated with $\cclrd{r}\,\cpar\,\cclrd{s}$,
duplicates the value of the variable $\alpha$ and splits the additional context between the two
new variables. In a flat calculus, this operation was expressed using ordinary tuple
construction, which is not possible here -- the returned context needs to contain a
two-element vector $\alpha \xtimes \alpha$.

% --------------------------------------------------------------------------------------------------

\begin{figure*}[!t]
The semantics is defined over a typing derivation:
%
\begin{equation*}
\hspace{-3em}
\begin{array}{ll}
\hspace{4em}\semdef
  {\coctx{x\!:\!\tau}{\alift{\cunit}} \vdash x : \tau}
  {\ident{counit}_{\cunit}}
& (\emph{var})
\\[1em]
\hspace{4.6em}\semdef
  {\coctx{()}{\alift{}} \vdash n : \ident{num} }
  {\ident{const}~n}
& (\emph{num})
\\[1.5em]
\hspace{1.40em}\semdeff
  {\coctx{\Gamma, x\!:\!\tau_1}{\aclrd{\textbf{r}}\,\atimes\,\alift{\cclrd{s}}} \vdash e : \tau_2}
  {\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash \lambda x.e : \tau_1 \xrightarrow{\cclrd{s}} \tau_2}
  {f}
  {f \circ \ident{curry}~\ident{merge}_{\aclrd{\textbf{r}}, \alift{\cclrd{s}}} }
& (\emph{abs})
\\[2em]
\hspace{-1.85em}\emdefff
  {\coctx{\Gamma_1}{\aclrd{\textbf{r}}} \vdash e_1 : \tau_1 \xrightarrow{\cclrd{t}} \tau_2}
  {\coctx{\Gamma_2}{\aclrd{\textbf{s}}} \vdash e_2 : \tau_1}
  {\begin{array}{l}\sem{\coctx{\Gamma_1, \Gamma_2}{\aclrd{\textbf{r}\,\atimes\,(\cclrd{t} \aseq \aclrd{\textbf{s}})}} \vdash e_1~e_2 : \tau_2}\\[-0.25em]~\end{array}}
  {f}
  {g}
  {\hspace{-0.5em}\begin{array}{l}
  \ident{app}~\circ~f\hspace{-0.15em}\times\hspace{-0.15em}(\ident{cobind}_{\cclrd{t}, \aclrd{\textbf{s}}}~g)\\[-0.25em]
  ~~\circ~~\ident{split}_{\aclrd{\textbf{r}}, \cclrd{t} \,\aseq\, \aclrd{\textbf{s}}}\\[-0.25em]
  \end{array}\hspace{-0.5em}}
& (\emph{app})
\\[1.5em]
\hspace{1.55em}\semdeff
  {\coctx{\Gamma}{ \aclrd{\textbf{r}} } \vdash e : \tau}
  {\coctx{\Gamma,x \!:\! \tau_1}{\aclrd{\textbf{r}} \atimes \alift{ \czero }} \vdash e : \tau}
  {f}
  {f\circ\ident{snd}\circ \ident{split}_{\aclrd{\textbf{r}}, \alift{\czero}}}
& (\emph{weak})
\\[1.5em]
\hspace{0.5em}\mdeff
  {\begin{array}{l}\sem{\coctx{\Gamma_1,x\!:\!\tau_1,y\!:\!\tau_2,\Gamma_2\\[-0.25em]\qquad}
     {\aclrd{\textbf{r}} \atimes \alift{\cclrd{s},\cclrd{t}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}\end{array}}
  {\begin{array}{l}\sem{\coctx{\Gamma_1,y\!:\!\tau_2,x\!:\!\tau_1,\Gamma_2\\[-0.25em]\qquad}{\aclrd{\textbf{r}}
          \atimes \alift{\cclrd{t},\cclrd{s}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}\end{array}}
  {f}
  {\begin{array}{l}\hspace{-0.5em}f\,\circ\,\ident{nest}_{\aclrd{\textbf{r}}, \alift{\cclrd{t},\cclrd{s}},
     \alift{\cclrd{s},\cclrd{t}}, \aclrd{\textbf{q}}}\\[-0.25em]
     ~~(\ident{merge}_{\alift{\cclrd{s}}, \alift{\cclrd{t}}}\circ\ident{swap}\circ\ident{split}_{\alift{\cclrd{t}}, \alift{\cclrd{s}}})\hspace{-5em}~ \end{array} }
& (\emph{exch})
\\[1.5em]
\hspace{0em}\mdeff
  {\begin{array}{l}\sem{\coctx{\Gamma_1,y\!:\!\tau_1,z\!:\!\tau_1,\Gamma_2\\[-0.25em]\qquad}
      {\aclrd{\textbf{r}} \atimes \alift{\cclrd{s},\cclrd{t}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}\end{array}}
  {\begin{array}{l}\sem{\coctx{\Gamma_1,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}}
          \atimes \alift{\cclrd{s} \,\cpar\, \cclrd{t}} \atimes \aclrd{\textbf{q}}} \\[-0.25em] \qquad\vdash \subst{e}{z,y}{x} : \tau}\end{array}}
  {f}
  {\begin{array}{l}\hspace{-0.5em}f\,\circ\,\ident{nest}_{\aclrd{\textbf{r}}, \alift{\cclrd{s}\,\cpar\,\cclrd{t}},
      \alift{\cclrd{s},\cclrd{t}}, \aclrd{\textbf{q}}}~\ident{dup}_{\cclrd{s}, \cclrd{t}}\hspace{-0.5em} \\[-0.25em]~\end{array}}
& (\emph{contr})
\end{array}
\end{equation*}

\vspace{2em}
Assuming the following auxiliary operations:
%
\begin{equation*}
\begin{array}{rcl}
  \ident{nest}_{\aclrd{\textbf{r}}, \aclrd{\textbf{s}}, \aclrd{\textbf{s'}}, \aclrd{\textbf{t}}}~f &=&
    \ident{merge}_{\aclrd{\textbf{r}}, \aclrd{\textbf{s'}}\atimes\aclrd{\textbf{t}}} \;\circ\;
      \ident{id} \times(\ident{merge}_{\aclrd{\textbf{s'}}, \aclrd{\textbf{t}}} \,\circ\, f \times \ident{id} \,\circ\, \ident{split}_{\aclrd{\textbf{s}}, \aclrd{\textbf{t}}}) \;\circ\;
      \ident{split}_{\aclrd{\textbf{r}}, \aclrd{\textbf{s}}\atimes\aclrd{\textbf{t}}}
\end{array}
\end{equation*}
\begin{equation*}
\begin{array}{rcl}
  \ident{id}~x &=& x \\[-0.25em]
  \ident{const}~v &=& \lambda x.v \\[-0.25em]
  \ident{curry}~f~x~y &=& \lambda f.\lambda x.\lambda y.f~(x, y)\\[-0.25em]
  \ident{fst}~(x,y) &=& x\\[-0.25em]
  \ident{swap}~(x,y) &=& (y,x)\\[-0.25em]
  f \times g &=& \lambda (x, y).(f~x, g~y)\\[-0.25em]
  \ident{app}~(f, x) &=& f~x
\end{array}
\end{equation*}

\figcaption{Categorical semantics of the structural coeffect calculus}
\label{fig:struct-semantics}
\end{figure*}

% --------------------------------------------------------------------------------------------------

\subsection{Semantics of structural calculus}

The concrete semantics for liveness and bounded variable use shown in
Sections~\ref{sec:applications-struct-live} and \ref{sec:applications-struct-bll}
suggests that semantics of structural coeffect calculi tend to be more complex
than semantics of flat coeffect calculi. The complexity comes from the fact
that we need a more expressive representation of the variable context -- \eg~a vector
of optional values. Additionally, the structural system needs to pass separate variable
contexts to the sub-expressions.

The latter aspect is fully captured by the semantics shown in this section. The
earlier point is left to the concrete notion of structural coeffect. Our model still gives
us the flexibility of defining the concrete representation of variable vectors. We explore
a number of examples in Section~\ref{sec:struct-semantics-examples} and start by looking
at a unified categorical semantics defined in terms of \emph{structural indexed comonads}.

\paragraph{Contexts and functions.}
In the structural coeffect calculus, expressions in context are interpreted as functions taking
a vector (represented using $-\xtimes-$) wrapped in a structure indexed with a vector of annotations
such as $\ctyp{\aclrd{\textbf{r}}}$. Functions take only a single variable as an input and so the
structure is annotated with a scalar, such as $\ctyp{\cclrd{r}}$, which we treat as being equivalent
to a singleton vector annotation $\ctyp{\alift{\cclrd{r}}}$:
%
\begin{equation*}
\begin{array}{rcl}
\sem{\coctx{x_1\!:\!\tau_1, \ldots, x_n\!:\!\tau_n}{ \alift{\cclrd{r_1}, \ldots, \cclrd{r_n}} } \vdash e : \tau}
  &:& \ctyp{ \alift{\cclrd{r_1}, \ldots, \cclrd{r_n}} }{(\tau_1 \xtimes \ldots \xtimes \tau_n)} \rightarrow \tau\\
\sem{\tau_1 \xrightarrow{\cclrd{r}} \tau_2} &=& \ctyp{\alift{\cclrd{r}}}{\tau_1} \rightarrow \tau_2
\end{array}
\end{equation*}
%
Note that the instances of flat indexed comonad ignored the fact that the variable
context wrapped in the data structure is a product. This is not generally the case for the
structural indexed comonads -- the definitions shown in Section~\ref{sec:struct-semantics-examples}
are given specifically for $\ctyp{ \alift{\cclrd{r_1}, \ldots, \cclrd{r_n}} }{(\tau_1 \xtimes \ldots \xtimes \tau_n)}$
rather than more generally for $\ctyp{\aclrd{\textbf{r}}}{\alpha}$. The need to examine the structure
of the variable context is another reason for using $-\xtimes-$ when interpreting expressions in contexts.

\paragraph{Expressions.}
A semantics of structural coeffect calculi is shown in Figure~\ref{fig:struct-semantics}. The
semantics is written as composition of morphisms using a number of auxiliary definitions. Due to
the eqivalence between Cartesian Closed Categories and the $\lambda$-calculus, we will treat it
as specifying translation to a target functional langauge in Section~\ref{sec:struct-transl}.

The following summarizes how the standard syntax-driven rules work, highlighting the differences
from the flat version:

\begin{itemize}
\item When accessing a variable (\emph{var}), the context now contains \emph{only} the accessed
  variable and so the semantics is just $\ident{counit}_{\cunit}$ without a projection.
  Constants (\emph{const}) are interpreted by a constant function.

\item The semantics of flat function application first duplicated the context so that the same
  variables can be passed to both sub-expressions. This is no longer needed -- the
  (\emph{app}) rule splits the variables \emph{including} the additional context into two parts.
  Passing the first context to the semantics of $e_1$ gives us a function
  $\ctyp{\alift{\cclrd{t}}}{\tau_1} \rightarrow \tau_2$.

  A value $\ctyp{\alift{\cclrd{t}}}{\tau_1}$ required in order to call the function is obtained by
  applying $\ident{cobind}_{\cclrd{t}, \aclrd{\textbf{s}}}$ to the semantics of $e_2$. The result
  $\ctyp{\cclrd{t}\aseq\aclrd{\textbf{s}}}{(\ldots \xtimes \ldots \xtimes \ldots)} \rightarrow \ctyp{\alift{\cclrd{t}}}{\tau_1}$
  is then called with the latter part of the split input context.

\item The semantics of function abstraction (\emph{abs}) is syntactically the same as in the
  flat version -- the only difference is that we now merge a free-variable context with a
  singleton vector, both at the level of variable assignments and at the level of coeffect
  annotations.
\end{itemize}

\noindent
The semantics for the non-syntax-driven rules (weakening, exchange, contraction) performs
transformations on the free-variable context. Weakening (\emph{weak}) splits the context and
ignores the part corresponding to the removed variable. If we were modelling the semantics in
a language with a linear type system, this would require an additional operation for ignoring an
unused context annotated with $\aclrd{\czero}$.

The remaining rules perform a transformation anywhere inside the free-variable vector.
To simplify writing the semantics, we define a helper
$\ident{nest}_{\aclrd{\textbf{r}}, \aclrd{\textbf{s}}, \aclrd{\textbf{s'}}, \aclrd{\textbf{t}}}$
that splits the variable vector into three parts, transforms the middle part and then
merges them, using the newly transformed middle part.

The transformations on the middle part are quite simple. The (\emph{exch}) rule swaps two
single-variable contexts and the (\emph{contr}) rule uses the $\ident{dup}_{\cclrd{s}, \cclrd{t}}$
operation to duplicate a variable while splitting its additional context.

\paragraph{Properties.}

As in the flat calculus, the main reason for defining the categorical semantics in this chapter
is to provide validation for the design of the calculus. The following correspondence theorem
states that the annotations in the typing rules of the structural coeffect calculus correspond
to the indices of the semantics. Thus, the calculus captures a context-dependent property if
it can be modelled by a \emph{structural indexed comonad}. As we show in the next section,
this is the case for all three discussed examples (liveness, dataflow, bounded variable reuse).

\begin{theorem}[Correspondence]
\label{thm:struct-correspondence}
In all of the typing rules of the structural coeffect system, the context annotations $\aclrd{\textbf{r}}$
and $\cclrd{s}$ of typing judgements $\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e : \tau$ and function types
$\tau_1 \xrightarrow{\cclrd{s}} \tau_2$  correspond to the indices of mappings $\ctyp{\aclrd{\textbf{r}}}{}$
and $\ctyp{\alift{\cclrd{s}}}{}$ in the corresponding semantic function defined
by $\sem{\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e : \tau}$.
\end{theorem}
\begin{proof}
By analysis of the semantic rules in Figure~\ref{fig:struct-semantics}.
\end{proof}

% --------------------------------------------------------------------------------------------------

\subsection{Examples of structural indexed comonads}
\label{sec:struct-semantics-examples}

The categorical semantics for structural coeffect calculus is easily instantiated to give
semantics for a concrete calculus. In this section, we revisit the three examples discussed
throughout this chapter -- structural liveness, dataflow and bounded variable reuse.
Some aspects of the first two examples will be similar to flat versions discussed in
Section~\ref{sec:semantics-flat-monoidal} -- they are based on the same data structures (option and a
list, respectively), but the data structures are composed differently. Generally speaking,
rather than having a data structure over a product of variables, we now have
a vector of variables over a specific data structure.

The abstract semantics does not specify how vectors of variables should be represented, so this can
vary in concrete instantiations. In all our examples, we represent a vector of variables as a
product written using $\times$. To distinguish between products representing vectors and ordinary
products (\eg~a product of contexts returned by \ident{split}), we write vectors using
$\langle a, \ldots, b \rangle$ rather than the parentheses, used for ordinary tuples.

\paragraph{Dataflow.}
It is interesting to note that the semantics of dataflow and bounded variable reuse (discussed
next) both keep a product of multiple values for each variable, so they are both built around an
\emph{indexed list} data structure. However, their \ident{cobind} and \ident{dup} operations work
differently. We start by looking at the structure modelling dataflow computations. For readability,
variables in bold face (such as $\mathbf{a_1}$) range over vectors while ordinary notation (such
as $a_1$) is used for individual values.

\begin{example}[Indexed list for dataflow]
\label{thm:struct-dfl}
The indexed list model of dataflow computations is defined over a structural coeffect
algebra $(\mathbb{N}, +, \mathit{max}, 0, 0, \leq)$. The data type $\ctyp{\langle n_1, \ldots, n_k\rangle}$
is indexed by required number of past variables for each individual variable. It is defined
over a vector of variables $\alpha_1 \xtimes \ldots \xtimes \alpha_k$ and it keeps a product
containing a current value followed by $n_i$ past values:
%
\begin{equation*}
\ctyp{\langle n_1, \ldots, n_k\rangle}{(\alpha_1 \xtimes \ldots \xtimes \alpha_k)} =
\underbrace{(\alpha_1 \times \ldots \times \alpha_1)}_{(n_1+1)-\textnormal{times}} \times \ldots \times
  \underbrace{(\alpha_k \times \ldots \times \alpha_k)}_{(n_k+1)-\textnormal{times}}
\end{equation*}
%
The mappings that define the structural indexed comonad include the \ident{split} and \ident{merge}
operations that are shared by the other two examples (discussed below):
%
\begin{equation*}
\begin{array}{l}
\ident{merge}_{\langle m_1, \ldots, m_k \rangle, \langle n_1, \ldots n_l \rangle}
  (\langle \mathbf{a_1}, \ldots, \mathbf{a_k} \rangle, \langle \mathbf{b_1}, \ldots, \mathbf{b_l}\rangle) = \\[-0.25em]
\quad \langle \mathbf{a_1}, \ldots, \mathbf{a_k}, \mathbf{b_1}, \ldots, \mathbf{b_l}\rangle
\\[0.45em]
\ident{split}_{\langle m_1, \ldots, m_k \rangle, \langle n_1, \ldots n_l \rangle}
   \langle \mathbf{a_1}, \ldots, \mathbf{a_k}, \mathbf{b_1}, \ldots, \mathbf{b_l}\rangle = \\[-0.25em]
\quad (\langle \mathbf{a_1}, \ldots, \mathbf{a_k} \rangle, \langle \mathbf{b_1}, \ldots, \mathbf{b_l}\rangle)
\end{array}
\end{equation*}
%
The remaining mappings that are required by structural indexed comonad and capture the
essence of dataflow computations are defined as:
%
\begin{equation*}
\begin{array}{l}
\ident{counit}_{0}~\langle \langle a_0 \rangle \rangle = a_0
\\[0.45em]
\ident{cobind}_{m, \langle n_1, \ldots, n_k \rangle}~f~
  \langle \langle a_{1,0}, \ldots a_{1,m+{n_1}} \rangle, \ldots, \langle a_{k,0}, \ldots a_{k,m+{n_k}} \rangle \rangle = \\[-0.25em]
\quad \langle\langle\; f \langle \langle a_{1,0}, \ldots a_{1,{n_1}} \rangle, \ldots, \langle a_{k,0}, \ldots a_{k,{n_k}} \rangle \rangle, ~\ldots~, \\[-0.25em]
\quad ~~~\; f \langle \langle a_{1,m}, \ldots a_{1,m+{n_1}} \rangle, \ldots, \langle a_{k,m}, \ldots a_{k,m+{n_k}} \rangle \rangle~\; \rangle\rangle
\\[0.45em]
\ident{dup}_{m, n} \langle \langle a_1, \ldots, a_{\mathit{max}(m,n)} \rangle \rangle =
   \langle \langle a_1, \ldots, a_m \rangle, \langle a_1, \ldots, a_n \rangle \rangle
\end{array}
\end{equation*}
\end{example}

\noindent
The definition of the indexed list data structure relies on the fact that the number of annotations
corresponds to the number of variables combined using $-\xtimes-$. It then creates a vector of lists
containing $n_i+1$ values for the $i$-\textit{th} variable (the annotation represents the number of
required \emph{past} values so one more value is required).

The \ident{split} and \ident{merge} operations are defined separately, because they are not specific
to the example. They operate on the top-level vectors of variables (without looking at the
representation of the variable). This means that we can re-use the same definitions for the following
two examples (with the only difference that $\mathbf{a_i}, \mathbf{b_i}$ will there represent options
rather than lists).

The mappings that explain how dataflow computations work are \ident{cobind} (representing sequential
composition) and \ident{dup} (representing context sharing or parallel composition). In \ident{cobind},
we get $k$ vectors corresponding to $k$ variables, each with $m+n_i$ values. The operation calls
$f$ $m$-times to obtain $m$ past values required as the result of type $\ctyp{\langle m \rangle} \beta$.

The $\ident{dup}_{m,n}$ operation needs to produce a two-variable context containing $m$ and $n$ values,
respectively, of the input variable. The input provides $\mathit{max}(m, n)$ values, so the definition
is simply a matter of restriction. Finally, \ident{counit} extracts the value of its single variable.

\paragraph{Bounded reuse.}
As mentioned earlier, the semantics of calculus for bounded reuse is also based on the indexed list
structure. Rather than representing possibly different past values that can be shared (see the
definition of \ident{dup}), the list now represents multiple copies of the same value as each value
can only be accessed once. This semantics follows that of Girard \cite{logic-bounded}.

\begin{example}[Indexed list for bounded reuse]
\label{thm:struct-bll}
The indexed list model of bounded variable reuse is defined over a structural coeffect
algebra $(\mathbb{N}, \ast, +, 1, 0, \leq)$. The data type $\ctyp{\langle n_1, \ldots, n_k\rangle}$
is a vector containing $n_i$ values of $i$-\textit{th} variable:
%
\begin{equation*}
\ctyp{\langle n_1, \ldots, n_k\rangle}{(\alpha_1 \xtimes \ldots \xtimes \alpha_k)} =
\underbrace{(\alpha_1 \times \ldots \times \alpha_1)}_{n_1-\textnormal{times}} \times \ldots \times
  \underbrace{(\alpha_k \times \ldots \times \alpha_k)}_{n_k-\textnormal{times}}
\end{equation*}
%
The \ident{merge} and \ident{split} operations are defined as in Example~\ref{ex:struct-dfl}.
The operations that capture the behaviour of bounded reuse are:
%
\begin{equation*}
\begin{array}{l}
\ident{counit}_{1}~\langle \langle a_0 \rangle \rangle = a_0
\\[0.45em]
\ident{dup}_{m, n} \langle \langle a_1, \ldots, a_{m+n} \rangle \rangle =
\quad \langle \langle a_1, \ldots, a_m \rangle, \langle a_{m+1}, \ldots, a_{m+n} \rangle \rangle
\\[0.45em]
\ident{cobind}_{m, \langle n_1, \ldots, n_k \rangle}~f~
  \langle \langle a_{1,0}, \ldots a_{1,m\ast{n_1}} \rangle, \ldots, \langle a_{k,0}, \ldots a_{k,m\ast{n_k}} \rangle \rangle = \\[-0.25em]
\quad \langle\; f \langle \langle a_{1,0}, \ldots a_{1,{n_1 - 1}} \rangle, \ldots, \langle a_{k,0}, \ldots a_{k,{n_k - 1}} \rangle \rangle, ~\ldots~, \\[-0.25em]
\quad ~~ f \langle \langle a_{1,(m-1)\ast n_1}, \ldots a_{1,(m-1) \ast n_1} \rangle, \ldots,
                   \langle a_{k,m\ast n_k - 1}, \ldots a_{k,m\ast n_k - 1} \rangle \rangle~\; \rangle
\end{array}
\end{equation*}
\end{example}

\noindent
The \ident{counit} operation is defined as previously -- it extracts the only value of the only
variable In the bounded variable reuse system, variable sharing is annotated with the $+$ operator
(in contrast with \textit{max} used in dataflow). The $\ident{dup}_{m,n}$ operation thus splits the $m+n$
available values between two vectors of length $m$ and $n$, without \emph{sharing} a value. The
\ident{cobind} operation works similarly -- it splits $m\ast n_i$ available values of each
variable into $m$ vectors containing $n_i$ copies and then calls the $f$ function $m$-times to
obtain $m$ resulting values without sharing any input value.

\paragraph{Liveness.}
In both dataflow and bounded reuse, the data type is defined as a vector of values obtained
by applying the indexed list type constructor to types of individual variables. We can
generalize this pattern. Given a parameterized (indexed) type constructor $D^l \alpha$, we define
$\ctyp{\langle l_1, \ldots, l_n \rangle}$ in terms of a vector of $D^{l_i}$ types.
For liveness, the definition lets us reuse some of the mappings used when defining the semantics of
flat liveness. However, we cannot fully define the semantics of the structural version in terms of
the flat version -- the \ident{cobind} operation is different and we need an appropriate
\ident{dup} operation.

\begin{example}[Structural indexed option]
\label{thm:struct-live}
Given a structural coeffect algebra formed by $(\{ \ident{L}, \ident{D} \}, \sqcap, \sqcup, \ident{L}, \ident{D}, \sqsubseteq)$
and the indexed option data type $D^l$, such that $D^{\ident{D}}\alpha = 1$ and $D^{\ident{L}}\alpha=\alpha$,
the data type for structural indexed option comonad is:
%
\begin{equation*}
\ctyp{\langle n_1, \ldots, n_k\rangle}{(\alpha_1 \xtimes \ldots \xtimes \alpha_k)} =
  D^{n_1} \alpha_1 \times \ldots \times D^{n_k} \alpha_k
\end{equation*}
%
The \ident{merge} and \ident{split} operations are defined as earlier. The remaining operations
model variable liveness as follows:
%
\begin{equation*}
\begin{array}{l}
\ident{cobind}_{\ident{L}, \langle l_1, \ldots, l_n \rangle}~f~\langle a_1, \ldots, a_n \rangle = \langle f~\langle a_1, \ldots, a_n \rangle \rangle \\[-0.25em]
\ident{cobind}_{\ident{D}, \langle \ident{D}, \ldots, \ident{D} \rangle}~f~\langle (), \ldots, () \rangle = \langle \ident{D} \rangle
\\[0.5em]
\hspace{-0.5em}
\begin{array}{lll}
~\\[-0.85em]
\ident{dup}_{\ident{D}, \ident{D}} \langle () \rangle &\narrow{=}& \langle (), () \rangle \\[-0.25em]
\ident{dup}_{\ident{L}, \ident{D}} \langle a \rangle &\narrow{=}& \langle a, () \rangle \\[-0.25em]
\ident{dup}_{\ident{D}, \ident{L}} \langle a \rangle &\narrow{=}& \langle (), a \rangle \\[-0.25em]
\ident{dup}_{\ident{L}, \ident{L}} \langle a \rangle &\narrow{=}& \langle a, a \rangle
\end{array}
\qquad\quad
\begin{array}{lll}
\ident{counit}_{\ident{L}}~\langle a \rangle &\narrow{=}& a
\end{array}
\end{array}
\end{equation*}
\end{example}

\noindent
When the expected result of the \ident{cobind} operation is dead (second case), the operation can
ignore all inputs and directly return the unit value $()$. Otherwise, it passes the vector of
input variables to $f$ as-is -- no matter whether the individual values are live or dead. The
\ident{L} annotation is a unit with respect to $\cap$ and so the annotations expected by $f$ are
the same as those required by the result of \ident{cobind}.

The \ident{dup} operation resembles with the flat version of \ident{split} -- this is expected as
duplication in the flat calculus is performed by first duplicating the variable context (using
\ident{map}) and then applying \ident{split}. Here, the duplication returns a pair. Depending on the
required coeffect annotations, this may copy (duplicate) the value, or it may produce an empty context.

Finally, \ident{counit} extracts a value which is always present as guaranteed by the type
$\ctyp{\langle \ident{L} \rangle}{\alpha} \rightarrow \alpha$. The lifting operation models
sub-coeffecting which can turn a context with a value into a dead context (second case); otherwise
it behaves as identity.

\paragraph{Properties.}
The concrete categortical semantics presented in this section is a generalization of the concrete
semantics given when introducing context-aware programming languages in Chapter~\ref{ch:applications}.

\begin{theorem}[Generalization]
\label{thm:struct-generalization}

Consider a typing derivation obtained according to the rules for finding unique typing derivations
as specified in Section~\ref{sec:struct-unique} for a coeffect language with liveness, dataflow or
bounded variable use.

The semantics obtained by instantiating the rules in Figure~\ref{fig:struct-semantics} with the
concrete operations defined in Example~\ref{thm:struct-live},
Example~\ref{thm:struct-dfl} or Example~\ref{thm:struct-bll} is the
same as the one defined in Figure~\ref{fig:applications-struct-livesem},
Section~\ref{sec:applications-structural-dataflow} and Section~\ref{sec:applications-struct-bll},
respectively.
\end{theorem}
\begin{proof}
Simple expansion of the definitions for the unique typing derivation.
\end{proof}


% ==================================================================================================
%
%    #######
%       #    #####    ##   #    #  ####  #        ##   ##### #  ####  #    #
%       #    #    #  #  #  ##   # #      #       #  #    #   # #    # ##   #
%       #    #    # #    # # #  #  ####  #      #    #   #   # #    # # #  #
%       #    #####  ###### #  # #      # #      ######   #   # #    # #  # #
%       #    #   #  #    # #   ## #    # #      #    #   #   # #    # #   ##
%       #    #    # #    # #    #  ####  ###### #    #   #   #  ####  #    #
%
% ==================================================================================================

\section{Translational semantics}
\label{sec:struct-transl}

In the previous section, we used category theory to give a unified model capable of capturing
the semantics of our three context-aware language based on the structural coeffect calculus.
Although the categorical model is interesting on its own, we use it in the same way as in
Chapter~\ref{ch:semantics} -- to define a translation from source context-aware languages to a
simple target functional language. As for flat coeffect calculus, we show that the translation
produces well-typed programs in the target language. For a sample context-aware programming
language, we then show that well-typed programs (produced by the translation) do not get stuck.

This section mirrors the development presented in Chapter~\ref{ch:semantics} for flat coeffect
calculus. We extend the simple target language with additional constructs inspired by structural
indexed comonads (Section~\ref{sec:struct-transl-ext}), define the translation to the target
langauge (Section~\ref{sec:struct-transl-transl}) and prove safety of one sample language
(Section~\ref{sec:struct-transl-safety}) -- we choose structural dataflow to allow easy
comparison with the flat system.

% --------------------------------------------------------------------------------------------------

\begin{figure}[t]
\paragraph{Language syntax.}
Given a structural coeffect algebra, extend the programming language syntax with the following
constructs:

\begin{equation*}
\begin{array}{rcl}
  e &  =  &\ldots \sep\ident{cobind}_{\cclrd{s},\aclrd{\textbf{r}}}~e_1~e_2 \sep \ident{counit}_{\cunit}~e \sep \ident{merge}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}~e
         \sep \ident{split}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}~e \sep \ident{dup}_{\cclrd{r},\cclrd{s}}~e \\
  \tau &  = &\ldots \sep \ctyp{\aclrd{\textbf{r}}}{(\tau_1 \xtimes \ldots \xtimes \tau_k)} \\
  K  & = &\ldots \sep \ident{cobind}_{\cclrd{s},\aclrd{\textbf{r}}}~\_~e \sep \ident{cobind}_{\cclrd{s},\aclrd{\textbf{r}}}~v~\_ \sep \ident{counit}_{\cunit}~\_ \\
    && \hspace{1.4em} \sep \ident{merge}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}~\_
           \sep \ident{split}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}~\_ \sep \ident{dup}_{\cclrd{r},\cclrd{s}}~\_ \\
\end{array}
\end{equation*}

~

~

\paragraph{Typing rules.}
Given a structural coeffect algebra, add the typing rules:

\begin{equation*}
\begin{array}{l}
\tyrule{counit}
  {\Gamma \vdash e : \ctyp{\alift{\cunit}}{\tau}}
  {\Gamma \vdash \ident{counit}_{\cunit}~e : \tau} \\
\\
\tyrule{cobind}
  {\Gamma \vdash e_1 : \ctyp{\aclrd{\textbf{r}}}{(\tau_1 \xtimes \ldots \xtimes \tau_k)} \rightarrow \tau & \Gamma \vdash e_2 : \ctyp{\cclrd{s}\aseq\aclrd{\textbf{r}}}{\tau_1(\tau_1 \xtimes \ldots \xtimes \tau_k)} }
  {\Gamma \vdash \ident{cobind}_{\cclrd{s}, \aclrd{\textbf{r}}}~e_1~e_2 : \ctyp{\alift{\cclrd{s}}}{\tau}} \\
  \\
\tyrule{merge}
  {\Gamma \vdash  e : \ctyp{\aclrd{\textbf{r}}}{(\tau_1 \xtimes \ldots \xtimes \tau_l)} \times \ctyp{\aclrd{\textbf{s}}}{(\tau_{l+1} \xtimes \ldots \xtimes \tau_k)} }
  {\Gamma \vdash  \ident{merge}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}~e : \ctyp{\aclrd{\textbf{r}}\atimes\aclrd{\textbf{s}}}{(\tau_1 \xtimes \ldots \xtimes \tau_k)} }\\
\\
\tyrule{split}
  {\Gamma \vdash  e : \ctyp{\aclrd{\textbf{r}}\atimes\aclrd{\textbf{s}}}{(\tau_1 \xtimes \ldots \xtimes \tau_k)} }
  {\Gamma \vdash  \ident{split}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}~e : \ctyp{\aclrd{\textbf{r}}}{(\tau_1 \xtimes \ldots \xtimes \tau_l)} \times \ctyp{\aclrd{\textbf{s}}}{(\tau_{l+1} \xtimes \ldots \xtimes \tau_k)}} \\
\\
\tyrule{dup}
  {\Gamma \vdash  e : \ctyp{\alift{\cclrd{r}\cpar\cclrd{s}}}{\tau} }
  {\Gamma \vdash  \ident{dup}_{\cclrd{r},\cclrd{s}}~e : \ctyp{\alift{\cclrd{r},\cclrd{s}}}{(\tau \xtimes \tau)} } \\
\end{array}
\end{equation*}

\caption{Comonadically-inspired extensions for structural coeffects}
\label{fig:struct-semantics-ext}
\end{figure}

% --------------------------------------------------------------------------------------------------

\subsection{Comonadically-inspired language extensions}
\label{sec:struct-transl-ext}

In Section~\ref{sec:semantics-translation-target}, we defined the syntax, typing rules and
operational semantics for a simple functional programming language. We then extended it with
uninterpreted constructs inspired by the \emph{flat indexed comonad} structure and used it as the
translation target for the flat coeffect calculus. In this section, we take the same core language
and extend it with constructs inspired by the \emph{structural indexed comonad}.

Given a coeffect language with a structural coeffect algebra formed by
$(\C, \cseq, \cpar, \cunit, \czero, \cleq)$ and operations $\alift{-}$ and $\aseq, \atimes$, we
extend the core functional language with operations shown in Figure~\ref{fig:struct-semantics-ext}.
The syntax extensions add comonadically-inspired operations that mirror those defined in
Section~\ref{sec:struct-semantics-idxc}. The typing for the operations corresponds to their
categorical counterparts.

We also include an uninterpreted type $\ctyp{\aclrd{\textbf{r}}}{\tau_1\xtimes\ldots\xtimes\tau_k}$,
which models a contextual (comonadic) value indexed by a vector of annotations. As in the
categorical model for structural coeffects, context consisting of multiple variables is not modelled
as ordinary tuple -- it can only be manipulated by the comonadically-inspired operations.
In the target language, this is done by defining the $\ctyp{\aclrd{\textbf{r}}}{}$ type over
zero or more underlying types. Here, our syntactic treatment differs slightly from the categorical
model where objects created by $\xtimes$ were first-class values. In Figure~\ref{fig:struct-semantics-ext},
we need to explicitly specify the types of individual components in typing rules for
(\emph{merge}), (\emph{split}) and (\emph{cobind}).

As with flat coeffects, the extensions described here are common for all concrete instances of
structural context-aware languages. For each concrete language, we need to provide values of type
$\ctyp{\aclrd{\textbf{r}}}{\tau}$ and reduction rules for comonadically-inspired operations.

% --------------------------------------------------------------------------------------------------

\begin{figure*}[!t]
The translation is defined over a typing derivation:
%
\begin{equation*}
\begin{array}{ll}
\hspace{3.25em}\semdef
  {\coctx{x\!:\!\tau}{\alift{\cunit}} \vdash x : \tau}
  {\lambda\ctx.\ident{counit}_{\cunit}~\ctx}
& (\emph{var})
\\[1em]
\hspace{4em}\semdef
  {\coctx{()}{\alift{}} \vdash n : \ident{num} }
  {\lambda\ctx.n}
& (\emph{num})
\\[1.5em]
\hspace{0.8em}\semdeff
  {\coctx{\Gamma, x\!:\!\tau_1}{\aclrd{\textbf{r}}\,\atimes\,\alift{\cclrd{s}}} \vdash e : \tau_2}
  {\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash \lambda x.e : \tau_1 \xrightarrow{\cclrd{s}} \tau_2}
  {f}
  {\lambda\ctx.\lambda v.f~(\ident{merge}_{\aclrd{\textbf{r}}, \alift{\cclrd{s}}}~(\ctx, v)) }
& (\emph{abs})
\\[2em]
\hspace{-2.5em}\emdefff
  {\coctx{\Gamma_1}{\aclrd{\textbf{r}}} \vdash e_1 : \tau_1 \xrightarrow{\cclrd{t}} \tau_2}
  {\coctx{\Gamma_2}{\aclrd{\textbf{s}}} \vdash e_2 : \tau_1}
  {\begin{array}{l}\sem{\coctx{\Gamma_1, \Gamma_2}{\aclrd{\textbf{r}\,\atimes\,(\cclrd{t} \aseq \aclrd{\textbf{s}})}} \vdash e_1~e_2 : \tau_2}\\[-0.25em]~\\[-0.25em]~\end{array}}
  {f}
  {g}
  {\hspace{-0.5em}\begin{array}{l}
  \lambda\ctx.~~\\[-0.25em]
    \quad \kvd{let}~(\ctx_1, \ctx_2) = \ident{split}_{\aclrd{\textbf{r}}, \cclrd{t} \,\aseq\, \aclrd{\textbf{s}}}~\ctx\\[-0.25em]
    \quad f~\ctx_1~(\ident{cobind}_{\cclrd{t}, \aclrd{\textbf{s}}}~g~\ctx_2)
  \end{array} }
& (\emph{app})
\\[1.5em]
\hspace{0em}\emdeff
  {\coctx{\Gamma}{ \aclrd{\textbf{r}} } \vdash e : \tau}
  {\begin{array}{l}\sem{\coctx{\Gamma,x \!:\! \tau_1}{\aclrd{\textbf{r}} \atimes \alift{ \czero }} \vdash e : \tau}\\[-0.25em]~\\[-0.25em]~\\\end{array}}
  {f}
  {\hspace{-0.5em}\begin{array}{l}
  \lambda\ctx.~~\\[-0.25em]
    \quad \kvd{let}~(\ctx_1, \_) = \ident{split}_{\aclrd{\textbf{r}}, \alift{\czero}}~\ctx\\[-0.25em]
    \quad f~\ctx_1
  \end{array} }
& (\emph{weak})
\\[1.5em]
\hspace{0em}\mdeff
  {\begin{array}{l}\sem{\coctx{\Gamma_1,x\!:\!\tau_1,y\!:\!\tau_2,\Gamma_2\\[-0.25em]\qquad}
     {\aclrd{\textbf{r}} \atimes \alift{\cclrd{s},\cclrd{t}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}\end{array}}
  {\begin{array}{l}\sem{\coctx{\Gamma_1,y\!:\!\tau_2,x\!:\!\tau_1,\Gamma_2\\[-0.25em]\qquad}{\aclrd{\textbf{r}}
          \atimes \alift{\cclrd{t},\cclrd{s}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}\\[-0.25em]~\end{array}}
  {\begin{array}{l}~\\[-0.25em]\hspace{-0.5em}f\end{array}}
  {\begin{array}{l}\hspace{-0.5em}
    \lambda\ctx.~f (\ident{nest}_{\aclrd{\textbf{r}}, \alift{\cclrd{t},\cclrd{s}},\alift{\cclrd{s},\cclrd{t}}, \aclrd{\textbf{q}}}~(\lambda\ctx'.\\[-0.25em]
     \quad \kvd{let}~(\ctx_1, \ctx_2) = \ident{split}_{\alift{\cclrd{t}}, \alift{\cclrd{s}}} \\[-0.25em]
     \quad \ident{merge}_{\alift{\cclrd{s}}, \alift{\cclrd{t}}}~(\ctx_2, \ctx_1)~))\end{array} }
& (\emph{exch})
\\[1.5em]
\hspace{-0.5em}\mdeff
  {\begin{array}{l}\sem{\coctx{\Gamma_1,y\!:\!\tau_1,z\!:\!\tau_1,\Gamma_2\\[-0.25em]\qquad}
      {\aclrd{\textbf{r}} \atimes \alift{\cclrd{s},\cclrd{t}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}\end{array}}
  {\begin{array}{l}\sem{\coctx{\Gamma_1,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}}
          \atimes \alift{\cclrd{s} \,\cpar\, \cclrd{t}} \atimes \aclrd{\textbf{q}}} \\[-0.25em] \qquad\vdash \subst{e}{z,y}{x} : \tau}\end{array}}
  {\begin{array}{l}~\\[-0.25em]\hspace{-0.5em}f\end{array}}
  {\begin{array}{l}\hspace{-0.5em}\lambda\ctx.f~(\ident{nest}_{\aclrd{\textbf{r}}, \alift{\cclrd{s}\,\cpar\,\cclrd{t}},
      \alift{\cclrd{s},\cclrd{t}}, \aclrd{\textbf{q}}}\\[-0.25em]
      \qquad \ident{dup}_{\cclrd{s}, \cclrd{t}}~\ctx)\hspace{-0.5em}\end{array}}
& (\emph{contr})
\end{array}
\end{equation*}

\vspace{2em}
Assuming the following auxiliary definition:
%
\begin{equation*}
\begin{array}{l}
  \ident{nest}_{\aclrd{\textbf{r}}, \aclrd{\textbf{s}}, \aclrd{\textbf{s'}}, \aclrd{\textbf{t}}} = \lambda f.\lambda \ctx.\\[-0.25em]
  \qquad \kvd{let}~(\ctx_1, \ctx') = \ident{split}_{\aclrd{\textbf{r}}, \aclrd{\textbf{s}}\atimes\aclrd{\textbf{t}}}~\ctx\\[-0.25em]
  \qquad \kvd{let}~(\ctx_2, \ctx_3) = \ident{split}_{\aclrd{\textbf{s}},\aclrd{\textbf{t}}}~\ctx'\\[-0.25em]
  \qquad \ident{merge}_{\aclrd{\textbf{r}}, \aclrd{\textbf{s'}}\atimes\aclrd{\textbf{t}}}~(\ctx_1, \ident{merge}_{\aclrd{\textbf{s'}}, \aclrd{\textbf{t}}}~(f~\ctx_2, \ctx_3))
\end{array}
\end{equation*}

\figcaption{Trnaslation from a structural coeffect calculus}
\label{fig:struct-translation}
\end{figure*}

% --------------------------------------------------------------------------------------------------

\subsection{Comonadically-inspired translation}
\label{sec:struct-transl-transl}

When translating context-aware programs to the functional language, variable contexts become
values of comonadically-inspired data types containing a value for each variable in the context.
Function inputs become comonadically-inspired values containing exactly one variable. More formally:
%
\begin{equation*}
\begin{array}{rcl}
\sem{\coctx{x_1\!:\!\tau_1, \ldots, x_n\!:\!\tau_n}{\alift{\cclrd{r_1}, \ldots, \cclrd{r_n}}}} &=&
  \ctyp{\alift{\cclrd{r_1}, \ldots, \cclrd{r_n}}}{(\sem{\tau_1} \xtimes \ldots \xtimes \sem{\tau_n})} \\[0.5em]
\sem{\tau_1 \xrightarrow{\cclrd{r}} \tau_2} & = & \ctyp{\alift{\cclrd{r}}}{\sem{\tau_1}} \rightarrow \sem{\tau_2} \\[-0.2em]
\sem{\ident{num}} & = & \ident{num} \\
\end{array}
\end{equation*}

\noindent
The definition differs from the one for flat coeffects (Section~\ref{sec:semantics-translation-transl})
in that the comonadically-inspired data type takes multiple type parameters (separated using $\xtimes$),
rather than wrapping a regular tuple in the target language.

The translation rules are defined in Figure~\ref{fig:struct-translation}. As in the case of the flat
coeffect calculus, the definition directly follows the categorical semantics shown in
Figure~\ref{fig:struct-translation}. We expand the definitions so that the result is a valid
program in the target language rather than a composition of morphisms.

As with flat coeffects, the correspondence property of the semantics (Theorem~\ref{thm:struct-correspondence})
can now be adapted into well-typedness of the translation. Given a well-typed program in the
structural coeffect calculus, the translation produces a well-typed program in the target
language. This is true for all context-aware languages based on the structural coeffect calculus
and it provides us with the first part of type safety theorem. The second part is type safety
of the target language with concrete domain-specific extensions as discussed in
Section~\ref{sec:struct-transl-safety}.

\begin{theorem}[Well-typedness of the translation]
\label{thm:struct-welltyped}
Given a typing derivation for a well-typed closed expression $\coctx{}{\alift{}} \vdash e : \tau$
written in a structural context-aware programming langugae that is translated to the target language as
(we write $\ldots$ for the omitted part of the translation tree):
%
\begin{equation*}
  \semdeff
    {~~(\ldots)~~}
    {\coctx{}{\alift{}} \vdash e : \tau }
    {(\ldots)}
    { ~~f }
\end{equation*}
%
Then $f$ is well-typed, \ie~in the target language: $\vdash f : \sem{\coctx{()}{\alift{}}} \rightarrow \sem{\tau}$.
\end{theorem}
\begin{proof}
By rule induction over the derivation of the translation. Given a judgement
$\coctx{x_1\!:\!\tau_1 \ldots x_n\!:\!\tau_n}{\aclrd{\textbf{c}}} \vdash e : \tau$ where
$\aclrd{\textbf{c}} = \alift{\cclrd{c_1},\ldots,\cclrd{c_n}}$, the translation
constructs a function of type $\ctyp{\aclrd{\textbf{c}}}(\sem{\tau_1}\xtimes\ldots\xtimes\sem{\tau_n}}) \rightarrow \sem{\tau}$.

\vspace{0.5em}\noindent\hangindent=0.6cm
Case (\emph{var}): $\aclrd{\textbf{c}}=\alift{\cunit}$ and so ${\ident{counit}_\cunit}~\ctx$ is well-typed.

\vspace{0.25em}\noindent\hangindent=0.6cm
Case (\emph{num}): $\tau = \ident{num}$ and so the body $n$ is well-typed.

\vspace{0.25em}\noindent\hangindent=0.6cm
Case (\emph{abs}): The type of $\ctx$ is $\ctyp{\aclrd{\textbf{r}}}(\ldots)$ and the type of $v$ is $\ctyp{\alift{\cclrd{s}}}\tau_1$,
  calling $\ident{merge}_{\aclrd{\textbf{r}},\alift{\cclrd{s}}}$ produces a context of type
  $\ctyp{\aclrd{\textbf{r}}\atimes\alift{\cclrd{s}}}(\ldots\xtimes\tau_1)$ as expected by $f$.

\vspace{0.25em}\noindent\hangindent=0.6cm
Case (\emph{app}): After applying $\ident{split}_{\aclrd{\textbf{r}}, \cclrd{t}\aseq\aclrd{\textbf{s}}}$ the types of
  $\ctx_1, \ctx_2$ are $\ctyp{\aclrd{\textbf{r}}}(\ldots)$ and $\ctyp{\cclrd{t}\aseq\aclrd{\textbf{s}}}(\ldots)$, respectively.
  $g$ requires $\ctyp{\aclrd{\textbf{s}}}(\ldots)$ and so the result of $\ident{cobind}_{\cclrd{t},\aclrd{\textbf{s}}}$ is
  $\ctyp{\alift{\cclrd{t}}}\tau_1$ as required by $f$.

\vspace{0.25em}\noindent\hangindent=0.6cm
Case (\emph{weak}): After applying $\ident{split}_{\aclrd{\textbf{r}}, \alift{\czero}}$ the type of
  $\ctx_1$ is $\ctyp{\aclrd{\textbf{r}}}(\ldots)$ as required.

\vspace{0.25em}\noindent\hangindent=0.6cm
Case (\emph{exch}), (\emph{contr}): The auxiliary definition $\ident{nest}_{\aclrd{\textbf{r}}, \aclrd{\textbf{s}}, \aclrd{\textbf{s'}}, \aclrd{\textbf{t}}}$
  keeps parts of the context corresponding to coeffect annotations $\aclrd{\textbf{r}}, \aclrd{\textbf{q}}$ unchanged and transforms
  the nested part. In (\emph{exch}), the provided lambda function is of type $\ctyp{\alift{\cclrd{s},\cclrd{t}}}{(\tau_1\xtimes\tau_2)}
  \rightarrow \ctyp{\alift{\cclrd{t},\cclrd{s}}}{(\tau_2\xtimes\tau_1)}$. In (\emph{contr}), the type of
  $\ident{dup}_{\cclrd{s},\cclrd{t}}$ is $\ctyp{\alift{\cclrd{s}\cpar\cclrd{t}}}{\tau} \rightarrow \ctyp{\alift{\cclrd{s},\cclrd{t}}}{(\tau\xtimes\tau)}$
  (assuming \ident{nest} is expanded, rather than treated as a value within the language).
\end{proof}

% --------------------------------------------------------------------------------------------------

\subsection{Structural coeffect language for dataflow}
\label{sec:struct-transl-safety}

The target language with comonadically-inspired primitives provides a framework that can be used
to model a variety of structural context-aware langauges and prove their safety. As outlined in
Section~\ref{sec:semantics-generalising}, the key principle that guarantees the safety of the
target language is a correspondence between coeffect annotations and the values they represent.
In a more expressive target language (such as Haskell or Agda), it would be sufficient to
provide an implementation of the comonadically-inspired primitives for the concrete domain-specific
language.

Our simple target language is not expressive enough to capture the correspondence in the type
system and so we instead follow the same methodology as when discussing safety for flat coeffect
languages in section Section~\ref{sec:semantics-proofs} and show safety for a sample concrete
context-aware language. We consider the structural coeffect language for dataflow. The definitions
can be compared with the flat version discussed in Section~\ref{sec:semantics-proofs-df}, which
highlights the similarities and differences between the flat and structural notion of context.

% --------------------------------------------------------------------------------------------------

\begin{figure}[t]
\vspace{-0.5em}
\paragraph{Language syntax}
\begin{equation*}
\begin{array}{rcl}
v &=& \ldots \sep \ident{Df}\langle \textbf{v}_0, \ldots, \textbf{v}_k \rangle
    \hspace{9.5em} \textbf{v} ~=~ \langle v_0, \ldots, v_k \rangle \\
e &=& \ldots \sep \ident{Df}\langle \textbf{e}_0, \ldots, \textbf{e}_k \rangle \sep \ident{prev}_{\cclrd{n_0}, \ldots, \cclrd{n_k}}~e
    \quad\qquad \textbf{e} ~=~ \langle e_0, \ldots, e_k \rangle \\
K &=& \ldots \sep \ident{Df}\langle \textbf{v}_0, \ldots, \langle v_{j,0}, \ldots, v_{j, i-1}, \_, e_{j, i+1} \ldots, e_{j, n}\rangle, \ldots, \textbf{e}_k\rangle \\
   && \ldots \sep \ident{prev}_{\cclrd{n_0}, \ldots, \cclrd{n_k}}~\_
\end{array}
\end{equation*}

\vspace{0.75em}
\paragraph{Typing rules}

\begin{equation*}
\tyrule{vec}
  { \forall i\in\{0\ldots n\}. ~ \Gamma \vdash e_i : \tau}
  { \Gamma \vdash_{\ident{vec}} \langle e_0, \ldots, e_n \rangle : \tau, \cclrd{n} }
\end{equation*}
\begin{equation*}
\tyrule{df}
  { \forall i\in\{0\ldots k\}. ~ \Gamma \vdash_{\ident{vec}} \textbf{e}_i : \tau_i, \cclrd{n_i}}
  { \Gamma \vdash \ident{Df}\langle \textbf{e}_0, \ldots, \textbf{e}_k \rangle : \ctyp{\alift{\cclrd{n_0}, \ldots, \cclrd{n_k}}}{(\tau_0\xtimes\ldots\xtimes\tau_k)} }
\end{equation*}
\begin{equation*}
\tyrule{prev}
  { \Gamma \vdash e : \ctyp{\alift{\cclrd{n_0+1},\ldots,\cclrd{n_k+1}}}{(\tau_0\xtimes\ldots\xtimes\tau_k)} }
  { \Gamma \vdash \ident{prev}_{\cclrd{n_0},\ldots,\cclrd{n_k}}~e : \ctyp{\alift{\cclrd{n_0},\ldots,\cclrd{n_k}}}{(\tau_0\xtimes\ldots\xtimes\tau_k)} }
\end{equation*}

\vspace{1em}
\paragraph{Translation}

\begin{equation*}
\semdeff
  { \coctx{\Gamma}{\alift{\cclrd{n_0+1},\ldots,\cclrd{n_k+1}}} \vdash e : \tau }
  { \coctx{\Gamma}{\alift{\cclrd{n_0},\ldots,\cclrd{n_k}}} \vdash \kvd{prev}~e : \tau }
  {f}
  {\lambda ctx.\ident{prev}_{\cclrd{n_0},\ldots,\cclrd{n_k}}~\ctx }
\end{equation*}

\vspace{1em}
\paragraph{Reduction rules}

\begin{equation*}
\begin{array}{rl}
{\footnotesize(\emph{counit})} & \begin{array}{l}
\ident{counit}_{\cclrd{0}}(\ident{Df} \langle\langle v_0 \rangle\rangle)   \rightsquigarrow v_0
\end{array}
\\[0.25em]
{\footnotesize(\emph{cobind})} & \begin{array}{l}
\ident{cobind}_{\cclrd{m}, \alift{\cclrd{n_1},\ldots,\cclrd{n_k}}}~f~\ident{Df}\langle \langle a_{1,0}, \ldots a_{1,m+{n_1}} \rangle, \ldots, \langle a_{k,0}, \ldots a_{k,m+{n_k}} \rangle \rangle \rightsquigarrow \\[-0.25em]
\quad \ident{Df}\langle\langle\; f (\ident{Df}\langle \langle a_{1,0}, \ldots a_{1,{n_1}} \rangle, \ldots, \langle a_{k,0}, \ldots a_{k,{n_k}} \rangle \rangle), ~\ldots~, \\[-0.25em]
\qquad ~~~\, f (\ident{Df}\langle \langle a_{1,m}, \ldots a_{1,m+{n_1}} \rangle, \ldots, \langle a_{k,m}, \ldots a_{k,m+{n_k}} \rangle \rangle)~\; \rangle\rangle
\end{array}
\\[0.25em]
{\footnotesize(\emph{merge})} & \begin{array}{l}
\ident{merge}_{\alift{\cclrd{m_0},\ldots,\cclrd{m_k}}, \alift{\cclrd{n_0},\ldots,\cclrd{n_l}}} ((\ident{Df}\langle \textbf{v}_0, \ldots, \textbf{v}_k \rangle), (\ident{Df}\langle \textbf{v}'_0, \ldots, \textbf{v}'_l\rangle)) \rightsquigarrow
\\[-0.25em]
\quad \ident{Df}\langle \textbf{v}_0, \ldots, \textbf{v}_k, \textbf{v}'_0, \ldots, \textbf{v}'_l \rangle
\end{array}
\\[0.25em]
{\footnotesize(\emph{split})} & \begin{array}{l}
\ident{split}_{\alift{\cclrd{m_0},\ldots,\cclrd{m_k}}, \alift{\cclrd{n_0},\ldots,\cclrd{n_l}}} (\ident{Df}\langle \textbf{v}_0, \ldots, \textbf{v}_k, \textbf{v}'_0, \ldots, \textbf{v}'_l \rangle)  \rightsquigarrow
\\[-0.25em]
\quad (\ident{Df}\langle \textbf{v}_0, \ldots, \textbf{v}_k \rangle, ~\ident{Df}\langle \textbf{v}'_0, \ldots, \textbf{v}'_l\rangle)
\end{array}
\\[0.25em]
{\footnotesize(\emph{prev})} & \begin{array}{l}
\ident{prev}_{\alift{\cclrd{n_1},\ldots,\cclrd{n_k}}} (\ident{Df}\langle\langle v_{1,0}, \ldots, v_{1, n_1}, v_{1,{n_1}+1} \rangle,\ldots,\langle v_{k,0}, \ldots, v_{k, n_k}, v_{k,{n_k}+1} \rangle\rangle) \rightsquigarrow
\\[-0.25em]
\quad \ident{Df}\langle\langle v_{1,0}, \ldots, v_{1, n_1} \rangle,\ldots,\langle v_{k,0}, \ldots, v_{k, n_k} \rangle\rangle
\end{array}
\\[0.25em]
{\footnotesize(\emph{dup})} & \begin{array}{l}
\ident{dup}_{\cclrd{m},\cclrd{n}} (\ident{Df}\langle\langle v_0, \ldots, v_{\mathit{max}(m,n)} \rangle\rangle) \rightsquigarrow
  \ident{Df}\langle\langle v_0, \ldots, v_m \rangle, \langle v_0, \ldots, v_n \rangle\rangle
\end{array}
\end{array}
\end{equation*}

\caption{Additional constructs for modelling structural dataflow}
\label{fig:structural-ext-df}
\end{figure}

% --------------------------------------------------------------------------------------------------

\paragraph{Domain-specific extensions.}

The Figure~\ref{fig:structural-ext-df} extends the target functional langauge with constructs,
typing rules, translation rules and reduction rules needed for modelling structural dataflow.
In the structural model, the type $\ctyp{\alift{\cclrd{r_0}, \ldots, \cclrd{r_n}}}{(\tau_0\xtimes\ldots\xtimes\tau_n)}$
represents a structure that provides values and additional contexts for variables of types
$\tau_0,\ldots,\tau_n$ with contextual capabilities as specified by corresponding coeffect annotations
$\cclrd{r_0}, \ldots, \cclrd{r_n}$.

In case of dataflow, the comonadically-inspired structure keeps vectors of past values for each of
the variables in the context. In the syntax, we write $\textbf{v}$ and $\textbf{e}$ for vectors of
values and expressions, respectively. The expression $\ident{Df}\langle \textbf{e}_0, \ldots, \textbf{e}_k \rangle$
is then formed by a vector of variable assignments where each variable assignment is a vector
of current and past values. When reducing expressions to values, we reduce values from left to
right and from current-most value to the last past value. This is specified by the context $K$.

When type-checking expressions that create the \ident{Df} values, we use an auxiliary judgement
$\Gamma \vdash_{\ident{vec}} e : \tau, \cclrd{n}$. The judgement checks that a vector of expressions
$\textbf{e}$ contains exactly $\cclrd{n}$ expressions of type $\tau$. This is caputred by the
(\emph{vec}) rule, which is then used to check individual elements of the context in the
(\emph{df}) rule.

\paragraph{Properties.}

Now consider a target language consisting of the core (ML-subset) defined by the syntax,
reduction rules and typing rules given in Figure~\ref{fig:semantics-target} (Chapter~\ref{ch:semantics})
with primitives inspired by structural indexed comonads defined in Figure~\ref{fig:struct-semantics-ext}
and also concrete notion of comonadically-inspired value and reduction rules for dataflow as
defined in Figure~\ref{fig:structural-ext-df}.

As with the examples discussed in Chapter~\ref{ch:semantics}, the resulting language is type safe.
Together with the well-typedness of the translation (Theorem~\ref{thm:struct-welltyped}), this
guarantees type safety of the structural coeffect calculus for dataflow.
In order to prove type safety, we first extend the \emph{canonical forms lemma}
(Lemma~\ref{thm:semantics-fp-canon}) and the \emph{preservation under substitution lemma}
(Lemma~\ref{thm:semantics-fp-pres-subst}). Those need to consider the new (\emph{df})
and (\emph{prev}) typing rules and substitution under the newly introduced expression forms
$\ident{Df}\langle\ldots\rangle$ and $\ident{prev}_{\cclrd{n}}$. We show that the translation
rule for \kvd{prev} produces well-typed expressions. Finally, we extend the type preservation
(Theorem~\ref{thm:structural-fp-pres}) and progress (Theorem~\ref{thm:structural-fp-prog}) theorems.

\begin{theorem}[Well-typedness of the \kvd{prev} translation]
\label{thm:structural-df-welltyped}
Given a typing derivation for a well-typed closed expression $\coctx{}{\alift{}} \vdash e : \tau$,
the translated program $f$ obtained using the rules in Figure~\ref{fig:struct-translation}
and Figure~\ref{fig:structural-ext-df} is well-typed, \ie~in the target language: $\vdash f : \sem{\coctx{()}{\alift{}}} \rightarrow \sem{\tau}$.
\end{theorem}
\begin{proof}
By rule induction over the derivation of the translation.

\vspace{0.5em}\noindent\hangindent=0.6cm
Case (\emph{var, num, abs, app}): As before.

\vspace{0.5em}\noindent\hangindent=0.6cm
Case (\emph{prev}): Type of $\ctx$ is $\ctyp{\alift{\cclrd{n_0+1},\ldots,\cclrd{n_k+1}}}{(\tau_0\xtimes\ldots\xtimes\tau_k)}$
  and so we can apply the (\emph{prev}) rule to obtain $\ctyp{\alift{\cclrd{n_0},\ldots,\cclrd{n_k}}}{(\tau_0\xtimes\ldots\xtimes\tau_k)}$
  as required by $f$.
\end{proof}

\begin{lemma}[Canonical forms]
\label{thm:structural-df-canon}
For all $e, \tau$, if $\vdash e : \tau$ and $e$ is a value then:
\begin{enumerate}
  \item If $\tau=\ident{num}$ then $e = n$ for some $n \in \mathbb{Z}$
  \item If $\tau=\tau_1 \rightarrow \tau_2$ then $e = \lambda x.e'$ for some $x, e'$
  \item If $\tau=\tau_1\times\ldots\times\tau_n$ then $e = (v_1, \ldots, v_n)$ for some $v_i$
  \item If $\tau=\ctyp{\alift{\cclrd{n_1}, \ldots, \cclrd{n_k}}}{(\tau_1\xtimes\ldots\xtimes\tau_k)}$
    then $e = \ident{Df}\langle \textbf{v}_0, \ldots \textbf{v}_n\rangle$ for some $\textbf{v}_i$
    such that $\textbf{v}_i = \langle v_0, \ldots, v_{n_i}\rangle$.
\end{enumerate}
\end{lemma}
\begin{proof}
  (1,2,3) as before; for (4) the last typing rule must have been (\emph{df}).
\end{proof}

\begin{lemma}[Preservation under substitution]
\label{thm:structural-df-pres-subst}
For all $\Gamma, e, e', \tau, \tau'$, if $\Gamma, x:\tau \vdash e : \tau'$ and $\Gamma \vdash e' : \tau$
then $\Gamma \vdash e[x \leftarrow e'] : \tau$.
\end{lemma}
\begin{proof}
  By induction over the derivation of $\Gamma, x:\tau \vdash e : \tau'$ as before, with new
  cases for $\ident{Df}\langle\ldots\rangle$ and $\ident{prev}_{\aclrd{\textbf{n}}}$.
\end{proof}

\begin{theorem}[Type preservation]
\label{thm:structural-df-pres}
  If $\Gamma \vdash e : \tau$ and $e \rightsquigarrow e'$ then $\Gamma \vdash e' : \tau$
\end{theorem}
\begin{proof}
  Rule induction over $\rightsquigarrow$.

\vspace{0.25em}\noindent\hangindent=0.6cm
Case (\emph{fn}, \emph{prj}, \emph{ctx}): As before, using Lemma~\ref{thm:structural-df-pres-subst} for (\emph{fn}).

\vspace{0.25em}\noindent\hangindent=0.6cm
Case (\emph{counit}): $e = \ident{counit}_{\cclrd{0}}(\ident{Df} \langle\langle v_0 \rangle\rangle)$. The last rule in the type
  derivation of $e$ must have been (\emph{counit}) with $\Gamma \vdash \ident{Df} \langle\lange v_0 \rangle\rangle : \ctyp{\alift{\cclrd{0}}}\tau$
  and therefore $\Gamma \vdash v_0 : \tau$.

\vspace{0.25em}\noindent\hangindent=0.6cm
Case (\emph{cobind}): $e = \ident{cobind}_{\cclrd{m}, \alift{\cclrd{n_1},\ldots,\cclrd{n_k}}}~f~(\ident{Df}\langle \textbf{v}_0, \ldots \textbf{v}_{k} \rangle)$
  such that $\forall i\in\{1\ldots k\}$ $\textbf{v}_i = \langle v_0, \ldots, v_{n_i}\rangle$. The last rule in the type derivation of $e$ must have been
  (\emph{cobind}) with a type $\tau = \ctyp{\alift{\cclrd{m}}}\tau'$ and assumptions:
\begin{itemize}[noitemsep,leftmargin=1.5cm,topsep=0pt]
  \item[--] $\Gamma \vdash f : \ctyp{\alift{\cclrd{n_1},\ldots,\cclrd{n_k}}}{(\tau_1\xtimes\ldots\xtimes\tau_k)} \rightarrow \tau_2$ and
  \item[--] $\Gamma \vdash \ident{Df}\langle \textbf{v}_0, \ldots \textbf{v}_{k} \rangle : \ctyp{\alift{\cclrd{m}+\cclrd{n_1},\ldots,\cclrd{m}+\cclrd{n_k}}}{(\tau_1\xtimes\ldots\xtimes\tau_k)}$
\end{itemize}
%
\hspace{0.5cm} Using the (\emph{df}) rule, the reduced expression has a type $\ctyp{\alift{\cclrd{m}}}\tau'$.

\vspace{0.25em}\noindent\hangindent=0.6cm
Case (\emph{merge}, \emph{split}, \emph{next}): Similar. In all three cases, the last typing rule in the derivation of $e$
  guarantees that the context contains correct number of vectors and each vector contains a
  sufficient number of values of a correct type.
\end{proof}

\begin{theorem}[Progress]
\label{thm:structural-df-prog}
  If $\vdash e : \tau$ then either $e$ is a value or there exists $e'$ such that $e \rightsquigarrow e'$
\end{theorem}
\begin{proof}
  By rule induction over $\vdash$.

\vspace{0.25em}\noindent\hangindent=0.6cm
Case (\emph{num,abs,var,app,proj,tup}): As before, using the adapted canonical forms lemma
  (Lemma~\ref{thm:structural-df-canon}) for (\emph{app}) and (\emph{proj}).

\vspace{0.25em}\noindent\hangindent=0.6cm
Case (\emph{counit}): $e = {\ident{counit}_\cunit}~e_1$. If $e_1$ is not a value, it can be reduced
  using (\emph{ctx}) with context ${\ident{counit}_\cunit}~\_$, otherwise it is a value. From Lemma~\ref{thm:structural-df-canon},
  $e_1 = \ident{Df}\langle\langle v \rangle\rangle$ and so we can apply (\emph{counit}) reduction rule.

\vspace{0.25em}\noindent\hangindent=0.6cm
Case (\emph{cobind}): $e = \ident{cobind}_{\cclrd{m}, \alift{\cclrd{n_1},\ldots,\cclrd{n_k}}}~e_1~e_2$. If $e_1$ is not a value,
  reduce using (\emph{ctx}) with context ${\ident{cobind}_{\cclrd{m},\alift{\cclrd{n_1},\ldots,\cclrd{n_k}}}}~\_~e$. If $e_2$ is
  not a value reduce using (\emph{ctx}) with context ${\ident{cobind}_{\cclrd{m},\alift{\cclrd{n_1},\ldots,\cclrd{n_k}}}}~v~\_$.
  If both are values then we have
  $e_2 = \ident{Df}\langle \langle a_{1,0}, \ldots a_{1,m+{n_1}} \rangle, \ldots, \langle a_{k,0}, \ldots a_{k,m+{n_k}} \rangle \rangle$
  from Lemma~\ref{thm:structural-df-canon} and so we can apply the (\emph{cobind}) reduction.

\vspace{0.25em}\noindent\hangindent=0.6cm
Case (\emph{merge}): $e = \ident{merge}_{\alift{\cclrd{m_0},\ldots,\cclrd{m_k}}, \alift{\cclrd{n_0},\ldots,\cclrd{n_l}}} e_1$. If $e_1$ is not a value,
  reduce using (\emph{ctx}) with context $e = \ident{merge}_{\alift{\cclrd{m_0},\ldots,\cclrd{m_k}}, \alift{\cclrd{n_0},\ldots,\cclrd{n_l}}}~\_$. If $e_1$ is
  a value, it must be a pair of vectors $(\ident{Df}\langle \textbf{v}_0, \ldots, \textbf{v}_k \rangle, \ident{Df}\langle \textbf{v}'_0, \ldots, \textbf{v}'_l\rangle)$
  using Lemma~\ref{thm:structural-df-canon} and it can reduce using (\emph{merge}) reduction.

\vspace{0.25em}\noindent\hangindent=0.6cm
Case (\emph{df}): $e = \ident{Df}\langle \textbf{e}_0, \ldots, \textbf{e}_n\rangle$. If $\textbf{e}_i$ is not a value
  then reduce using (\emph{ctx}) with the context $\ident{Df}\langle \ldots \rangle$.
  Otherwise, $\textbf{e}_0, \ldots, \textbf{e}_n$ are values and so $\ident{Df}\langle \textbf{e}_0, \ldots, \textbf{e}_n\rangle$
  is also a value.

\vspace{0.25em}\noindent\hangindent=0.6cm
Case (\emph{split}, \emph{prev}): Similar. Either sub-expression is not a value, or the type
  guarantees that it is a stream with correct number of elements to enable the (\emph{split})
  or (\emph{prev}) reduction, respectively.
\end{proof}

\begin{theorem}[Safety of context-aware dataflow language]
  If $\Gamma \vdash e : \tau$ and $e \rightsquigarrow^{*} e'$ then either $e'$ is a value of type $\tau$ or
  there exists $e''$ such that $e' \rightsquigarrow e''$ and $\Gamma \vdash e'' : \tau$.
\end{theorem}
\begin{proof}
  Rule induction over $\rightsquigarrow^*$ using Theorem~\ref{thm:structural-df-pres} and Theorem~\ref{thm:structural-df-prog}.
\end{proof}


% ==================================================================================================
%
%     #####
%    #     #  ####  #    #  ####  #      #    #  ####  #  ####  #    #
%    #       #    # ##   # #    # #      #    # #      # #    # ##   #
%    #       #    # # #  # #      #      #    #  ####  # #    # # #  #
%    #       #    # #  # # #      #      #    #      # # #    # #  # #
%    #     # #    # #   ## #    # #      #    # #    # # #    # #   ##
%     #####   ####  #    #  ####  ######  ####   ####  #  ####  #    #
%
% ==================================================================================================


\section{Conclusions}

This chapter completes the key development of this thesis -- the presentation of the coeffect
framework, consisting of two calculi capturing properties of context-aware computations introduced
in Chapter~\ref{ch:applications}. In Chapters~\ref{ch:flat} and \ref{ch:semantics}, we focused on
whole-context properties of computations and we developed \emph{flat coeffect calculus} to capture them.
This chapter develops \emph{structural coeffect calculus}, which captures \emph{per-variable}
contextual properties. The system provides a precise analysis of liveness and dataflow and allows
other interesting uses such as tracking of variable accesses based on bounded linear logic.

Following the structure of the previous two chapters, the structural coeffect calculus is parameterized
by a \emph{structural coeffect algebra}. The two definitions are similar -- both require operations
$\cseq$ and $\cpar$ that model sequential and pointwise composition, respectively. For flat
coeffects, we required $\czip$ to model context merging. For structural coeffects, we
instead use a vector (free monoid) with the $\atimes$ operation -- which serves a similar purpose
as $\czip$. In order to keep track of separate annotations for each variable, we use a system with
explicit structural rules (contraction, weakening and exchange) that manipulate the structure
of variables and the structure of annotations at the same time.

The structural coeffect calculus has desirable equational properties that are satisfied only by
certain flat coeffect calculi. In particular, we show that $\beta$-reduction and $\eta$-expansion
have the typing preservation property for any instance of the structural coeffect calculus. These
two strong properties are desirable for programming languages, but are often not satisfied
(\eg~by languages with effects).

Finally, we discuss the semantics of the structural coeffect calculus in in terms of \emph{structural
indexed comonads}. As in Chapter~\ref{ch:semantics}, we first use the categorical semantics
to unify the different notions of context (bounded reuse, dataflow and liveness) and then use
it as a basis for translation that turns well-typed programs written in the structural coeffect
calculus into well-typed programs of a simple functional language. We give concrete reduction
rules for the target language, modelling \emph{structural dataflow} and prove type safety
of the language.
