\chapter{Flat coeffects} 
\label{ch:flat-coeffects} 

%---------------------------------------------------------------------------------------------------

% comonadic semantics
\newcommand{\iunit}{\mathsf{e}}
\newcommand{\imult}{\oplus}
\newcommand{\iftor}[1]{C^{#1}}
\newcommand{\iftorhat}[1]{\hat{C}^{#1}}

\newcommand{\cosem}[1]{\llbracket #1 \rrbracket}
\newcommand{\interp}[1]{\llbracket #1 \rrbracket}
\newcommand{\ccat}[0]{\mathcal{C}}
\newcommand{\obj}[1]{\textnormal{obj}(#1)}

\newcommand{\cobind}[2]{#1^\dagger_{#2}}
\newcommand{\cmerge}[0]{ \ident{m} }
\newcommand{\csplit}[0]{ \ident{n} }
\newcommand{\counit}[0]{ \varepsilon }
% identity function

% structural coeffect calculus - operation names

%---------------------------------------------------------------------------------------------------

TODO: Change this

Understanding how programs affect their environment is a well studied area: \emph{effect 
systems}~\cite{effects-talpin-et-al} provide a static analysis of effects and 
\emph{monads}~\cite{monad-notions} provide a unified semantics to different notions of effect.  
Wadler and Thiemann unify the two approaches~\cite{monads-effects-marriage}, \emph{indexing}
a monad with effect information, and showing that the propagation of effects in an effect system 
matches the semantic propagation of effects in the monadic approach.

No such unified mechanism exists for tracking the context requirements. We use the term 
\emph{coeffect} for such contextual program properties. 
Notions of context have been previously captured using comonads
\cite{comonads-notions} (the dual of monads) 
and by languages derived from modal logic
\cite{logic-modal-reconstruction,logic-cmtt}, but these approaches
do not capture many useful examples which motivate our work. 
We build mainly on the former comonadic direction (\S\ref{sec:comonads}) and discuss the
modal logic approach later (\S\ref{sec:related}).

We extend a simply typed lambda calculus with a coeffect system based on comonads,
replicating the successful approach of effect systems and monads.

\paragraph{Examples of coeffects.}
We present three examples that do not fit the traditional approach of
\emph{effect systems} and have not been considered using the \emph{modal logic}
perspective, but can be captured as \emph{coeffect systems} (\S\ref{sec:motivation}) --
the tracking of implicit dynamically-scoped parameters (or resources),
analysis of variable liveness, and tracking the
number of required past values in dataflow computations.

\paragraph{Coeffect calculus.}
Informed by the examples, we identify a general algebraic structure for coeffects. 
From this, we define a general \emph{coeffect calculus} that unifies the motivating 
examples (\S\ref{sec:calculus}) and discuss its syntactic properties (\S\ref{sec:syntactic}). 

\paragraph{Indexed comonads.}
Our categorical semantics (\S\ref{sec:comonads}) extends the work of Uustalu and Vene 
\cite{comonads-notions}. By adding annotations, we generalize comonads to \emph{indexed comonads}, 
which capture notions of computation not captured by ordinary comonads.

% ==================================================================================================

\section{Motivation}
\label{sec:motivation}

Effect systems, introduced by Gifford and Lucassen
\cite{effects-gifford}, track \emph{effects} of computations, such as
memory access or message-based
communication~\cite{effects-messagepassing}. Their approach augments
typing judgments with effect information: $\Gamma \vdash e :
\tau, F$.  Wadler and Thiemann explain how this shapes
effect analysis of lambda abstraction~\cite{monads-effects-marriage}:
%
\begin{quote}
\emph{In the rule for abstraction, the effect is empty because evaluation immediately
returns the function, with no side effects. The effect on the function arrow
is the same as the effect for the function body, because applying the function will
have the same side effects as evaluating the body.}
\end{quote}
%
In contrast to the static analysis of \emph{effects}, the analysis of \emph{context-dependence} 
does not match this pattern. In the systems we consider, lambda abstraction places 
requirements on both the \emph{call-site} (latent requirements) and the \emph{declaration-site} 
(immediate requirements), resulting in different syntactic properties. 
We informally discuss three examples first that demonstrate how contextual
requirements propagate. Section (\S\ref{sec:calculus}) then unifies these 
in a single calculus.

We write coeffect judgements $\ctyp{s}{\Gamma} \vdash e : \tau$ where the 
coeffect annotation $s$ associates context requirements with the 
free-variable context $\Gamma$. Function types have the form $\ctyp{s}{\tau_1} \rightarrow \tau_2$ associating
\emph{latent} coeffects $s$ with the parameter.
The $\ctyp{s}{\Gamma}$ syntax and $\ctyp{s}{\tau}$ types are a result of the
indexed comonadic semantics (\S\ref{sec:comonads}).

% --------------------------------------------------------------------------------------------------
\vspace{-1em}
\subsection{Implicit parameters and resources.}
\label{sec:coeffects-res}

Implicit parameters~\cite{app-implicit-parameters} are \emph{dynamically-scoped} variables.
They can be used to parameterize a computation without propagating arguments explicitly through a 
chain of calls and are part of the context in which expressions evaluate. As correctly expected
\cite{app-implicit-parameters}, they can be modelled by comonads. Rebindable resources in distributed
computations follow a similar pattern, but we discuss implicit parameters for simplicity.

The following function prints a number using implicit parameters
\ident{?culture} (determining the decimal mark) and \ident{?format}
(the number of decimal places):
%
\begin{equation*}
\lambda n . \ident{printNumber}~n~\ident{?culture}~\ident{?format}
\end{equation*}
%
Figure~\ref{fig:example-resources} shows a type-and-coeffect system
tracking the set of an expression's implicit parameters. 
For simplicity here, all implicit parameters have type $\rho$.

Context requirements are created in (\emph{access}), while (\emph{var}) requires no
implicit parameters; (\emph{app}) combines requirements of
both sub-expressions as well as the latent requirements of the
function. The (\emph{abs}) rule is where the example differs from
effect systems.  Function bodies can access the union of the
parameters (or resources) available at the declaration-site ($\ctyp{r}{\Gamma}$) and
at the call-site ($\ctyp{s}{\tau_1}$). Two of the nine permissible
judgements for the above example are:
%
\newcommand{\cfebody}{(\ldots)} % \ident{countFutureEvents}
\begin{equation*}
\begin{array}{rcl}
\ctyp{\emptyset}{\Gamma} &\vdash& \cfebody : \ctyp{\{\ident{?culture}, \ident{?format} \}}{\ident{int}} \rightarrow \ident{string}\\
\ctyp{\{\ident{?culture}, \ident{?format}\}}{\Gamma} &\vdash& \cfebody : \ctyp{\{\ident{?format}\}}{\ident{int}} \rightarrow \ident{string}
\end{array}
\end{equation*}
%
The coeffect system infers multiple, \ie{} non-principal, coeffects for functions.
Different judgments are desirable depending on how a function is used. 
In the first case, both parameters have to be provided by the caller.
In the second, both are available at declaration-site, but \ident{?format} may be
rebound (precise meaning is provided by the monoidal structure on the product comonad in \S\ref{sec:comonads}).

Implicit parameters can be captured by the
\emph{reader} monad, where parameters are associated with the function codomain $\mtyp{\emptyset}{(\ident{int} \rightarrow
  \mtyp{\{\ident{?culture}, \ident{?format} \}}{\ident{string}})}$,
modelling only the first case. Whilst the reader monad can be extended to model rebinding, 
the next example cannot be structured by \emph{any} monad.

% --------------------------------------------------------------------------------------------------

\begin{figure}[t]
\vspace{-1.4em}
\begin{equation*}
\inference[(\emph{var})\;]
  {x : \tau \in \Gamma}
  {\ctyp{\emptyset}{\Gamma} \vdash x : \tau }
%
\quad\quad
%
\inference[(\emph{app})\;]
  {\ctyp{r}{\Gamma} \vdash e_1 : \ctyp{t}{\tau_1} \rightarrow \tau_2 &
   \ctyp{s}{\Gamma} \vdash e_2 : \tau_1 }
  {\ctyp{r \cup s \cup t}{\Gamma} \vdash e_1~e_2 : \tau_2}
\end{equation*}
\vspace{-0.7em}
\begin{equation*}
\inference[(\emph{access})\;]
  {}
  {\ctyp{ \{\ident{?a} \} }{\Gamma} \vdash \ident{?a} : \rho }
%
\quad\quad\quad
%
\inference[(\emph{abs})\;]
  {\ctyp{r \cup s}{(\Gamma, x:\tau_1)} \vdash e : \tau_2}
  {\ctyp{r}{\Gamma} \vdash \lambda x.e : \ctyp{s}{\tau_1} \rightarrow \tau_2 }
\end{equation*}
\vspace{-0.9em}
\caption{Selected coeffect rules for implicit parameters}
\label{fig:example-resources}
\vspace{-1em}
\end{figure}

% --------------------------------------------------------------------------------------------------

\begin{figure}[!b]
\vspace{-2em}
\begin{equation*}
\inference[(\emph{var})\;]
  {x : \tau \in \Gamma}
  {\ctyp{\ident L}{\Gamma} \vdash x : \tau }
\quad
\inference[(\emph{app})\;]
  { \ctyp{s}{\Gamma} \vdash e_2 : \tau_1 &
    \ctyp{r}{\Gamma} \vdash e_1 : \ctyp{t}{\tau_1} \rightarrow \tau_2 }
  {\ctyp{r \sqcup (s \sqcap t)}{\Gamma} \vdash e_1~e_2 : \tau_2}
\end{equation*}
\vspace{-1.5em}
\caption{Selected coeffect rules for liveness analysis}
\label{fig:example-need}
\vspace{-1.2em}
\end{figure}

% --------------------------------------------------------------------------------------------------

\vspace{-1em}
\subsection{Liveness analysis.}

Liveness analysis detects whether a free variable of an expression may be used (\emph{live}) or 
whether it is definitely not needed (\emph{dead}). A compiler can remove
bindings to dead variables as the result is never used. 

We start with a restricted analysis and briefly mention how to make it practical
later (\S\ref{sec:related}). The restricted form is interesting theoretically as it gives rise
to the indexed Maybe comonad (\S\ref{sec:comonads}), which is a basic but instructive example.

A coeffect system in Fig.~\ref{fig:example-need} detects whether all variables are dead 
($\ctyp{\ident D}{\Gamma}$) or whether at least one variable is live ($\ctyp{\ident L}{\Gamma}$). 
Variable access (\emph{var}) is annotated with \ident L and constant access with \ident D. That is,
if $c\in\mathbb{N}$ then $\ctyp{\ident D}{\Gamma} \vdash c : \ident{int}$.
A dead context may be marked as live by
letting $\ident D \sqsubseteq \ident L$ and adding sub-coeffecting (\S\ref{sec:calculus}).

The (\emph{app}) rule is best understood by discussing its semantics. Consider first 
\emph{sequential composition} of (semantic) functions $g, f$ annotated with $r, s$. 
The argument of $g \circ f$ is live only when arguments of both $f$ and $g$ are live. 
The coeffect semantics captures the additional behaviour that $f$ is not evaluated when
$g$ ignores its input (regardless of the evaluation order of the underlying language).
We write $r \sqcap s$ for a conjunction (returning \ident L iff $r = s = \ident{L}$). 
Secondly, a \emph{pointwise composition} passes the same
argument to $g$ and $h$. The parameter is live if either the parameter
of $g$ or $h$ is live ($r \sqcup s$). Application combines the
two operations, so the context $\Gamma$ is live if it is needed by
$e_1$ \emph{or} by the function value \emph{and} by $e_2$.

An (\emph{abs}) rule (not shown) compatible with the structure in Fig.~\ref{fig:example-resources}
combines the context annotations using $\sqcap$. Thus, if the body uses some 
variables, both the function argument and the context of the declaration-site are marked as live.

Liveness cannot be modelled using monads as $\tau_1 \rightarrow \mtyp{r}{\tau_2}$.
In call-by-value languages, the argument $\tau_1$ is always evaluated. Using 
indexed comonads (\S\ref{sec:comonads}), we
model liveness as $\ctyp{r}{\tau_1} \rightarrow \tau_2$ where
$\ctyp{r}$ is the parametric type $\mathsf{Maybe}~\tau = \tau + 1$
(which contains a value $\tau$ when $r=\ident{L}$ and does not contain
value when $r=\ident{D}$).

% --------------------------------------------------------------------------------------------------

\begin{figure}[t]
\vspace{-1em}
\begin{equation*}
\inference[(\emph{var})\;]
  {x : \tau \in \Gamma}
  {\ctyp{0}{\Gamma} \vdash x : \tau }
%
\quad\quad
% 
\inference[(\emph{app})\;]
  {\ctyp{m}{\Gamma} \vdash e_1 : \ctyp{p}{\tau_1} \rightarrow \tau_2 &
   \ctyp{n}{\Gamma} \vdash e_2 : \tau_1 }
  {\ctyp{\textit{max}(m, n + p)}{\Gamma} \vdash e_1~e_2 : \tau_2}
\end{equation*}
\begin{equation*}
\inference[(\emph{prev})\;]
  {\ctyp{n}{\Gamma} \vdash e : \tau}
  {\ctyp{n+1}{\Gamma} \vdash \kvd{prev}~e : \tau}
%
\quad\quad
%
\inference[(\emph{abs})\;]
  {\ctyp{\textit{min}(m, n)}{(\Gamma, x:\tau_1)} \vdash e : \tau_2}
  {\ctyp{m}{\Gamma} \vdash \lambda x.e : \ctyp{n}{\tau_1} \rightarrow \tau_2 }
\end{equation*}
\vspace{-1em}
\caption{Selected coeffect rules for causal data flow}
\label{fig:example-dataflow}
\vspace{-1em}
\end{figure}

% --------------------------------------------------------------------------------------------------

\vspace{-1em}
\subsection{Efficient dataflow.}
Dataflow languages (\eg~\cite{app-lucid}) declaratively describe
computations over streams. In \emph{causal} data flow, program may
access past values -- in this setting, a function $\tau_1 \rightarrow
\tau_2$ becomes a function from a list of historical values $[\tau_1]
\rightarrow \tau_2$. A coeffect system here tracks how many past values
to cache.

Figure~\ref{fig:example-dataflow} annotates contexts with an integer specifying the maximum
number of required past values. The current value is always present, so (\emph{var}) is annotated with $0$.
The expression $\kvd{prev}~e$ gets the previous value of stream $e$ and requires one
additional past value (\emph{prev}); \eg~$\kvd{prev}~(\kvd{prev}~e)$ requires 2 past values.

The (\emph{app}) rule follows the same intuition as for liveness. Sequential composition
adds the tags (the first function needs $n + p$ past values to produce $p$ past inputs
for the second function); passing the context to two subcomputations requires the maximum
number of the elements required by the two subcomputations. The (\emph{abs}) rule for data-flow 
needs a distinct operator -- \emph{min} -- therefore, the declaration-site and 
call-site must each provide at least the number of past values required by the function body
(the body may use variables coming from the declaration-site as well as the argument).

The soundness follows from our categorical model (\S\ref{sec:comonads}). Uustalu and Vene
\cite{comonads-notions} model causal dataflow computations using a non-empty list comonad 
$\ident{NeList}~\tau = \tau \times (\ident{NeList}~\tau + 1)$. However, such model leads to
(inefficient) unbounded lists of past elements. The above static analysis provides an
approximation of the number of required past elements and so we use just fixed-length lists.

% ==================================================================================================

\section{Generalized coeffect calculus}
\label{sec:calculus}

The previous three examples exhibit a number of commonalities. We capture these in 
the \emph{coeffect calculus}. We do not overly restrict the calculus to make
it open for notions of context-dependent computations not discussed above.

The syntax of our calculus is that of the simply-typed lambda calculus
(where $v$ ranges over variables, \ident{T} over base types, and $r$ over coeffect annotations):
%
\begin{equation*}
e ::= v \sep \lambda v.e \sep e_1~e_2
\quad\quad\quad\quad
\tau ::= \ident{T} \sep \tau_1 \rightarrow \tau_2 \sep \ctyp{r}{\tau}
\end{equation*}

The type $\ctyp{r}{\tau}$ captures values of type $\tau$ in a context
specified by the annotation  $r$. This type appears only on the
left-hand side of a function arrow $\ctyp{r}{\tau_1} \rightarrow \tau_2$. 
In the semantics, $\ctyp{r}$ corresponds to some data type
(\eg{}~\ident{list} or \ident{Maybe}). Extensions
such as explicit \emph{let}-binding are discussed later
(\S\ref{sec:syntactic}).

The coeffect tags $r$, that were demonstrated in the previous section, can be generalized to a 
structure with three binary operators and a particular element. 

\begin{definition}
A \emph{coeffect algebra} $(S, \imult, \vee, \wedge, \iunit)$ is a set $S$ with
an element $\iunit \in S$, a semi-lattice $(S, \vee)$, a monoid $(S, \imult, \iunit)$,
and a binary $\wedge$. That is, $\forall r,s,t\in S$:
\begin{equation}
\tag{monoid}
   r \imult (s \imult t) = (r \imult s) \imult t 
\quad\quad\quad
   \iunit \imult r = r = r \imult \iunit  \quad\quad
\end{equation}
\vspace{-1.5em}
\begin{equation}
\tag{semi-lattice}
   r \vee s = s \vee r 
\quad\quad
   r \vee (s \vee t) = (r \vee s) \vee t
\quad\quad
   r \vee r = r
\end{equation}
\end{definition}
%
The generalized coeffect calculus captures the three motivating examples (\S\ref{sec:motivation}),
where some operators of the coeffect algebra may coincide. 

The $\imult$ operator represents \emph{sequential} composition; guided by the categorical
model (\S\ref{sec:comonads}), we require it to form a monoid with $\iunit$.
The operator $\vee$ corresponds to merging of context-requirements in \emph{pointwise composition} 
and the semi-lattice $(S, \vee)$ defines a partial order: $r \leq s$ when 
$r \vee s = s$. This ordering implies a sub-coeffecting rule.  
The coeffect $\iunit$ is often the top or bottom of the lattice.

The $\wedge$ operator corresponds to splitting requirements of a function body. 
The operator is unrestricted in the general system.
A number of additional laws holds for \emph{some} coeffects systems, \eg{}~semi-lattice structure of
$\wedge$ and a form of distributivity. Quite possibly, they should hold for all coeffect systems.  
We start with as few laws as possible so as not to limit possible uses of the calculus.  
We consider constrained variants that provide useful syntactic properties later (\S\ref{sec:syntactic}).


\vspace{-0.4em}
\paragraph{Implicit parameters} use sets of names $S = \mathcal{P}(\ident{Id})$ as tags with
union $\cup$ for all three operators. Variable access is annotated with $\iunit = \emptyset$
and $\leq$ is subset ordering.

\vspace{-0.4em}
\paragraph{Liveness} uses a two point lattice $S=\{ \ident{D}, \ident{L} \}$ where
$\ident{D} \sqsubseteq \ident{L}$. Variables are annotated with the top element $e = \ident{L}$ 
and constants with bottom $\ident{D}$. The $\vee$ operation is $\sqcup$ (join) and $\wedge$
and $\imult$ are both $\sqcap$ (meet).

\vspace{-0.4em}
\paragraph{Dataflow} tags are natural numbers $S = \mathbb{N}$ and operations
$\vee, \wedge$ and $\imult$ correspond to \textit{max}, \textit{min} and $+$, respectively. 
Variable access is annotated with $\iunit = 0$ and the order $\leq$ is the standard ordering
of natural numbers.

% --------------------------------------------------------------------------------------------------

\vspace{-1em}
\subsection{Coeffect typing rules.}
Figure~\ref{fig:coeffect-typing} shows the
rules of the coeffect calculus, given some coeffect algebra $(S, \imult, \vee, \wedge, \iunit)$.
The context required by a variable access (\emph{var}) is annotated with $\iunit$.
The sub-coeffecting rule (\emph{sub}) allows the contextual requirements of an expression 
to be generalized.

The (\emph{abs}) rule checks the body of the function in a context $r \wedge s$, which is a 
combination of the coeffects available in the context $r$ where the function is 
defined and in a context provided by the caller of the function. 
Note that none of the judgements create a \emph{value} of type $\ctyp{r}{\tau}$. This
type appears only immediately to the left of  an arrow $\ctyp{r}{\tau_1} \rightarrow \tau_2$.

In function application (\emph{app}), context requirements of both expressions and the 
function are combined as previously: the pointwise composition $\vee$ is used to combine
the coeffects of the expression representing a function $r$ and the coeffects of
the argument, sequentially composed with the coeffects of the function $s \imult t$.

For space reasons, we omit recursion. We note that this would require adding
effect variables and extending the coeffect algebra with a fixed point operation.

% --------------------------------------------------------------------------------------------------

\begin{figure}[t]
\vspace{-1em}
\begin{equation*}
\inference[(\emph{var})\;]
  {x : \tau \in \Gamma}
  {\ctyp{\iunit}{\Gamma} \vdash x : \tau }
%
\quad\quad
%
\inference[(\emph{app})\;]
  {\ctyp{r}{\Gamma} \vdash e_1 : \ctyp{s}{\tau_1} \rightarrow \tau_2 &
   \ctyp{t}{\Gamma} \vdash e_2 : \tau_1 }
  {\ctyp{r \vee (s \imult t)}{\Gamma} \vdash e_1~e_2 : \tau_2}
\end{equation*}
\begin{equation*}
\inference[(\emph{sub})\;]
  {\ctyp{s}{\Gamma} \vdash e : \tau }
  {\ctyp{r}{\Gamma} \vdash e : \tau }
\;(s\leq r)  
%
\quad\quad\quad\quad
%
\inference[(\emph{abs})\;]
  {\ctyp{r \wedge s}{(\Gamma, x:\tau_1)} \vdash e : \tau_2}
  {\ctyp{r}{\Gamma} \vdash \lambda x.e : \ctyp{s}{\tau_1} \rightarrow \tau_2 }
\end{equation*}
\caption{Type and coeffect system for the coeffect calculus}
\label{fig:coeffect-typing}
\vspace{-1em}
\end{figure}

% ==================================================================================================

\section{Coeffect semantics using indexed comonads}
\label{sec:comonads}

The approach of \emph{categorical semantics} interprets terms as
morphisms in some category.  For typed calculi, typing judgments $x_1 : \tau_1 \ldots x_n : \tau_n
\vdash e: \tau$ are usually mapped to morphisms $\interp{\tau_1} \times \ldots \times
\interp{\tau_n} \rightarrow \interp{\tau}$. Moggi showed the semantics of various effectful 
computations can be captured generally using the (\emph{strong}) \emph{monad}
structure~\cite{monad-notions}. Dually, Uustalu and Vene showed that
(\emph{monoidal}) \emph{comonads} capture various kinds of context-dependent 
computation~\cite{comonads-notions}.

We extend Uustalu and Vene's approach to give a semantics for
the coeffect calculus by generalising comonads to
\emph{indexed comonads}. We emphasise semantic intuition and
abbreviate the categorical foundations for space reasons.

\vspace{-1em}
\paragraph{Indexed comonads.}

Uustalu and Vene's approach interprets well-typed terms 
as morphisms $C (\tau_1 \times \ldots
\times \tau_n) \rightarrow \tau$, where $C$ encodes contexts
and has a comonad structure~\cite{comonads-notions}.
Indexed comonads comprise a \emph{family} of object mappings 
$C^r$ indexed by a coeffect $r$ describing the contextual requirements satisfied by
the encoded context. We interpret judgments $C^r (x_1 : \tau_1, \ldots, x_n : \tau_n) \vdash e : \tau$ as
morphisms $C^r (\interp{\tau_1} \times \ldots \times \interp{\tau_n}) \rightarrow \interp{\tau}$.

The indexed comonad structure provides a notion of composition
for computations with different contextual requirements.
%%
\begin{definition}
Given a monoid $(S, \imult, \iunit)$ with binary operator $\imult$ and
unit $\iunit$, an \emph{indexed comonad} over a category $\ccat$
comprises a family of object mappings $\iftor r$ where for all $r \in S$ and $A \in \obj{\ccat}$ then 
$\iftor r A \in \obj{\ccat}$ and:
%%
\begin{itemize}
\item a natural transformation $\counit_A : \iftor{\iunit} A \rightarrow A$, called the \emph{counit};
\item a family of mappings $\cobind{(-)}{r, s}$ from morphisms $\iftor
  r A \rightarrow B$ to \\ morphisms $\iftor{r \imult{} s} A
  \rightarrow \iftor s B$ in $\ccat$, natural in $A,B$, called
  \emph{coextend};
\end{itemize}
%
\noindent
such that for all $f : \iftor r \tau_1 \rightarrow \tau_2$ and $g : \iftor s \tau_2 \rightarrow \tau_3$ 
the following equations hold:
%
\renewcommand{\arraycolsep}{1.5em}
\begin{align*}
\begin{array}{ccc}
\counit \circ \cobind{f}{r, \iunit} = f & 
\cobind{{(\counit)}}{\iunit, r} = \ident{id} & 
\cobind{(g \circ \cobind{f}{r, s})}{(r \imult s), t} = \cobind{g}{s, t} \circ \cobind{f}{r, (s \imult t)} \\
\end{array}
\end{align*}
\end{definition}
%
The \emph{coextend} operation gives rise to an associative composition operation for
computations with contextual requirements (with \emph{counit} as the identity):
%
\[
\hat{\circ} : (\iftor r \tau_1 \rightarrow \tau_2) \rightarrow (\iftor s \tau_2 \rightarrow \tau_3) 
  \rightarrow (\iftor{r \imult s} \tau_1 \rightarrow \tau_3) \quad\quad\quad
g \, \hat{\circ} \, f = g \circ f^\dagger_{r,s}\quad
\]
%
The composition $\hat{\circ}$ best expresses the intention
of indexed comonads: contextual requirements of the composed
functions are combined. The properties of
the composition follow from the indexed comonad laws and the 
monoid $(S, \oplus, \iunit)$.

\paragraph{Example}
Indexed comonad are analogous to comonads (in coKleisli form), but
with the additional monoidal structure on indices.  Indeed, comonads
are a special case of indexed comonads with a trivial singleton
monoid, \eg{}, $(\{1\}, \ast, 1)$ with $1 \ast 1 = 1$ where $\iftor 1$
is the underlying functor of the comonad and $\counit$ and
$\cobind{(-)}{1, 1}$ are the usual comonad operations.
However, as demonstrated next, not all indexed comonads are derived from ordinary comonads.

\paragraph{Example}
The \emph{indexed partiality comonad} encodes free-variable contexts
of a computation which are either \emph{live} or \emph{dead} (\ie{}, have
\emph{liveness} coeffects) with the monoid $(\{\ident{D}, \ident{L}\},
\sqcap, \ident{L})$, where $\iftor{\ident L} A = A$ encodes live
contexts and $\iftor{\ident D} A = 1$ encodes dead contexts,
where $1$ is the unit type inhabited by a single value $()$.
The \emph{counit} operation $\counit{} : \iftor{\ident{L}} A \rightarrow A$
is defined $\counit\ x = x$ and \emph{coextend},
for all $f : \iftor r A \rightarrow B$, and thus
$\cobind{f}{r, s} : \; \iftor{r \sqcap s} A \rightarrow \iftor s B$,
is defined:
%
\begin{align*}
\begin{array}{llll}
\cobind{f}{\ident{D}, \ident{D}} x = () \qquad\qquad & 
\cobind{f}{\ident{D}, \ident{L}} x = f () \qquad\qquad &
\cobind{f}{\ident{L}, \ident{D}} x = () \qquad\qquad &
\cobind{f}{\ident{L}, \ident{L}} x = f~x 
\end{array}
\end{align*}
%
The indexed family $C^r$ here is analogous to the non-indexed \textsf{Maybe} (or \emph{option})
data type $\mathsf{Maybe}\ A = A + 1$.  This
type does not permit a comonad structure since
$\varepsilon : \mathsf{Maybe}\ A \rightarrow A$ is undefined at $(\textsf{inr} \, ())$. 
For the indexed comonad, $\counit$ need only be defined
 for $\iftor{\ident{L}} A = A$. Thus, indexed comonads capture a broader range of
 contextual notions of computation than comonads.

 Moreover, indexed comonads are not restricted by the \emph{shape
   preservation} property of comonads~\cite{orchard12codo}: that
 a coextended function cannot change the \emph{shape} of the
 context. For example, in the second case above $f^\dagger_{\ident{D},
   \ident{L}} : \iftor{\ident{D}} A \rightarrow \iftor{\ident{L}} B$
 where the shape changes from $1$ (empty context) to $B$ (available
 context). 

\vspace{-1em}
\subsection{Monoidal indexed comonads.}
Indexed comonads provide a semantics to sequential composition, but
additional structure is needed for the semantics of the full coeffect calculus.
Uustalu and Vene~\cite{comonads-notions} additionally require a (\emph{lax semi-}) \emph{monoidal comonad} 
structure, which provides a monoidal operation $\mathsf{m} : C A
\times C B \rightarrow C (A \times B)$ for merging contexts (used in
the semantics of abstraction).

The semantics of the coeffect calculus requires an indexed
lax semi-monoidal structure for combining contexts \emph{as well as} an indexed
\emph{colax} monoidal structure for \emph{splitting} contexts. These are provided
by two families of morphisms (given a coeffect algebra with $\vee$ and $\wedge$):
%
\begin{itemize}
\item $\cmerge_{r, s} : \iftor r A \times \iftor s B \rightarrow \iftor{(r \wedge s)}(A \times B)$ natural
in $A, B$;
\item $\csplit_{r, s} : \iftor{(r \vee s)}(A \times B) \rightarrow \iftor r A \times \iftor s B$ natural
in $A, B$;
\end{itemize}
%
\noindent
The $\cmerge_{r, s}$ operation merges contextual computations with
tags combined by $\wedge$ (greatest lower-bound), elucidating 
the behaviour of $\cmerge_{r, s}$: that merging may result in 
the loss of some parts of the contexts $r$ and $s$.

The $\csplit_{r, s}$ operation splits context-dependent computations
and thus the contextual requirements. To obtain coeffects $r$ and
$s$, the input needs to provide \emph{at least} $r$ and $s$, so the
tags are combined using the $\vee$ (least upper-bound).

For the sake of brevity, we elide the indexed versions of the laws required by Uustalu and Vene
(\eg~most importantly, merging two contexts and then adding the third is
equivalent to merging the last two and then adding the first; similar rule holds is required
for splitting).

\paragraph{Example}
For the indexed partiality comonad, given the liveness coeffect
algebra $(\{\ident{D}, \ident{L}\}, \sqcap, \sqcup, \sqcap, \ident{L})$,
the additional lax/colax monoidal operations are:
%%
\begin{align*}
\begin{array}{lll}
\cmerge_{\ident{L}, \ident{L}} (x, y) = (x, y) 
  \quad\quad& \csplit_{\ident{D}, \ident{D}} \;\; () \;\;\; = ((), ())
  \quad\quad& \csplit_{\ident{D}, \ident{L}} (x, y) = ((), y) \\
\cmerge_{\ident{r}, \ident{s}} \;\,(x, y) = () 
  & \csplit_{\ident{L}, \ident{D}} (x, y) = (x, ())
  & \csplit_{\ident{L}, \ident{L}} (x, y) = (x, y)
\end{array}
\end{align*}

\paragraph{Example}
Uustalu and Vene model causal dataflow computations using the
non-empty list comonad $\ident{NEList}~A = A \times (1 +
\ident{NEList}~A)$~\cite{comonads-notions}.  Whilst this comonad
implies a trivial indexed comonad, we define an indexed comonad with
integer indices for the number of past values demanded of the context.

We define $\ctyp{n}{A} = A \times (A \times \ldots \times A)$ where the first $A$ is the current
(always available) value, followed by a finite product of $n$ past values. The definition of the
operations is a straightforward extension of the work of Uustalu and Vene.

%\begin{example}
%The semantics of the coeffect calculus for
% dynamically-scoped implicit parameters, with coeffect
%algebra $(\mathcal{P}(\ident{Id}), \cup, \cup, \cup, \emptyset)$, 
%is provided by the indexed comonad $\iftor rA = A \times (r \rightarrow \tau)$
%where $r \in \mathcal{P}(\ident{Id})$ with operations:\dnote{The type here is wrong,
%do we need to store the types too? Maybe should just be a product.}
%%
%\vspace{-1.0em}
%\begin{equation*}
%\begin{array}{l}
%\cobind{f}{r, s} \; : \; \iftor{r \cup s} A \rightarrow \iftor s B\\
%\cobind{f}{r, s} (a, g) = (f(a, g|_r), g|_s)
%\\[1em]
%\counit{} (a, g) = a\\
%%\iota_{r, s} \; : \: \iftor r A \rightarrow \iftor s A\\
%\iota_{r, s}(a, g) = (a, g|_s)\quad(\textnormal{if}~\leq r)
%\end{array}
%\quad\begin{array}{l}
%\cmerge_{r, s} : \iftor r A \times \iftor s B \rightarrow \iftor{(r \cup s)}(A \times B)\\
%\cmerge_{r, s} ((a_1, g_1), (a_2, g_2)) = ((a_1, a_2), g_1|_{r \setminus s} \cup g_2 )
%\\[1em]
%\csplit_{r, s} : \iftor{(r \cup s)}(A \times B) \rightarrow \iftor r A \times \iftor s B \\
%\csplit_{r, s} ((a_1, a_2), g) = ((a_1, g|_r), (a_1, g|_s))
%\end{array}
%\end{equation*}
%\end{example}

%The function created using \emph{coextend} expects a function $g$ that is defined for
%resource names $r \cup s$. We use function restriction $g|_r$ and $g|_s$ to get functions that are 
%defined on resources required by $f$ and the result of coextend, respectively.

%The operation $\cmerge_{r, s}$ pairs the values and combines the resources available in both contexts. 
%It combines a function $g_1|_{r\setminus s}$ (defined for resources in $r$ excluding those in $s$) and 
%function $g_2$ (defined for resources $s$). This definition is not symmetric as it prefers resources 
%defined in the second context. As a result, the caller of a function can rebind resources defined
%at the declaration site. 

%Resources show that indexed comonads describe the structure of context more precisely
%than comonads. A comonad would have to use $TA = A \times (\Omega \rightharpoonup R)$ 
%with a \emph{partial} function on all resource names. Using indexed comonads, we can ensure that the function
%is defined on all resources tracked statically in the tag.\dnote{Needs tweaking}

\vspace{-1.5em}
\subsection{Categorical Semantics. }
\label{sec:comonads-semantics}

\newcommand{\llangle}{\langle\hspace{-0.25em}\langle}
\newcommand{\rrangle}{\rangle\hspace{-0.25em}\rangle}

\begin{figure*}[t]
\vspace{-1em}
\newcommand{\uu}[1]{\overline{#1}}
% \begin{equation*} 
% \cosem{\ctyp{r}{(x_1 : \tau_1 \times \ldots \times x_n : \tau_n)} \vdash e : \tau} : 
%   \ctyp{r}{(\tau_1 \times \ldots \times \tau_n)} \rightarrow \tau
% \end{equation*}
% \vspace{-0.4em}
\begin{equation*}
\begin{array}{rcll}
\cosem{\ctyp{r}{\Gamma} \vdash \lambda x.e : \ctyp{s}{\tau_1} \rightarrow \tau_2} &=& 
    \emph{curry} \; (\cosem{\ctyp{r \wedge s}{(\Gamma, x:\tau_1)} \vdash e : \tau_2} \circ \cmerge_{r, s})    %&$(1)$
\\[0.1em]
\cosem{\ctyp{r \vee (s \imult t)}{\Gamma} \vdash e_1~e_2 : \tau} &=& 
    (\emph{uncurry} \;  \cosem{\ctyp{r}{\Gamma} \vdash e_1 : \ctyp{s}{\tau_1} \rightarrow \tau_2}) \, \circ \\
 & & \quad\; (id \times \cobind{\cosem{\ctyp{t}{\Gamma}\vdash e_2 : \tau_1}}{t,s})
    \circ \csplit_{r, s \imult t} \circ \iftor{r \vee (s \imult t)}\Delta
\\[0.1em]
\cosem{\ctyp{\iunit}{\Gamma} \vdash x_i : \tau_i} &=&
    \pi_i \circ \counit                                                                  % &$(3)$
%\\[0.1em]
%\cosem{\ctyp{r}{\Gamma} \vdash e : \tau} &=&
%    \cosem{\ctyp{s}{\Gamma} \vdash e : \tau} \circ \iota_{r, s}                              %   &%$(4)$
%\\[0.1em]
%\cosem{\ctyp{r\vee (r \imult s)}{\Gamma} \vdash \kvd{let}~x=e_1~\kvd{in}~e_2 : \tau_2} &=&
%    \cosem{\ctyp{r}{(\Gamma, x:\tau_1)} \vdash e_2 : \tau_2} \circ
% ((\varepsilon \times \cosem{ \ctyp{s}{\Gamma} \vdash e_1 : \tau_1 }) \circ 
%\iftorhat{r \vee (r \imult t)}\Delta
\end{array}
\end{equation*}
\vspace{-1.5em}
\caption{Categorical semantics for the coeffect calculus}
\label{fig:semantics}
\vspace{-1.0em}
\end{figure*}

Figure~\ref{fig:semantics} shows the
categorical semantics of the coeffect calculus
using additional operations 
$\pi_i$ for projection of the \emph{i}$^{th}$ element of a 
product, usual
\emph{curry} and \emph{uncurry} operations, and
 $\Delta : A \rightarrow A \times A$ duplicating a
value. While $\iftor{r}$ is a family of object mappings,
it is promoted to a family of functors with the derived morphism mapping 
$\iftor{r}(f) = \cobind{ (f \circ \counit) }{\iunit, r}$.

The semantics of variable access and abstraction are the same as in
Uustalu and Vene's semantics, modulo coeffects. Abstraction uses $\cmerge_{r, s}$ to merge the outer
context with the argument context for the context of the function body.
The indices of $\iunit$ for
$\counit$ and $r,s$ for $\cmerge_{r, s}$ match the coeffects
of the terms.
The semantics of application is more complex. It first duplicates the
free-variable values inside the context and then splits this context
using $\csplit_{r, {s \oplus t}}$. The two contexts (with
different coeffects) are passed to the two sub-expressions,
where the argument subexpression, passed a context $(s \oplus t)$,
is coextended to produce a context $s$ which is passed into
the parameter of the function subexpression (\emph{cf.} given $f : A \rightarrow (B \rightarrow C)$,
 $g : A \rightarrow B$, then $\emph{uncurry} \, f \, \circ \, (id \times g) \circ \Delta : A \rightarrow C$).

A semantics for sub-coeffecting is omitted, but may be provided
by an operation 
$\iota_{r, s} : \iftor r A \rightarrow \iftor s A$ natural in $A$, for all $r, s \in S$ where $s \leq r$,
which transforms a value $C^r A$ to $C^s A$ by
ignoring some of the encoded context.

% ==========================================================================================

\section{Syntax-based equational theory}
\label{sec:syntactic}

Operational semantics of every context-dependent language differs as the notion of context 
is always different. However, for coeffect calculi satisfying certain conditions we can 
define a universal equational theory. This suggests a pathway to an operational semantics for 
two out of our three examples (the notion of context for data-flow is more complex).

In a pure $\lambda$-calculus, $\beta$ and $\eta$ equality for
functions (also called \emph{local soundness} and \emph{completeness}
respectively~\cite{logic-modal-reconstruction})
describe how pairs of abstraction and application can be eliminated:
$(\lambda x . e_2) e_1 \equiv_\beta \subst{e_1}{x}{e_2}$ and $(\lambda x . e \, x) 
\equiv_\eta e$. The $\beta$ equality rule, using the usual Barendregt convention of 
syntactic substitution, implies a \emph{reduction},
giving part of an operational semantics for the calculus.

The call-by-name evaluation strategy modelled by $\beta$-reduction is
not suitable for impure calculi therefore a restricted $\beta$ rule,
corresponding to call-by-value, is used, \ie~$(\lambda x . e_2) v
\equiv \subst{e_2}{x}{v}$. Such reduction can be encoded by a
\emph{let}-binding term, $\kvd{let}~x=e_1~\kvd{in}~e_2$, which
corresponds to sequential composition of two computations, where the
resulting pure value of $e_1$ is substituted into
$e_2$~\cite{monads-inaction,monad-notions}.

%
% We consider here both a notion of \emph{let}-binding for the coeffect
% calculus, useful for a CBV evaluation, and a notion of substitution 
% for a CBV evaluation.
% 

For an equational theory of coeffects, consider first a notion 
of \emph{let}-binding equivalent to $(\lambda x . e_2)~e_1$, which
has the following type and coeffect rule:
%
\begin{equation}
\inference
  {\ctyp{s}{\Gamma} \vdash e_1 : \tau_1 &
   \ctyp{r_1 \wedge r_2}{(\Gamma, x : \tau_1)} \vdash e_2 : \tau_2}
  {\ctyp{r_1 \vee (r_2 \imult s)}{\Gamma} \vdash \kvd{let}~x = e_1~\kvd{in}~e_2
: \tau_2 }
\label{eq:let1}
\end{equation}

\noindent
For our examples, $\wedge$ is idempotent (\ie{}, $r \wedge r = r$)
implying a simpler rule:

% For the three examples we consider, a simpler rule gives a more
% precise coeffect. Because $r \wedge r = r$ for all our examples, we
% can also a coeffect $r \vee (r \imult s)$. Moreover,
%for our examples (but not necessarily for \emph{all} coeffect
%systems), $r \vee (r \imult s) \leq r_1 \vee (r_2 \imult s)$ meaning
%that the following gives more precise coeffects:
%
\begin{equation}
\inference
  {\ctyp{s}{\Gamma} \vdash e_1 : \tau_1 &
   \ctyp{r}{(\Gamma, x : \tau_1)} \vdash e_2 : \tau_2}
  {\ctyp{r \vee (r \imult s)}{\Gamma} \vdash \kvd{let}~x = e_1~\kvd{in}~e_2 : \tau_2 }
\label{eq:let2}
\end{equation}
%%
For our examples (but not necessarily \emph{all} coeffect
systems), this defines a more ``precise'' coeffect with respect to $\leq$
where $r \vee (r \imult s) \leq r_1 \vee (r_2 \imult s)$.

This rule removes the non-principality of the first rule
(\ie~multiple possible typings).  However, using idempotency 
to split coeffects in abstraction would remove additional
flexibility needed by the implicit parameters example.

The coeffect $r \vee (r \imult s)$ can
also be simplified for all our examples, leading to more intuitive
rules -- for implicit parameters $r \cup (r \cup s) = r \cup s$; for
liveness we get that $r \sqcup (r \sqcap s) = r$ and for dataflow we
obtain $\textit{max}(r, r+s) = r + s$.

Our calculus can be extended with \emph{let}-binding and \eqref{eq:let2}.
However, we also consider the cases when a
syntactic substitution $e_2[x \leftarrow e_1]$ has the coeffects
specified by the above rule \eqref{eq:let2} 
and prove \emph{subject reduction} theorem
for certain coeffect calculi.  We consider two common special cases
when the coeffect of variables $\iunit$ is the greatest ($\top$) or
least ($\bot$) element of the semi-lattice $(S, \vee)$ and derive
additional conditions that have to hold about the coeffect algebra:

\begin{lemma}[Substitution]
\label{thm:subst}
Given $C^r (\Gamma, x : \tau_2) \vdash e_1 : \tau_1$ and $C^s \Gamma \vdash e_2 : \tau_2$
then $C^{r \vee (r \oplus s)} \Gamma \vdash \subst{e_2}{x}{e_1} : \tau_1$ if 
the coeffect algebra satisfies the conditions that 
$\iunit$ is either the greatest or least element of the semi-lattice,
$\oplus = \wedge$, and $\oplus$ distributes over $\vee$,
\ie{}, $X \oplus (Y \vee Z) = (X \oplus Y) \vee (X \oplus Z)$.
\end{lemma}

\begin{proof}
By induction over $\vdash$, using the laws (\S\ref{sec:calculus}) and additional assumptions.
\end{proof}

Assuming $\rightarrow_\beta$ is the usual call-by-name reduction, the
following theorem models the evaluation of coeffect calculi with
coeffect algebra that satisfies the above requirements. We do not
consider \emph{call-by-value}, because our calculus does not have a
notion of \emph{value}, unless explicitly provided by
\emph{let}-binding (even a function ``value'' $\lambda x.e$ may have
immediate contextual requirements).

\begin{theorem}[Subject reduction]
\label{thm:reduction}
For a coeffect calculus, satisfying the conditions of Lemma~\ref{thm:subst}, if
$\ctyp{r}{\Gamma} \vdash e : \tau$ and $e \rightarrow_\beta e'$ then 
$\ctyp{r}{\Gamma} \vdash e' : \tau$.
\end{theorem}
\begin{proof}
A direct consequence of Lemma~\ref{thm:subst}. 
\end{proof}

The above theorem holds for both the liveness and resources examples,
but not for dataflow.  In the case of liveness, $\iunit$ is the
greatest element ($r \vee \iunit = \iunit$); in the case of
resources, $\iunit$ is the \emph{least} element ($r \vee \iunit =
r$) and the proof relies on the fact that additional
context-requirements can be placed at the context $\ctyp{r}{\Gamma}$
(without affecting the type of function when substituted under
$\lambda$ abstraction).

However, the coeffect calculus also captures context-dependence in
languages with more complex evaluation strategies than
\emph{call-by-name} reduction based on syntactic substitution.  In
particular, syntactic substitution does not provide a suitable evaluation
for dataflow (because a substituted expression needs to capture the
context of the original scope).

Nevertheless, the above results show that -- unlike effects --
context-dependent properties can be integrated with
\emph{call-by-name} languages. Our work also provides a model of
existing work, namely Haskell implicit parameters
\cite{app-implicit-parameters}.

% ==================================================================================================

\section{Related and further work}
\label{sec:related}

This paper follows the approaches of effect systems \cite{effects-gifford,effects-talpin-et-al,monads-effects-marriage}
and categorical semantics based on monads and comonads \cite{monad-notions,comonads-notions}. Syntactically,
\emph{coeffects} differ from \emph{effects} in that they model systems where $\lambda$-abstraction 
may split contextual requirements between the declaration-site and call-site.

Our \emph{indexed (monoidal) comonads} (\S\ref{sec:comonads}) fill the gap between (non-indexed)
\emph{(monoidal) comonads} of Uustalu and Vene \cite{comonads-notions}
and indexed monads of Atkey~\cite{monads-parameterised-notions}, Wadler and Thiemann
\cite{monads-effects-marriage}. Interestingly, \emph{indexed} comonads are \emph{more
general} than comonads, capturing more notions of context-dependence (\S\ref{sec:motivation}).

% --------------------------------------------------------------------------------------------------

\vspace{-1em}
\paragraph{Comonads and modal logics.}

Bierman and de Paiva \cite{logic-intuitionistic-modal} model the
$\square$ modality of an intuitionistic S4 modal logic using monoidal
comonads, which links our calculus to modal logics.  This link can be
materialized in two ways.

Pfenning et al. and Nanevski et al.  derive term languages using the Curry-Howard
correspondence~\cite{logic-modal-reconstruction,logic-intuitionistic-modal,logic-cmtt},
building a \emph{metalanguage} (akin to Moggi's monadic metalanguage
\cite{monad-notions}) that includes $\square$ as a type
constructor. For example, in \cite{logic-modal-reconstruction}, the
modal type $\Box \tau$ represents closed terms.
In contrast, the \emph{semantic} approach uses monads or comonads
\emph{only} as a semantics.  This has been employed by Uustalu and
Vene and (again) Moggi \cite{monad-notions,comonads-notions}.  We
follow the semantic approach.

Nanevski et al. extend an S4 term language to a \emph{contextual}
modal type theory (CMTT)~\cite{logic-cmtt}.
The \emph{context} is a set of variables required by a computation, which
makes CMTT useful for meta-programming and staged computations. Our contextual types are
indexed by a coeffect algebra, which is more general and can capture
variable contexts, but also integers, two-point lattices, \emph{etc.}.

The work on CMTT suggests two extensions to coeffects. The first is
developing the logical foundations. We briefly considered special cases
of our system that permits local soundness in \S\ref{sec:syntactic} and
local completeness can be treated similarly. The second problem is 
developing the coeffects \emph{metalanguage}. The use of coeffect algebras
would provide an additional flexibility over CMTT, allowing a wider range 
of applications.

% --------------------------------------------------------------------------------------------------

\vspace{-1em}
\paragraph{Relating effects and coeffects.} 
The difference between effects and coeffects is mainly in the (\emph{abs}) rule. While the 
semantic model (monads vs. comonads) is very different, we can consider extending the two to 
obtain equivalent syntactic rules. To allow splitting of implicit parameters in lambda abstraction, 
the reader monad needs an operation that eagerly performs some effects of a function: 
$(\tau_1 \rightarrow \mtyp{r \oplus s}{\tau_2}) \rightarrow \mtyp{r}{(\tau_1 \rightarrow \mtyp{s}{\tau_2})}$.
To obtain a pure lambda abstraction
for coeffects, we need to restrict the $\cmerge_{r, s}$ 
operation of indexed comonads, so that the first parameter is annotated with $\iunit$ (meaning
no effects): $\iftor \iunit A \times \iftor r B \rightarrow \iftor{r}(A \times B)$.

\vspace{-1em}
\paragraph{Structural coeffects.} To make the liveness analysis practical, we need to associate
information with individual variables (rather than the entire context). We can generalize the 
calculus from this paper by adding a product operation $\times$ to the coeffect algebra.
A variable context $x:\tau_1, y:\tau_2, z:\tau_3$ is then annotated with
$r\times s \times t$ where each component of the tag corresponds to a single variable. The system
then needs to be extended with structural rules such as:
%
\begin{equation*}
\inference[(\emph{abs})]
  {\ctyp{r \cprd s}{(\Gamma, x:\tau_1)} \vdash e : \tau_2}
  {\ctyp{r}{\Gamma} \vdash \lambda x.e : \ctyp{s}{\tau_1} \rightarrow \tau_2 }
\quad
\inference[(\emph{contr})]
  {\ctyp{r \cprd s}{(x:\tau_1, y:\tau_1)} \vdash e : \tau_2}
  {\ctyp{r \cvop s }{(z:\tau_1)} \vdash \subst{\subst{e}{x}{z}}{y}{z} : \tau_2 }
\end{equation*}
%
The context-requirements associated with function are exactly those linked to the specific
variable of the lambda abstraction. Rules such as contraction manipulate variables and perform
a corresponding operation on the indices.

The structural coeffect system is related to bunched typing \cite{types-bunched} (but generalizes
it by adding indices). We are currently investigating how to use structural coeffects to capture 
fine-grained context-dependence properties such as secure information flow \cite{app-secure-flow}
or, more generally, those captured by dependency core calculus \cite{types-dcc}.

% ==================================================================================================

\section{Conclusions}

We examined three simple calculi with associated
static analyses (liveness analysis, implicit parameters, and dataflow
analysis). These were unified in the \emph{coeffect calculus},
providing a general coeffect system parameterised by an
algebraic structure describing the propagation of context
requirements throughout a program.

We model the semantics of coeffect calculus using \emph{indexed comonad} -- a novel structure, which
is more powerful than (monoidal) comonads. Indices of the indexed comonad operations manifest the 
semantic propagation of context such that the propagation of information in the general coeffect
type system corresponds exactly to the semantic propagation of context in our categorical model.

We consider the analysis of context to be essential, not least for the examples here but 
also given increasingly rich and diverse distributed systems.
