%!TEX root = ../main.tex

\chapter{Structural coeffect calculus} 
\label{ch:structural}

As already discussed, the aim of this thesis is to identify abstractions for context-aware
programming languages. We attempt to find abstractions that are general enough to capture a wide
range of useful programming language features, but specific enough to let us identify
interesting properties of the languages.

In Chapter~\ref{ch:applications}, we identified two notions of context. We generalized the 
class of flat calculi that capture whole-context properties in Chapter~\ref{ch:flat}. 
In this chapter, we turn our attention to \emph{structural} coeffect calculi that capture
per-variable properties.

The flat coeffect system captures interesting use-cases (implicit parameters, liveness and
data-flow), but provides relatively weak properties. We can define its categorical semantics,
but the equational theory proofs had numerous additional requirements. For this reason, it
is worthwhile to consider structural systems in a separate chapter. We will see that 
structural coeffects have a number of desirable properties that hold for all instances of the
calculus.



% ==================================================================================================
%                                                                                      
%     ###           #                       #                 #       #                 
%      #            #                       #                 #                         
%      #    # ##   ####   # ##    ###    ## #  #   #   ###   ####    ##     ###   # ##  
%      #    ##  #   #     ##  #  #   #  #  ##  #   #  #   #   #       #    #   #  ##  # 
%      #    #   #   #     #      #   #  #   #  #   #  #       #       #    #   #  #   # 
%      #    #   #   #  #  #      #   #  #  ##  #  ##  #   #   #  #    #    #   #  #   # 
%     ###   #   #    ##   #       ###    ## #   ## #   ###     ##    ###    ###   #   # 
%                                                                                     
% ==================================================================================================

\section{Introduction}
\label{sec:structural-intro}

Two examples of flat systems from the previous chapter were liveness and data-flow. As discussed
in \ref{sec:applications-structural}, these are interesting for theoretical reasons. However, tracking
liveness of the whole context is not practically useful. Structural versions of liveness and 
data-flow let us track more fine-grained properties. Moreover, the equational theory of flat 
coeffect calculus did not reveal many useful properties for flat liveness and data-flow. 
As we show in this chapter, this is not the case with structural versions.

In this chapter, we focus on three example applications. We look at structural liveness and
data-flow and we also consider calculus for bounded reuse, which checks how many times a variable
is accessed and generalizes linear logics (that restrict variables to be used exactly once).

%---------------------------------------------------------------------------------------------------

\subsection{Contributions}

Compared to the previous chapter, the structural coeffect calculi we consider are more 
homogeneous and so finding the common pattern is in some ways easier. However, the systems
are somewhat more complicated as they need to keep annotations attached to individual variables. 
The contributions of this chapter are as follows:

\begin{itemize}
\item We present a \emph{structural coeffect calculus} with a type system that is parameterized by a 
  \emph{structural coeffect algebra} and can be instantiated to obtain all of the three examples
  discussed (Section~\ref{sec:struct-calculus}).
  
\item We give the equational theory of the calculus. We prove the type-preservation property 
  for all structural calculi for both call-by-name and call-by-value (Section~\ref{sec:struct-syntax}). 
  
\item We show how to extend indexed comonads introduced in the previous section to 
  \emph{structural indexed comonads} and use them to give the semantics of structural 
  coeffect calculus (Section~\ref{sec:struct-semantics}). As with the flat version, the
  categorical semantics provides a motivation for the design of the calculus.
\end{itemize}

%---------------------------------------------------------------------------------------------------

\subsection{Related work}

In the previous chapter, we discussed the correspondence between coeffects and effects (and 
between comonads and monads). As noted earlier, the $\lambda$-calculus is assymetric in that
an expression has multiple inputs (variables in the context), but just a single result 
(the resulting value) and so monads and effects have no notion directly corresponding to 
structural coeffect systems.

The work in this chapter is more closely related to sub-structural type systems \cite{substruct-attpl-intro}.
While sub-structural systems remove some or all of \emph{weakening}, \emph{contraction} and
\emph{exchange} rules, our systems keep them, but use them to manipulate both the context
and its annotations.

Our work follows the language semantics style in that we provide a structural semantics to
the terms of ordinary $\lambda$-calculus. The most closely related work has been done in the
meta-langauge style, which extends the terms and types with constructs working with the context
explicitly. This includes Contextual Modal Type Theory (CMTT) \cite{logic-cmtt}, where variables
may be of a type $A[\Psi]$ denoting a value of type $A$ that requires context $\Psi$. In CMTT, 
$A[\Psi]$ is a first-class type, while structural coeffect systems do not expose coeffect 
annotations as stand-alone types.

Structural coeffect systems annotate the whole variable context with a \emph{vector} of annotations.
For example, a context with variables $x$ and $y$ annotated with $\cclrd{s}$ and $\cclrd{t}$, 
respectively is written as $\coctx{x\!:\!\tau_1,y\!:\!\tau_2}{\alift{\cclrd{s},\cclrd{t}}}$.
This means that the typing judgements have the same structure as those of the flat coeffect
calculus. As discussed in Chapter~\ref{ch:unified}, this makes it possible to unify the two 
systems and compose tracking of flat and structural properties.



% =================================================================================================
%                                                            
%       ###           ##                   ##                 
%      #   #           #                    #                 
%      #       ###     #     ###   #   #    #    #   #   ###  
%      #          #    #    #   #  #   #    #    #   #  #     
%      #       ####    #    #      #   #    #    #   #   ###  
%      #   #  #   #    #    #   #  #  ##    #    #  ##      # 
%       ###    ####   ###    ###    ## #   ###    ## #  ####  
%                                                           
% =================================================================================================

\section{Structural coeffect calculus}
\label{sec:struct-calculus}

In the structural coeffect calculus, a vector of variables in the free-variable context is 
annotated with a vector of primitive (scalar) coeffect annotations. These annotations differ
for different coeffect calculi and their properties are captured by the \emph{structural 
coeffect scalar} definition below. The scalar annotations can be integers (how many past values we 
need) or annotations specifying whether a variable is live or not.

Scalar annotations are written as $\cclrd{r}, \cclrd{s}, \cclrd{t}$ (following the style used in 
the previous chapter). Functions always have exactly one input variable and so they are annotated
with a coeffect scalar. Thus the expressions and types of structural coeffect calculi are the same
as in the previous chapter (except that annotation on function type is now a structural coeffect 
scalar):
%
\begin{equation*}
\begin{array}{rcl}
e &::=& x \sep \lambda x.e \sep e_1~e_2 \sep \kvd{let}~x = e_1~\kvd{in}~e_2\\
\tau &::=& T \sep \tau_1 \xrightarrow{\cclrd{r}} \tau_2
\end{array}
\end{equation*}
%
In the previous chapter, the free variable context $\Gamma$ has been treated as a set. In the 
structural coeffect calculus, the order of variables matters. Thus we treat free variable context
as a vector with a uniqueness condition. We also write $\xlen{-}$ for the length
of the vector:
%
\begin{equation*}
\begin{array}{rcl}
 \Gamma &\narrow{=}& \langle x_1\!:\tau_1, \ldots, x_n\!:\!\tau_n \rangle \qquad \textnormal{such that}~~\forall i, j ~.~ i \neq j \implies x_i \neq x_j\\
 \xlen{\Gamma} &\narrow{=}& n
\end{array}
\end{equation*}
%
For readability, we use the usual notation $x_1\!:\!\tau_1, \ldots, x_1\!:\!\tau_1 \vdash e : \tau$ for
typing judgements, but the free variable context should be understood as a vector.
Furthermore, the usual notation $\Gamma_1, \Gamma_2$ stands for the tensor product.
Given $\Gamma_1 = \langle x_1\!:\tau_1, \ldots, x_n\!:\!\tau_n \rangle $ and
$\Gamma_2 = \langle x_{n+1}\!:\tau_{n+1}, \ldots, x_m\!:\!\tau_m \rangle $ then
$\Gamma_1, \Gamma_2 = \Gamma_1 \times \Gamma_2 = \langle x_1\!:\tau_1, \ldots, x_m\!:\!\tau_m \rangle$.

The free variable contexts are annotated with vectors of structural coeffect scalars. In what follows,
we write the vectors of coeffects as $\alift{\cclrd{r_1}, \ldots, \cclrd{r_n}}$. Meta-variables ranging 
over vectors are written as $\aclrd{\textbf{r}}, \aclrd{\textbf{s}}, \aclrd{\textbf{t}}$ (using bold face 
and colour to distinguish them from scalar meta-variables) and the length of a coeffect vector
is written as $\alen{\aclrd{\textbf{r}}}$. The structure for working with vectors
of coeffects is provided by the \emph{structural coeffect algebra} definition below. 

% -------------------------------------------------------------------------------------------------

\subsection{Structural coeffect algebra}

The structural coeffect scalar structure is similar to \emph{flat coeffect algebra} with the 
exception that it drops the $\czip$ operation. It only provides a monoid $(\C, \cseq, \cunit)$
modelling sequential composition of computations and a monoid $(\C, \cpar, \czero)$ representing
pointwise composition, as well as a relation $\cleq$ that defines sub-coeffecting.

\begin{definition}
\label{def:structural-scalar}
A \emph{\cclrd{structural coeffect scalar}} $(\C, \cseq, \cpar, \cunit, \czero, \cleq)$ is a set 
$\C$ together with elements $\cunit, \czero \in \C$, relation $\cleq$ and binary operations 
$\cseq, \cpar$ such that $(\C, \cseq, \cunit)$ and $(\C, \cpar, \czero)$ are monoids and
$(\C, \cleq)$ is a pre-order. That is, for all $r,s,t\in \C$:
%
\begin{equation*}
\begin{array}{ccr}
r \;\cseq\; (s \;\cseq\; t) = (r \;\cseq\; s) \;\cseq\; t  &
\cunit \;\cseq\; r = r = r \;\cseq\; \cunit &
\textnormal{(monoid)}   
\\
r \;\cpar\; (s \;\cpar\; t) = (r \;\cpar\; s) \;\cpar\; t &
\czero \;\cpar\; r = r = r \;\cpar\; \czero &
\textnormal{(monoid)}   
\\
\textnormal{if}~~r\; \cleq\; s ~~\textnormal{and}~~s\; \cleq\; t~~\textnormal{then}~~r\; \cleq\; t&
t\; \cleq\; t &
\textnormal{(pre-order)}   
\end{array}
\end{equation*}
%
In addition, the following distributivity axioms hold:
\begin{align*}
\quad (\cclrd{r}\, \cpar\, \cclrd{s}) \;\cseq\; \cclrd{t} & = (\cclrd{r} \,\cseq\, \cclrd{t}) \;\cpar\; (\cclrd{s}\, \cseq\, \cclrd{t}) \\
\quad \cclrd{t} \;\cseq\; (\cclrd{r}\, \cpar\, \cclrd{s}) & = (\cclrd{t} \,\cseq\, \cclrd{r}) \;\cpar\; (\cclrd{t}\, \cseq\, \cclrd{s})
\end{align*}
\end{definition}

\noindent
In the flat coeffect calculus, we used the $\czip$ operation to merge the annotations of contexts
available from the declaration-site and the call-site or, in the syntactic reading, to split the 
context requirements.

In the structural coeffect calculus, we use a vector instead -- combining and splitting of 
coeffects becomes just vector a concatenation or splitting, respectively, which is provided
by the tensor product. The operations on vectors are indexed by integers representing the lengths
of the vectors. The additional structure required by the type system for structural coeffect 
calculi is given by the following definition.

\begin{definition}
A \emph{\aclrd{structural coeffect algebra}} is formed by a structural coeffect scalar 
$(\C, \cseq, \cpar, \cunit, \czero, \cleq)$ equipped with the following additional structures:

\begin{itemize}
\item Coeffect vectors $\aclrd{\textbf{r}}, \aclrd{\textbf{s}}, \aclrd{\textbf{t}}$, ranging over
  structural coeffect scalars indexed by vector lengths $\sclrd{m}, \sclrd{n} \in \sclrd{\mathbb{N}}$.

\item An operation that constructs a vector from scalars indexed by the vector length
  $\alift{-}_{\sclrd{n}} : \C \times \ldots \times \C \rightarrow \C^{\sclrd{n}}$
  and an operation that returns the vector length such that 
  $\alen{\aclrd{\textbf{r}}} = \sclrd{n}$ for $\aclrd{\textbf{r}} : \C^{\sclrd{n}}$

\item A pointwise extension of the $\cseq$ operator written as $\cclrd{t} \,\aseq\, \aclrd{\textbf{s}}$
  such that\\ $\cclrd{t} \,\aseq\, \alift{\cclrd{r_1}, \ldots, \cclrd{r_n}} = 
    \alift{\cclrd{t} \,\cseq\,\cclrd{r_1}, \ldots, \cclrd{t} \,\cseq\,\cclrd{r_n}}$.

\item An indexed tensor product $\atimes_{\sclrd{n},\sclrd{m}} : \C^{\sclrd{n}} \times \C^{\sclrd{m}} \rightarrow \C^{\sclrd{n}+\sclrd{m}}$
  that is used in both directions -- for vector concatenation and for splitting -- 
  which is defined as $\alift{\cclrd{r_1}, \ldots, \cclrd{r_n}} 
     \atimes_{\sclrd{n}, \sclrd{m}} \alift{\cclrd{s_1}, \ldots, \cclrd{s_m}}
   = \alift{\cclrd{r_1}, \ldots, \cclrd{r_n}, \cclrd{s_1}, \ldots, \cclrd{s_m}}$
\end{itemize}
\end{definition}

\noindent
The fact that the tensor product $\atimes_{\sclrd{n},\sclrd{m}}$ is indexed by the lengths
of the two vectors means that we can use it unambiguously for both concatenation of vectors
and for splitting of vectors, provided that the lengths of the resulting vectors are known.
In the following text, we usually omit the indices and write just 
$\aclrd{\textbf{r}} \atimes \aclrd{\textbf{s}}$, because the lengths of the coeffect vectors 
can be determined from the lengths of the matching free variable context vectors.

More generally, we could see the the coeffect annotations as a \emph{container} 
\cite{types-containers} that supports certain operations. This approach is used in 
Chapter~\ref{ch:unified} as a way of unifying the flat and structural systems. 

% -------------------------------------------------------------------------------------------------

\subsection{Structural coeffect types}
\label{sec:struct-calculus-types}

The type system for structural coeffect calculus is similar to sub-structural type systems
in how it handles free variable contexts. The \emph{syntax-driven} rules do not implicitly allow
weakening, exchange or contraction -- this is done by checking the types of sub-expressions
in disjoint parts of the free variable context. Unlike in sub-structural logics, our system
allows weakening, exchange and contraction, but using explicit \emph{structural} rules that
perform corresponding transformation on the coeffect annoation.

\paragraph{Syntax-driven rules.}
The variable access rule (\emph{var}) annotates the corresponding variable as being used
using $\cunit$. Note that, as in sub-structural systems, the free variable context contains 
\emph{only} the accessed variable. Other variables can be introduced using explicit weakening.
Constants (\emph{const}) are type checked in an empty variable context, which is annotated with
an empty vector of coeffect annotations.

The (\emph{abs}) rule assumes that the free variable context of the body can be split into
a potentially empty \emph{declaration site} and a singleton context containing the bound
variable. The corresponding splitting is performed on the coeffect vector, uniquely associating
the annotation $\cclrd{s}$ with the bound variable $x$. This means that the typing rule removes
non-determinism present in flat coeffect systems.

In (\emph{app}), the sub-expressions $e_1$ and $e_2$ use free variable contexts $\Gamma_1, \Gamma_2$
with coeffect vectors $\aclrd{\textbf{r}}, \aclrd{\textbf{s}}$, respectively. The function
value is annotated with a coeffect scalar $\cclrd{t}$.
The coeffect annotation of the composed expression is obtained by combining the annotations
associated with variables in $\Gamma_1$ and $\Gamma_2$. Variables in $\Gamma_1$ are only
used to obtain the function value, resulting in coeffects $\aclrd{\textbf{r}}$. The 
variables in $\Gamma_2$ are used to obtain the argument value, which is then sequentially
composed with the function, resulting in $\cclrd{t}\,\aseq\,\aclrd{\textbf{s}}$.

\paragraph{Structural rules.}
The remaining rules, shown in Figure~\ref{fig:struct-types} (b), are not syntax-directed.
They allow different transformation of the free variable context. We include sub-coeffecting
(\emph{sub}) as one of the rules, allowing sub-coeffecting on coeffect scalars belonging
to individual variables. The remaining rules capture \emph{weakening}, \emph{exchange} and
\emph{contraction} known from sub-structural systems.

The (\emph{weak}) allows adding a variable to the context, extending the coeffect
vector with $\czero$ to mark it as unused, (\emph{exch}) provides a way to rearrange variables
in the context, performing the same reordering on the coeffect vector. Finally recall that 
variables in the free variable context are required to be \emph{unique}. The (\emph{contr}) rule 
allows re-using a variable as we can type check sub-expressions using two separate varaibles and 
then unify them using substitution. The resulting variable is annotated with $\cpar$ and it
is the only place in the structural coeffect system where context requiremens are combined,
or semantically, where the same context is shared.

%---------------------------------------------------------------------------------------------------

\begin{figure}[t]
{\small a.) Syntax-driven typing rules:}
\begin{equation*}
\tyrule{var}
  { }
  {\coctx{x\!:\!\tau}{\alift{\cunit}} \vdash x : \tau }
\end{equation*}
\begin{equation*}
\tyrule{const}
  {c \!:\! \tau \in \Delta}
  {\coctx{()}{\alift{}} \vdash c : \tau }
\end{equation*}
\begin{equation*}
\tyrule{app}
  {\coctx{\Gamma_1}{\aclrd{\textbf{r}}} \vdash e_1 : \tau_1 \xrightarrow{\cclrd{t}} \tau_2 &
   \coctx{\Gamma_2}{\aclrd{\textbf{s}}} \vdash e_2 : \tau_1 }
  {\coctx{\Gamma_1, \Gamma_2}{\aclrd{\textbf{r}\;\atimes\;(\cclrd{t} \,\aseq\, \aclrd{\textbf{s}})}} \vdash e_1~e_2 : \tau_2}
\end{equation*}
\begin{equation*}
\tyrule{abs}
  {\coctx{\Gamma, x\!:\!\tau_1}{\aclrd{\textbf{r}}\,\atimes\,\alift{\cclrd{s}}} \vdash e : \tau_2}
  {\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash \lambda x.e : \tau_1 \xrightarrow{\cclrd{s}} \tau_2 }
\end{equation*}
\begin{equation*}
\tyrule{let}
  { \coctx{\Gamma_1}{\aclrd{\textbf{r}}} \vdash e_1 : \tau_1 &
    \coctx{\Gamma_2, x\!:\!\tau_1}{\aclrd{\textbf{s}}\;\atimes\;\alift{\cclrd{t}}} \vdash e_2 : \tau_2}
  {\coctx{\Gamma_1, \Gamma_2}{(\cclrd{t} \,\aseq\, \aclrd{\textbf{r}}) \;\atimes\; \aclrd{\textbf{s}}} \vdash \kvd{let}~x=e_1~\kvd{in}~e_2 : \tau_2 }
\end{equation*}

\vspace{1em}
{\small b.) Structural rules for context manipulation:}
\begin{equation*}
\tyrule{sub}
  {\coctx{\Gamma_1,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} \atimes \alift{\cclrd{s'}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}
  {\coctx{\Gamma_1,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} \atimes \alift{\cclrd{s}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}
\quad
(\cclrd{s'} \cleq \cclrd{s})
\end{equation*}
\begin{equation*}
\tyrule{weak}
  {\coctx{\Gamma}{ \aclrd{\textbf{r}} } \vdash e : \tau}
  {\coctx{\Gamma,x \!:\! \tau_1}{\aclrd{\textbf{r}} \atimes \alift{ \czero }} \vdash e : \tau} 
\end{equation*}
\begin{equation*}
\tyrule{exch}
  {\coctx{\Gamma_1,x\!:\!\tau_1,y\!:\!\tau_2,\Gamma_2}{\aclrd{\textbf{r}} \atimes \alift{\cclrd{s},\cclrd{t}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}
  {\coctx{\Gamma_1,y\!:\!\tau_2,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} \atimes \alift{\cclrd{t},\cclrd{s}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}
\quad
\begin{array}{l}
 \xlen{\Gamma_1} = \alen{\aclrd{\textbf{r}}}\\[-0.25em]
 \xlen{\Gamma_2} = \alen{\aclrd{\textbf{s}}}
\end{array}
\end{equation*}
\begin{equation*}
\hspace{2.5em} 
\tyrule{contr}
  {\coctx{\Gamma_1,y\!:\!\tau_1,z\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} \atimes \alift{\cclrd{s},\cclrd{t}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}
  {\coctx{\Gamma_1,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} \atimes \alift{\cclrd{s} \,\cpar\, \cclrd{t}} \atimes \aclrd{\textbf{q}}} \vdash \subst{e}{z,y}{x} : \tau}
~
\begin{array}{l}
 \xlen{\Gamma_1} = \alen{\aclrd{\textbf{r}}}\\[-0.25em]
 \xlen{\Gamma_2} = \alen{\aclrd{\textbf{s}}}
\end{array}
\end{equation*}

\caption{Type system for the structural coeffect calculus}
\label{fig:struct-types}
\end{figure}

%---------------------------------------------------------------------------------------------------

\subsection{Understanding structural coeffects}

The type system for structural coeffects appears more complicated when compared to the flat
version, but it is in many ways simpler -- it removes the ambiguity arising from the use
of $\czip$ in lambda abstraction and, as discussed in Section~\ref{sec:struct-syntax}, has
a cleaner equational theory.

\paragraph{Flat and structural context.} In flat systems, lambda abstraction splits context
requirements using $\czip$ and application combines them using $\cpar$. In the structural
version, both of these are replaced with $\atimes$. The $\czip$ operation is not needed, but
$\cpar$ is still used in the (\emph{contr}) rule.

This suggests that $\czip$ and $\cpar$ serve two roles in flat coeffects. First, they are used
as over- and under-approximations of $\atimes$. This is demonstrated by the (\emph{approximation})
requirement introduced in Section~\ref{sec:flat-syntax-cbv}, which requires that
$\cclrd{r}\,\czip\,\cclrd{t}\;\cleq\;\cclrd{r}\,\cpar\,\cclrd{t}$. Semantically, flat abstraction
combines available context, potentially discarding parts of it (under-approximation), while flat
application splits available context, potentially duplicating parts of it (over-approxi\-mation)\footnote{
Because of this duality, earlier version of coeffects in \cite{coeffects-icalp13}
used $\wedge$ and $\vee$.}.

Second, the operator $\cpar$ is used when the semantics passes the same context to multiple
sub-expressions. In flat systems, this happens in (\emph{app}) and (\emph{pair}), because the 
sub-expressions may share variables. In structural systems, this is separated into an 
explicit contraction rule.

\paragraph{Let binding.}
The other aspect that makes structural systems simpler is that they remove the need for 
separate let binding. As discussed in Section~\ref{sec:flat-calculus-let}, flat calculi include
let binding that gives a \emph{more precise} typing than combination of abstraction and 
application. This is not the case for structural coeffects.

\begin{remark}[Let binding]
\label{thm:structural-letbinding}
In a structural coeffect calculus, the typing of $(\lambda x.e_2)~e_1$ is equivalent
to the typing of $\kvd{let}~x=e_1~\kvd{in}~e_2$.
\end{remark}
\begin{proof}
Consider the following typing derivation for $(\lambda x.e_2)~e_1$. Note that 
in the last step, we apply (\emph{exch}) repeatedly to swap $\Gamma_1$ and $\Gamma_2$. 
%
\begin{equation*}
\inference
  { \begin{array}{l}\coctx{\Gamma_1}{\aclrd{\textbf{r}}} \vdash e_1 : \tau_1\vspace{-1.6em}\end{array} &
    \inference
      { \coctx{\Gamma_2, x\!:\!\tau_1}{\aclrd{\textbf{s}}\;\atimes\;\alift{\cclrd{t}}} \vdash e_2 : \tau_2 }
      { \coctx{\Gamma_2}{\aclrd{\textbf{s}}} \vdash \lambda x.e_2 : \tau_1 \xrightarrow{\cclrd{t}} \tau_2} \vspace{0.2em} }
  { \inference
      { \coctx{\Gamma_2, \Gamma_1}{\aclrd{\textbf{s}} \;\atimes\; (\cclrd{t} \,\aseq\, \aclrd{\textbf{r}})} \vdash (\lambda x.e_2)~e_1 : \tau_2 }
      { \coctx{\Gamma_1, \Gamma_2}{(\cclrd{t} \,\aseq\, \aclrd{\textbf{r}}) \;\atimes\;  \aclrd{\textbf{s}} } \vdash (\lambda x.e_2)~e_1 : \tau_2 } }
\end{equation*}

\noindent
The assumptions and conclusions match those of the (\emph{let}) rule. 
\end{proof}


%---------------------------------------------------------------------------------------------------

\subsection{Examples of structural coeffects}

The structural coeffect calculus can be instantiated to obtain the structural coeffect calculi
presented in Section~\ref{sec:applications-structural}. Two of them -- structural data-flow and
structural liveness provide a more precise tracking of properties that can be tracked using 
flat systems. Formally, a flat coeffect algebra can be turned into a structural coeffect algebra
(by dropping the $\czip$ operator), but this does not always give us a meaningful system -- for
example, it is not clear why one would associate implicit parameters with individual variables.

On the other hand, some of the structural systems do not have a flat equivalent, typically 
because there is no appropriate $\czip$ operator that could be added to form the flat coeffect
algebra. This is the case, for example, for the bounded variable use.

\begin{example}[Structural liveness]
The structural coeffect algebra for liveness is formed by
$(\mathcal{L}, \sqcap, \sqcup, \ident{L}, \ident{D}, \sqsubseteq)$, where $\mathcal{L}=\{ \ident{L}, \ident{D} \}$ is 
the same two-point lattice as in the flat version, that is $\ident{D} \sqsubseteq \ident{L}$
with a join $\sqcup$ and meet $\sqcap$. 
\end{example}

\begin{example}[Structural data-flow]
In data-flow, context is annotated with natural numbers and the flat coeffect algebra is formed 
by $(\mathbb{N}, +, \mathit{max}, 0, 0, \leq)$.
\end{example}

\noindent
For the two examples that have both flat and structural version, obtaining the strucutral coeffect
algebra is easy. As shown by the examples above, we simply omit the $\czip$ operation. The laws
required by a structural coeffect algebra are the same as those required by the flat version
and so the above definitions are both valid. Similar construction can be used for the
\emph{optimized data-flow} example from Section~\ref{sec:flat-calculus-examples}.

It is important to note that this gives us a systems with \emph{different} properties. The 
information are now tracked per-variable rather than for the enitre context. For data-flow,
we also need to adapt the typing rule for the \kvd{prev} construct. Here, we write $\aclrd{+}$ 
for a pointwise extension of the $+$ operator, such that
$\alift{\cclrd{r_1}, \ldots, \cclrd{r_n}} + k = \alift{\cclrd{r_1} + k, \ldots, \cclrd{r_n} + k}$.
%
\begin{equation*}
\tyrule{prev}
  { \coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e : \tau }
  { \coctx{\Gamma}{\aclrd{\textbf{r}} \,\aclrd{+}\, 1} \vdash \kvd{prev}~e : \tau }
\end{equation*}
%
The rule appears similar to the flat one, but there is an important difference. Because of the
structural nature of the type system, it only increments the required number of values for 
variables that are used in the expression $e$. Annotations of other variables can be left 
unchanged. 

Before looking at the semantics and equational properties of structural coeffect systems, 
we consider bounded variable use, which is an example of structural system that does not
have a flat counterpart.

\begin{example}[Bounded variable reuse]
The structural coeffect algebra for tracking bounded variable use is given by
$(\mathbb{N}, \ast, +, 1, 0, \leq)$
\end{example}

\noindent
Similarly to the structural calculus for data-flow, the calculus for bounded variable reuse
annotates each variable with an integer. However, the integer denotes how many times is the variable 
\emph{accessed} rather than how many \emph{past values} are needed. The resulting type system is 
the one shown in Figure~\ref{fig:applications-struct-live} in Chapter~\ref{ch:applications}.

% ==================================================================================================
%                                              
%      #####  #                                 
%        #    #                                 
%        #    # ##    ###    ###   # ##   #   # 
%        #    ##  #  #   #  #   #  ##  #  #   # 
%        #    #   #  #####  #   #  #      #  ## 
%        #    #   #  #      #   #  #       ## # 
%        #    #   #   ###    ###   #          # 
%                                         #   # 
%                                          ###                                                                         
% ==================================================================================================

\section{Categorical motivation}
\label{sec:struct-semantics}

When introducing structural coeffect systems in Section~\ref{sec:applications-structural}, we 
included a concrete semantics of structural liveness and bounded variable reuse. In this section,
we generalize the examples using the notion of \emph{structural indexed comonad}, which is an 
extension of \emph{indexed comonad} structure. As in the previous chapter, the main aim of this 
section is to motivate and explain the design of the structural coeffect calculus shown in 
Section~\ref{sec:struct-calculus}. The semantics highlights the similarities and differences 
between the two systems.

Most of the differences between flat and structural systems arise from the fact that contexts
in structural coeffect systems are treated as \emph{vectors} rather than sets modelled using 
categorical products, so we start by discussing our treatment of vectors.

% --------------------------------------------------------------------------------------------------

\subsection{Semantics of vectors}

In the flat coeffect calculus, the context is interpreted as a product and so a typing judgement
$\coctx{x_1\!:\tau_1, \ldots, x_n:\tau_n}{\cclrd{r}} \vdash e : \tau$ is interpreted as a morphism 
$\ctyp{\cclrd{r}}{(\tau_1 \times \ldots \times \tau_n)} \rightarrow \tau$. In this model, we can 
freely transform the value contained in the context modelled using an indexed comonad
$\ctyp{\cclrd{r}}$. For example, the function $\ident{map}_{\cclrd{r}}~\pi_i$ transforms
a context $\ctyp{\cclrd{r}}{(\tau_1 \times \ldots \times \tau_n)}$ into a value 
$\ctyp{\cclrd{r}}{\tau_i}$. This changes the carried value without affecting the coeffect $\cclrd{r}$.

The ability to freely transform the variable structure is not desirable in the model of 
structural coeffect systems. Our aim is to guarantee (by construction) that the structure of
the coeffect annotations matches the structure of variables. To achieve this, we model vectors
using a structure distinct from ordinary products which we denote $-\xtimes-$. 
For example, the judgement $\coctx{x_1\!:\tau_1, \ldots, x_n:\tau_n}{\alift{\cclrd{r_1},\ldots,\cclrd{r_n}}} \vdash e : \tau$
is modelled as a morphism $\ctyp{\alift{\cclrd{r_1},\ldots,\cclrd{r_n}}}{(\tau_1 \xtimes \ldots \xtimes \tau_n)} \rightarrow \tau$.

The operator is a bifunctor, but it is \emph{not} a product in the categorical sense. In particular, 
there is no way to turn $\tau_1 \xtimes \ldots \xtimes \tau_n$ into $\tau_i$ (the structure does 
not have projections) and so there is also no way of turning
$\ctyp{\alift{\cclrd{r_1},\ldots,\cclrd{r_n}}}{(\tau_1 \xtimes \ldots \xtimes \tau_n)}$ into
$\ctyp{\alift{\cclrd{r_1},\ldots,\cclrd{r_n}}}{\tau_i}$, which would break the correspondence 
between coeffect annotations and variable structure.

The structure created using $-\xtimes-$ can be manipulated only using operations provided by
the \emph{strucutral indexed comonad}, which operate over variable contexts contained in an 
indexed comonad $\ctyp{\aclrd{\textbf{r}}}$.

In what follows, we model (finite) vectors of length $n$ as $\tau_1 \xtimes \ldots \xtimes \tau_n$.
We assume that the use of the operator can be freely re-associated. If an operation requires an 
input in the form $(\tau_1 \xtimes \ldots \xtimes \tau_i) \xtimes (\tau_{i+1} \xtimes \ldots \xtimes \tau_n)$,
we call it with $(\tau_1 \xtimes \ldots \xtimes \tau_n)$ as an argument and assume that the 
appropriate transformation is inserted.

% --------------------------------------------------------------------------------------------------

\subsection{Indexed comonads, revisited}

The semantics of structural coeffect calculus reuses the definition of \emph{indexed comonad} almost
without a change. The additional structure that is required for context manipulation (merging and 
splitting) is different and is provided by the \emph{structural indexed comonad} structure that we
introduce in this section.

Recall the definition from Section~\ref{sec:flat-semantics-idx}, which defines an indexed comonad 
over a monoid $(\C, \cseq, \cunit)$ as a triple $(\ctyp{\cclrd{r}{}}, \ident{counit}_{\cunit}, 
\ident{cobind}_{\cclrd{r}, \cclrd{s}})$. The triple consists of a family of object mappings $\ctyp{\cclrd{r}{}}$,
and two mappings that involve context-dependent morphisms of the form $\ctyp{\cclrd{r}} \tau \rightarrow \tau'$.

In the structural coeffect calculus, we work with morphisms of the form $\ctyp{\cclrd{r}} \tau \rightarrow \tau'$
representing function values (appearing in the language), but also of the form
$\ctyp{\alift{\cclrd{r_1},\ldots,\cclrd{r_n}}}{(\tau_1 \xtimes \ldots \xtimes \tau_n)} \rightarrow \tau$, 
modelling expressions in a context. To capture this, we need to generalize some of the indices from
\emph{coeffect scalars} $\cclrd{r}, \cclrd{s}, \cclrd{t}$ to \emph{coeffect vectors} $\aclrd{r}, \aclrd{s}, \aclrd{t}$.

\begin{definition}
Given a monoid $(\C, \cseq, \cunit)$ with a pointwise extension of the $\cseq$ operator to a vector 
(written as $\cclrd{t}\,\aseq\,\aclrd{\textbf{s}}$) and an operation lifting scalars to vectors 
$\alift{-}$, an \emph{indexed comonad} over a category $\catc$ is a triple 
$(\ctyp{\cclrd{r}{}}, \ident{counit}_{\cunit}, \ident{cobind}_{\cclrd{s}, \aclrd{\textbf{r}}})$:

\begin{compactitem}
\item $\ctyp{\aclrd{\textbf{r}}}{}$ for all $\aclrd{\textbf{r}} \in \bigcup_{\sclrd{m}\in \sclrd{\mathbb{N}}} \C^{\sclrd{m}}$ is a family of object mappings 
\item $\ident{counit}_{\cunit}$ is a mapping $\ctyp{\alift{\cunit}}{\alpha} \rightarrow \alpha$ 
\item $\ident{cobind}_{\cclrd{s}, \aclrd{\textbf{r}}}$ is a mapping $(\ctyp{\aclrd{\textbf{r}}}{\alpha} \rightarrow \beta) 
  \rightarrow (\ctyp{\cclrd{s}\aseq\aclrd{\textbf{r}}}{\alpha} \rightarrow \ctyp{\alift{\cclrd{s}}}{\beta})$
\end{compactitem}
\end{definition}

\noindent
The object mapping $\ctyp{\aclrd{\textbf{r}}}$ is now indexed by a vector rather than by a scalar 
$\ctyp{\cclrd{r}}$ as in the previous chapter. This new definition supersedes the old one, because a 
flat coeffect annotation can be seen as singleton vectors.

The operation $\ident{counit}_{\cunit}$ operates on a singleton-vector. This means that it will always
return a single variable value rather than a vector created using $-\xtimes-$. The $\ident{cobind}_{\cclrd{s}, \aclrd{\textbf{r}}}$
operation is, perhaps surprisingly, indexed by a coeffect vector and a coeffect scalar. This assymmetry
is explained by the fact that the input function ($\ctyp{\aclrd{\textbf{r}}}{\alpha} \rightarrow \beta$)
takes a vector of variables, but always produces just a single value. Thus the resulting function 
also takes a vector of variables, but always returns a context with singleton variable vector.
In other words, $\alpha$ may contain $\xtimes$, but $\beta$ may not, because the coeffect calculus has
no way of constructing values containing $\xtimes$.

% --------------------------------------------------------------------------------------------------

\subsection{Structural indexed comonads}

The flat indexed comonad structure extends indexed comonads with operations 
$\ident{merge}_{\cclrd{r},\cclrd{s}}$ and $\ident{split}_{\cclrd{r},\cclrd{s}}$ 
that combine or split the additional (flat) context and are annotated with the flat 
coeffect operations $\czip$ and $\cpar$, respectively. In the structural version, we use
corresponding operations that operate on variable vectors represented using $\xtimes$ and
are annotated with a tensor $\atimes$ which mirrors the variable structure.

The following definition also includes $\ident{lift}_{\cclrd{r'},\cclrd{r}}$, which is similar as
before and models sub-coeffecting and also $\ident{dup}_{\cclrd{r}, \cclrd{s}}$ which models
duplication of a variable in a context needed for the semantics of contraction:

\begin{definition}
Given a structural coeffect algebra formed by $(\C, \cseq, \cpar, \cunit, \czero, \cleq)$
with operations $\alift{-}$ and $\aseq$, a \emph{structural indexed comonad} is an indexed comonad over 
the monoid $(\C, \cseq, \cunit)$ equipped with families of operations $\ident{merge}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}$, 
$\ident{split}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}$,
$\ident{dup}_{\cclrd{r}, \cclrd{s}}$ and $\ident{lift}_{\cclrd{r'},\cclrd{r}}$ where:
%
\begin{compactitem}
\item $\ident{merge}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}$ is a family of mappings
  $\ctyp{\aclrd{\textbf{r}}}{\alpha} \times \ctyp{\aclrd{\textbf{s}}}{\beta} \rightarrow \ctyp{\aclrd{\textbf{r}}\atimes\aclrd{\textbf{s}}}{(\alpha \xtimes \beta)}$
\item $\ident{split}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}$ is a family of mappings
  $\ctyp{\aclrd{\textbf{r}}\atimes\aclrd{\textbf{s}}}{(\alpha \xtimes \beta)} \rightarrow \ctyp{\aclrd{\textbf{r}}}{\alpha} \times \ctyp{\aclrd{\textbf{s}}}{\beta}$
\item $\ident{dup}_{\cclrd{r}, \cclrd{s}}$ is a family of mappings
  $\ctyp{\alift{\cclrd{r} \cpar \cclrd{s}}}{\alpha} \rightarrow \ctyp{\alift{\cclrd{r}, \cclrd{s}}}{(\alpha \xtimes \alpha)}$
\item $\ident{lift}_{\cclrd{r'},\cclrd{r}}$ is a family of mappings
  $\ctyp{\alift{\cclrd{r'}}}{\alpha} \rightarrow \ctyp{\alift{\cclrd{r}}}{\alpha}$~ for all $\cclrd{r'}, \cclrd{r}$ such that $\cclrd{r}\,\cleq\,\cclrd{r'}$
\end{compactitem}
%
Such that the following equalities hold:
\begin{equation*}
\begin{array}{l}
  \ident{merge}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}} \circ \ident{split}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}} \equiv \ident{id} \\
  \ident{split}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}} \circ \ident{merge}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}} \equiv \ident{id} 
\end{array}
\end{equation*}

\end{definition}

\noindent
The operations differ from those of the flat indexed comonad in that the \ident{merge} and 
\ident{split} operations are required to be inverse functions and to preserve the additional 
information about the context. This was not required for the flat system where the operations
could under- or over-approximate. Note that the operations use $\xtimes$ to combine or
split the contained values. This means that they operate on free-variable vectors rather than 
on ordinary products.

The \ident{dup} mapping is a new operation that was not required for a flat calculus. It 
takes a variable context with a single variable annotated with $\cclrd{r}\cpar\cclrd{s}$,
duplicates the value of the variable $\alpha$ and splits the additional context between the two
new variables. In flat calculus, this operation has been expressed using ordinary tuple 
construction, which is not possible here -- the returned context needs to contain a 
two-element vector $\alpha \xtimes \alpha$.

Finally, the \ident{lift} mapping is almost the same as in the flat version. It
operates on a singleton vector, which is equivalent to operating on a scalar as before.
The operation could easily be extended to a vector in a pointwise way, but we keep it simple
and perform sub-coeffecting separately on individual variables.

% --------------------------------------------------------------------------------------------------

\begin{figure*}[!t]
\begin{equation*}
\begin{array}{ll}
 \sem{\coctx{x\!:\!\tau}{\alift{\cunit}} \vdash x : \tau }~\ctx =
   \ident{counit}_{\cunit}~\ctx & (\emph{var})
\\[0.5em]
\sem{\coctx{\Gamma}{\czero} \vdash c_i : \tau }~\ctx =
  \delta~(c_i) & (\emph{const})
\\[0.5em]
\sem{\coctx{\Gamma_1, \Gamma_2}{\aclrd{\textbf{r}\;\atimes\;(\cclrd{t} \,\aseq\, \aclrd{\textbf{s}})}} \vdash e_1~e_2 : \tau_2}~\ctx = & (\emph{app})\\[-0.25em]
  \hspace{2.5em}
  \begin{array}{l}  
  \kvd{let}~(\ctx_1, \ctx_2) = \ident{split}_{\aclrd{\textbf{r}}, \cclrd{t} \,\aseq\, \aclrd{\textbf{s}}}~\ctx\\[-0.25em]
  \kvd{in}~\sem{\coctx{\Gamma_1}{\aclrd{\textbf{r}}} \vdash e_1 : \tau_1 \xrightarrow{\cclrd{t}} \tau_2}~\ctx_1~
      (\ident{cobind}_{\cclrd{t}, \aclrd{\textbf{s}}}~\sem{\coctx{\Gamma_2}{\aclrd{\textbf{s}}} \vdash e_2 : \tau_1 }~\ctx_2)
  \end{array}
\\[1.5em]
\sem{\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash \lambda x.e : \tau_1 \xrightarrow{\cclrd{s}} \tau_2 }~\ctx = \lambda v.& (\emph{abs})\\[-0.25em]
\hspace{2em}\sem{\coctx{\Gamma, x\!:\!\tau_1}{\aclrd{\textbf{r}}\,\atimes\,\alift{\cclrd{s}}} \vdash e : \tau_2}
  ~(\ident{merge}_{\aclrd{\textbf{r}}, \alift{\cclrd{s}}}~(\ctx, v))
\\[0.5em]
\sem{\coctx{\Gamma,x \!:\! \tau_1}{\aclrd{\textbf{r}} \atimes \alift{ \czero }} \vdash e : \tau}~\ctx = & (\emph{weak}) \\
  \hspace{2em}
  \kvd{let}~(\ctx_1, \_) = \ident{split}_{\aclrd{\textbf{r}}, \alift{\czero}}~\ctx~~\kvd{in}~~
  \sem{\coctx{\Gamma}{ \aclrd{\textbf{r}} } \vdash e : \tau}~\ctx_1
\\[0.5em]
\sem{\coctx{\Gamma_1,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} \atimes \alift{\cclrd{s}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}~\ctx = & (\emph{sub})\\
  \hspace{2em}
  \sem{\coctx{\Gamma_1,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} \atimes \alift{\cclrd{s'}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}~
  (\ident{nest}_{\aclrd{\textbf{r}}, \alift{\cclrd{s}}, \alift{\cclrd{s'}}, \aclrd{\textbf{q}}}~\ident{lift}_{\cclrd{s}, \cclrd{s'}}~\ctx)
\\[0.5em]
\sem{\coctx{\Gamma_1,y\!:\!\tau_2,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} 
        \atimes \alift{\cclrd{t},\cclrd{s}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}~\ctx = & (\emph{exch})\\[-0.25em]
  \hspace{2em}  \sem{\coctx{\Gamma_1,x\!:\!\tau_1,y\!:\!\tau_2,\Gamma_2}
     {\aclrd{\textbf{r}} \atimes \alift{\cclrd{s},\cclrd{t}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}\\[-0.25em]
  \hspace{4em}  (\ident{nest}_{\aclrd{\textbf{r}}, \alift{\cclrd{t},\cclrd{s}}, 
     \alift{\cclrd{s},\cclrd{t}}, \aclrd{\textbf{q}}}~\ident{swap}_{\cclrd{t},\cclrd{s}}~\ctx)
\\[0.5em]
\sem{\coctx{\Gamma_1,x\!:\!\tau_1,\Gamma_2}{\aclrd{\textbf{r}} 
        \atimes \alift{\cclrd{s} \,\cpar\, \cclrd{t}} \atimes \aclrd{\textbf{q}}} \vdash \subst{e}{z,y}{x} : \tau}~\ctx = & (\emph{contr})\\[-0.25em]
  \hspace{2em}  \sem{\coctx{\Gamma_1,y\!:\!\tau_1,z\!:\!\tau_1,\Gamma_2}
      {\aclrd{\textbf{r}} \atimes \alift{\cclrd{s},\cclrd{t}} \atimes \aclrd{\textbf{q}}} \vdash e : \tau}\\[-0.25em]
  \hspace{4em}  (\ident{nest}_{\aclrd{\textbf{r}}, \alift{\cclrd{s}\,\cpar\,\cclrd{t}}, 
      \alift{\cclrd{s},\cclrd{t}}, \aclrd{\textbf{q}}}~\ident{dup}_{\cclrd{s}, \cclrd{t}}~\ctx)
\end{array}
\end{equation*}
\\[0.5em]
{\small Assuming the following auxiliary definitions:}
\begin{equation*}
\hspace{-2em}
\begin{array}{l}
 \ident{swap}_{\cclrd{t},\cclrd{s}} ~:~ 
  \ctyp{\alift{\cclrd{t}, \cclrd{s}}}{(\alpha \xtimes \beta)} \rightarrow \ctyp{\alift{\cclrd{s}, \cclrd{t}}}{(\beta \xtimes \alpha)} \\[-0.25em]
\ident{swap}_{\cclrd{t},\cclrd{s}}~\ctx = \\
  \hspace{2em} \kvd{let}~(\ctx_1, \ctx_2) = \ident{split}_{\alift{\cclrd{t}}, \alift{\cclrd{s}}}~\ctx \\[-0.25em]
  \hspace{2em} \kvd{in}~\ident{merge}_{\alift{\cclrd{s}}, \alift{\cclrd{t}}}~(\ctx_2, \ctx_1)
 \\[0.5em]
\ident{nest}_{\aclrd{\textbf{r}}, \aclrd{\textbf{s}}, \aclrd{\textbf{s'}}, \aclrd{\textbf{t}}} ~:~
  (\ctyp{\aclrd{\textbf{s}}}{\beta} \rightarrow \ctyp{\aclrd{\textbf{s'}}}{\beta'}) \rightarrow
    \ctyp{\aclrd{\textbf{r}} \atimes \aclrd{\textbf{s}} \atimes \aclrd{\textbf{t}}}{(\alpha \xtimes \beta \xtimes \gamma)} \rightarrow
    \ctyp{\aclrd{\textbf{r}} \atimes \aclrd{\textbf{s'}} \atimes \aclrd{\textbf{t}}}{(\alpha \xtimes \beta' \xtimes \gamma)}\\[-0.25em]
\ident{nest}_{\aclrd{\textbf{r}}, \aclrd{\textbf{s}}, \aclrd{\textbf{s'}}, \aclrd{\textbf{t}}}~f~\ctx =\\
  \hspace{2em} \kvd{let}~(\ctx_1, \ctx') = \ident{split}_{\aclrd{\textbf{r}}, \aclrd{\textbf{s}}\atimes\aclrd{\textbf{t}}}~\ctx \\[-0.25em]
  \hspace{2em} \kvd{let}~(\ctx_2, \ctx_3) = \ident{split}_{\aclrd{\textbf{s}}, \aclrd{\textbf{t}}}~\ctx' \\[-0.25em] 
  \hspace{2em} \kvd{in}~\ident{merge}_{\aclrd{\textbf{r}}, \aclrd{\textbf{s'}}\atimes\aclrd{\textbf{t}}}~
        (\ctx_1, \ident{merge}_{\aclrd{\textbf{s'}}, \aclrd{\textbf{t}}}~(f~\ctx_2, \ctx_3))
\end{array}
\end{equation*}
\caption{Categorical semantics of the structural coeffect calculus}
\label{fig:struct-semantics}
\end{figure*}

% --------------------------------------------------------------------------------------------------

\subsection{Semantics of structural caluculus}

The concrete semantics for liveness and bounded variable use shown in 
Sections~\ref{sec:applications-struct-live} and \ref{sec:applications-struct-bll}
suggests that semantics of structural coeffect calculi tend to be more complex 
than semantics of flat coeffect calculi. The complexity comes from the fact
that we need a more expressive representation of the variable context -- \eg~a vector
of optional values -- and that the structural system needs to pass separate variable contexts
to the sub-expressions.

The latter aspect is fully captured by the semantics shown in this section. The
earlier point is left to the concrete notion of structural coeffect. Our model still gives
us the flexibility of defining the concrete representation of variable vectors. We explore
a number of examples in Section~\ref{sec:struct-semantics-examples} and start by looking
at the unified categorical semantics defined in terms of \emph{structural indexed comonads}.

\paragraph{Contexts and functions.}
In the structural coeffect calculus, expressions in context are interpreted as functions taking
a vector (represented using $-\xtimes-$) wrapped in a structure indexed with a vector of annotations
such as $\ctyp{\aclrd{\textbf{r}}}$. Functions take only a single variable as an input and so the
structure is annotated with a scalar, such as $\ctyp{\cclrd{r}}$, which we treat as being equivalent
to a singleton vector annotation $\ctyp{\alift{\cclrd{r}}}$:
%
\begin{equation*}
\begin{array}{rcl}
\sem{\coctx{x_1\!:\!\tau_1, \ldots, x_n\!:\!\tau_n}{ \alift{\cclrd{r_1}, \ldots, \cclrd{r_n}} } \vdash e : \tau} 
  &:& \ctyp{ \alift{\cclrd{r_1}, \ldots, \cclrd{r_n}} }{(\tau_1 \xtimes \ldots \xtimes \tau_n)} \rightarrow \tau\\
\sem{\tau_1 \xrightarrow{\cclrd{r}} \tau_2} &=& \ctyp{\alift{\cclrd{r}}}{\tau_1} \rightarrow \tau_2
\end{array}
\end{equation*}
%
Note that the instances of flat indexed comonad ignored the fact that the variable 
context wrapped in the data structure is a product. This is not generally the case for the 
structural indexed comonads -- the definitions shown in Section~\ref{sec:struct-semantics-examples}
are given specifically for $\ctyp{ \alift{\cclrd{r_1}, \ldots, \cclrd{r_n}} }{(\tau_1 \xtimes \ldots \xtimes \tau_n)}$
rather than more generally for $\ctyp{\aclrd{\textbf{r}}}{\alpha}$. The need for examining the structure
of the variable context is another reason for using $-\xtimes-$ when interpreting expressions in contexts.

\paragraph{Expressions.}
The semantics of strucutural coeffect calculi is shown in Figure~\ref{fig:struct-semantics}. As in
the previous chapter, the semantics is written in a programming language style using constructs
such as let-binding rather than using a categorical (point-free) notation. As before, the semantics
can be written using standard primitives (currying, uncurrying, function pairing etc.).

The following summarizes how the standard syntax-driven rules work, highlighting the differences
from the flat version:

\begin{itemize}
\item When accessing a variable (\emph{var}), the context now contains \emph{only} the accessed
  variable and so the semantics is just $\ident{counit}_{\cunit}$ without a projection.
  Constants (\emph{const}) are interpreted using a global dictionary $\delta$ as earlier.

\item The semantics of flat function application first duplicated the context so that the same 
  variables can be passed to both sub-expressions. This is no longer needed -- the 
  (\emph{app}) rule splits the variables \emph{including} the additional context into two parts.
  Passing the first context to the semantics of $e_1$ gives us a function
  $\ctyp{\alift{\cclrd{t}}}{\tau_1} \rightarrow \tau_2$. 

  The argument for the function is obtained by applying $\ident{cobind}_{\cclrd{t}, \aclrd{\textbf{s}}}$ 
  to the semantics of $e_2$. The resulting function 
  $\ctyp{\cclrd{t}\aseq\aclrd{\textbf{s}}}{(\ldots \xtimes \ldots \xtimes \ldots)} \rightarrow \ctyp{\alift{\cclrd{t}}}{\tau_1}$
  is then called with the latter part of the context to obtain argument for the first function.

\item The semantic of function abstraction (\emph{abs}) is syntactically the same as in the 
  flat version -- the only difference is that we now merge a free-variable context with a 
  singleton vector, both at the level of variable assignments and at the level of coeffect 
  annotations.
\end{itemize}

The semantics for the non-syntax-driven rules performs transformations on the 
free-variable context. Weakening (\emph{weak}) splits the context and ignores the part corresponding
to the removed variable. If we were modelling the semantics in a language with a linear 
type system, this would require an additional operation for ignoring a context annotated with 
$\aclrd{\czero}$.

The remaining rules perform a transformation anywhere inside the free-variable vector. 
To simplify writing the semantics, we define a helper operation 
$\ident{nest}_{\aclrd{\textbf{r}}, \aclrd{\textbf{s}}, \aclrd{\textbf{s'}}, \aclrd{\textbf{t}}}$
that splits the variable vector into three parts, transforms the middle part and then 
merges them, using the newly transformed middle part.

The transformations on the middle part are quite simple. The (\emph{sub}) rule 
uses $\ident{lift}_{\cclrd{s}, \cclrd{s'}}$ to discard some of the available additional context;
the (\emph{exch}) rule swaps two single-variable contexts and the (\emph{contr}) rule
uses the $\ident{dup}_{\cclrd{s}, \cclrd{t}}$ operation to duplicate a varaible while 
splitting its additional context.

\paragraph{Properties.}

As in the flat calculus, the main reason for defining the categorical semantics in this chapter
is to provide validation for the design of the calculus. As we show in the next section, the 
discussed examples (liveness, data-flow, bounded variable reuse) form \emph{structural indexed
comonads} and so the calculus captures them correctly if the coeffect annotations in the typing
rules match the indices in the semantics. More formally:

\begin{remark}[Correspondence]
In all of the typing rules of the structural coeffect system, the context annotations $\aclrd{\textbf{r}}$ 
and $\cclrd{s}$ of typing judgements $\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e : \tau$ and function types 
$\tau_1 \xrightarrow{\cclrd{s}} \tau_2$  correspond to the indices of mappings $\ctyp{\aclrd{\textbf{r}}}{}$ 
and $\ctyp{\alift{\cclrd{s}}}{}$ in the corresponding semantic function defined 
by $\sem{\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e : \tau}$.
\end{remark}
\begin{proof}
By analysis of the semantic rules in Figure~\ref{fig:struct-semantics}.
\end{proof}

\noindent
As in the flat calculus, the primitive operations of the structural indexed comonad are all 
annotated with different operations provided by the coeffect annotations. This means that the
semantics uniquely determines the structure of the typing rules of the strucutral coeffect
calculus. Thanks to the correspondence between the product structure $\atimes$ of the annotations
and the variable context $\xtimes$, the correspondence property also guarantees that variable
values are split correctly, as required by the structural nature of the type system.

% --------------------------------------------------------------------------------------------------

\subsection{Examples of structural indexed comonads}
\label{sec:struct-semantics-examples}

The categorical semantics for structural coeffect calculus can be easily instantiated to give
a semantics of a concrete calculus. In this section, we look at the three examples discussed
throughout this chapter -- structural liveness and data-flow and bounded variable reuse. 
Some aspects of the earlier two examples will be similar to flat versions discussed in
Section~\ref{sec:flat-semantics} -- they are based on the same data structures (option and a 
list, respectively), but the data structures are composed differently. Generally speaking -- 
rather than having a data structure over a product of variables, we now have 
a vector of variables over a specific data structure.

The abstract semantics does not specify how vectors of variables should be represented, so this can
vary in concrete instantiations. In all our examples, we represent a vector of variables as a 
product written using $\times$. To distinguish between products representing vectors and ordinary
products (\eg~a product of contexts returned by \ident{split}), we write vectors using 
$\langle a, \ldots, b \rangle$ rather than using parentheses.

\paragraph{Data-flow.}
It is interesting to note that the semantics of data-flow and bounded variable both keep
a product of multiple values for each variable, so they are both built around an \emph{indexed list}
data structure. However, their \ident{cobind} and \ident{dup} operations work differently. We start
by looking at the structure modelling data-flow computations (variables written in bold face such
as $\mathbf{a}_1$ range over vectors while $a_1$ ranges over individual values).

\begin{example}[Indexed list for data-flow]
The indexed list model of data-flow computations is defined over a structural coeffect
algebra $(\mathbb{N}, +, \mathit{max}, 0, 0, \leq)$. The data type $\ctyp{\langle n_1, \ldots, n_k\rangle}$
is indexed by required number of past variables for each individual variable. It is defined
over a vector of variables $\alpha_1 \xtimes \ldots \xtimes \alpha_k$ and it keeps a product
containing a current value followed by $n_i$ past values:
%
\begin{equation*}
\ctyp{\langle n_1, \ldots, n_k\rangle}{(\alpha_1 \xtimes \ldots \xtimes \alpha_k)} = 
\underbrace{(\alpha_1 \times \ldots \times \alpha_1)}_{(n_1+1)-\textnormal{times}} \times \ldots \times
  \underbrace{(\alpha_k \times \ldots \times \alpha_k)}_{(n_k+1)-\textnormal{times}}
\end{equation*}
%
The mappings that define the structural indexed comonad include the \ident{split} and \ident{merge}
operations that are shared by the other two examples (discussed below):
%
\begin{equation*}
\begin{array}{l}
\ident{merge}_{\langle m_1, \ldots, m_k \rangle, \langle n_1, \ldots n_l \rangle} 
  (\langle \mathbf{a_1}, \ldots, \mathbf{a_k} \rangle, \langle \mathbf{b_1}, \ldots, \mathbf{b_l}\rangle) = \\[-0.25em]
\quad \langle \mathbf{a_1}, \ldots, \mathbf{a_k}, \mathbf{b_1}, \ldots, \mathbf{b_l}\rangle
\\[0.45em]
\ident{split}_{\langle m_1, \ldots, m_k \rangle, \langle n_1, \ldots n_l \rangle} 
   \langle \mathbf{a_1}, \ldots, \mathbf{a_k}, \mathbf{b_1}, \ldots, \mathbf{b_l}\rangle = \\[-0.25em]
\quad (\langle \mathbf{a_1}, \ldots, \mathbf{a_k} \rangle, \langle \mathbf{b_1}, \ldots, \mathbf{b_l}\rangle)
\end{array}
\end{equation*}
%
The remaining mappings that are required by structural indexed comonad and capture the
essence of data-flow computations are defined as:
%
\begin{equation*}
\begin{array}{l}
\ident{counit}_{0}~\langle \langle a_0 \rangle \rangle = a_0
\\[0.45em]
\ident{cobind}_{m, \langle n_1, \ldots, n_k \rangle}~f~
  \langle \langle a_{1,0}, \ldots a_{1,m+{n_1}} \rangle, \ldots, \langle a_{k,0}, \ldots a_{k,m+{n_k}} \rangle \rangle = \\[-0.25em]
\quad \langle\langle\; f \langle \langle a_{1,0}, \ldots a_{1,{n_1}} \rangle, \ldots, \langle a_{k,0}, \ldots a_{k,{n_k}} \rangle \rangle, ~\ldots~, \\[-0.25em]
\quad ~~~\; f \langle \langle a_{1,m}, \ldots a_{1,m+{n_1}} \rangle, \ldots, \langle a_{k,m}, \ldots a_{k,m+{n_k}} \rangle \rangle~\; \rangle\rangle
\\[0.45em]
\ident{dup}_{m, n} \langle \langle a_1, \ldots, a_{\mathit{max}(m,n)} \rangle \rangle =
   \langle \langle a_1, \ldots, a_m \rangle, \langle a_1, \ldots, a_n \rangle \rangle
\\[0.45em]
\ident{lift}_{k', k} \langle\langle a_0, \ldots, a_{k'} \rangle\rangle = 
  \langle\langle a_0, \ldots, a_k \rangle\rangle \qquad\qquad(\hspace{-0.95em}\textnormal{\footnotesize when}~k\leq k')
\end{array}
\end{equation*}
\end{example}

The definition of the indexed list data structure relies on the fact that the number of annotations
corresponds to the number of variables combined using $-\xtimes-$. It then creates a vector of lists
containing $n_i+1$ values for $i$-\textit{th} variable (the annotation represents the number of 
required \emph{past} values so one more value is required).

The \ident{split} and \ident{merge} operations are defined separately, because they are not specific
to the example. They operate on the top-level vectors of variables (without looking at the 
representation of the variable). This means that we can re-use the same definitions for the following
two examples (with the only difference that $\mathbf{a_i}, \mathbf{b_i}$ will represent options
rather than lists).

The mappings that explain how data-flow computations work are \ident{cobind} (representing sequential
composition) and \ident{dup} (representing context sharing or parallel composition). In \ident{cobind},
we get $k$ vectors corresponding to $k$ variables, each with $m+n_i$ values. The operation calls 
$f$ $m$-times to obtain $m$ past values required as the result of type $\ctyp{\langle m \rangle} \beta$.

The \ident{dup} operation needs to produce a two-varaible context containing $m$ and $n$ values,
respectively, of the input variable. The input provides $\mathit{max}(m, n)$ values, so the definition
is simply a matter of restriction. Finally, \ident{counit} extracts the (only) value of the (only) variable
and \ident{lift} drops additional past values that are not required.

\paragraph{Bounded reuse.}
As mentioned earlier, the semantics of calculus for bounded reuse is also based on the indexed list 
structure. Rather than representing possibly different past values that can be shared (\emph{c.f.}~\ident{dup}), 
the list now represents multiple copies of the same value that cannot be shared.

\begin{example}[Indexed list for bounded reuse]
The indexed list model of bounded variable reuse is defined over a structural coeffect
algebra $(\mathbb{N}, \ast, +, 1, 0, \leq)$. The data type $\ctyp{\langle n_1, \ldots, n_k\rangle}$ 
is a vector containing $n_i$ values of $i$-\textit{th} variable:
%
\begin{equation*}
\ctyp{\langle n_1, \ldots, n_k\rangle}{(\alpha_1 \xtimes \ldots \xtimes \alpha_k)} = 
\underbrace{(\alpha_1 \times \ldots \times \alpha_1)}_{n_1-\textnormal{times}} \times \ldots \times
  \underbrace{(\alpha_k \times \ldots \times \alpha_k)}_{n_k-\textnormal{times}}
\end{equation*}
%
The \ident{merge} and \ident{split} operations are defined as in \emph{indexed list for data-flow}.
The operations that capture the behaviour of bounded reuse are defined as:
%
\begin{equation*}
\begin{array}{l}
\ident{counit}_{1}~\langle \langle a_0 \rangle \rangle = a_0
\\[0.45em]
\ident{lift}_{k', k} \langle\langle a_0, \ldots, a_{k'} \rangle\rangle = 
  \langle\langle a_0, \ldots, a_k \rangle\rangle \qquad\qquad(\hspace{-0.95em}\textnormal{\footnotesize when}~k\leq k')
\\[0.45em]
\ident{dup}_{m, n} \langle \langle a_1, \ldots, a_{m+n} \rangle \rangle = 
\quad \langle \langle a_1, \ldots, a_m \rangle, \langle a_{m+1}, \ldots, a_{m+n} \rangle \rangle
\\[0.45em]
\ident{cobind}_{m, \langle n_1, \ldots, n_k \rangle}~f~
  \langle \langle a_{1,0}, \ldots a_{1,m\ast{n_1}} \rangle, \ldots, \langle a_{k,0}, \ldots a_{k,m\ast{n_k}} \rangle \rangle = \\[-0.25em]
\quad \langle\; f \langle \langle a_{1,0}, \ldots a_{1,{n_1 - 1}} \rangle, \ldots, \langle a_{k,0}, \ldots a_{k,{n_k - 1}} \rangle \rangle, ~\ldots~, \\[-0.25em]
\quad ~~ f \langle \langle a_{1,(m-1)\ast n_1}, \ldots a_{1,(m-1) \ast n_1} \rangle, \ldots, 
                   \langle a_{k,m\ast n_k - 1}, \ldots a_{k,m\ast n_k - 1} \rangle \rangle~\; \rangle
\end{array}
\end{equation*}
\end{example}

\noindent
The \ident{counit} and \ident{lift} operations are defined as previously -- variable access 
extracts the only value of the only variable and sub-coeffecting allows discarding multiple
copies of a value that are not needed.

In the bounded variable reuse system, variable sharing is annotated with $+$ (in contrast with
\textit{max} used in data-flow). The \indent{dup} operation thus splits the $m+n$ available
values between two vectors of length $m$ and $n$, without \emph{sharing} a value. The 
\ident{cobind} operation works similarly -- it splits $m\ast n_i$ available values of each
variable into $m$ vectors containing $n_i$ copies and then calls the $f$ function $m$-times to 
obtain $m$ resulting values without sharing any input value.

\paragraph{Liveness.}
In both data-flow and bounded reuse, the data type is defined as a vector of values obtained
by applying some parameterized data type (indexed list) to types of individual variables. We can
generalize this pattern and define $\ctyp{\langle l_1, \ldots, l_n \rangle}$ in terms of 
$D^{l}$ where $D^{l}$ is a simpler indexed data type. For liveness, the definition lets us 
reuse the mapping used when defining the semantics of flat liveness. However, we cannot fully
define the semantics of the structural version in terms of the flat version -- the 
\ident{cobind} operation is different and we need to provide the \ident{dup} operation.

\begin{example}[Structural indexed option]
Given a structural coeffect algebra formed by $(\{ \ident{L}, \ident{D} \}, \sqcap, \sqcup, \ident{L}, \ident{D}, \sqsubseteq)$
and the indexed option data type $D^l$, such that $D^{\ident{D}}\alpha = 1$ and $D^{\ident{L}}\alpha=\alpha$,
the data type for structural indexed option comonad is:
%
\begin{equation*}
\ctyp{\langle n_1, \ldots, n_k\rangle}{(\alpha_1 \xtimes \ldots \xtimes \alpha_k)} = 
  D^{n_1} \alpha_1 \times \ldots \times D^{n_k} \alpha_k
\end{equation*}
%
The \ident{merge} and \ident{split} operations are defined as earlier. The remaining operations
model variable liveness as follows:
%
\begin{equation*}
\begin{array}{l}
\ident{cobind}_{\ident{L}, \langle l_1, \ldots, l_n \rangle}~f~\langle a_1, \ldots, a_n \rangle = \langle f~\langle a_1, \ldots, a_n \rangle \rangle \\[-0.25em]
\ident{cobind}_{\ident{D}, \langle \ident{D}, \ldots, \ident{D} \rangle}~f~\langle (), \ldots, () \rangle = \langle \ident{D} \rangle
\\[0.5em]
\hspace{-0.5em}
\begin{array}{lll}
~\\[-0.85em]
\ident{dup}_{\ident{D}, \ident{D}} \langle () \rangle &\narrow{=}& \langle (), () \rangle \\[-0.25em]
\ident{dup}_{\ident{L}, \ident{D}} \langle a \rangle &\narrow{=}& \langle a, () \rangle \\[-0.25em]
\ident{dup}_{\ident{D}, \ident{L}} \langle a \rangle &\narrow{=}& \langle (), a \rangle \\[-0.25em]
\ident{dup}_{\ident{L}, \ident{L}} \langle a \rangle &\narrow{=}& \langle a, a \rangle 
\end{array}
\qquad\quad
\begin{array}{lll}
\ident{counit}_{\ident{L}}~\langle a \rangle &\narrow{=}& a
\\[0.45em]
\ident{lift}_{\ident{L}, \ident{L}} \langle a \rangle &\narrow{=}& \langle a \rangle \\[-0.25em]
\ident{lift}_{\ident{L}, \ident{D}} \langle a \rangle &\narrow{=}& \langle () \rangle \\[-0.25em]
\ident{lift}_{\ident{D}, \ident{D}} \langle () \rangle &\narrow{=}& \langle () \rangle \\[-0.25em]
\end{array}
\end{array}
\end{equation*}
\end{example}

\noindent
When the expected result of the \ident{cobind} operation is dead (second case), the operation can
ignore all inputs and directly return the unit value $()$. Otherwise, it passes the vector of 
input variables to $f$ as-is -- no matter whether the individual values are live or dead. The
\ident{L} annotation is a unit with respect to $\cap$ and so the annotations expected by $f$ are
the same as those required by the result of \ident{cobind}.

The \ident{dup} operation resembles with the flat version of \ident{split} -- this is expected as
duplication in the flat calculus is performed by first duplicating the variable context (using 
\ident{map}) and then applying \ident{split}. Here, the duplication returns a pair which may or
may not contain value, depending on the annotations.

Finally, \ident{counit} extracts a value which is always present as guaranteed by the type
$\ctyp{\langle \ident{L} \rangle}{\alpha} \rightarrow \alpha$. The lifting operation models 
sub-coeffecting which may drop an available value (second case) or behaves as identity.


% ==================================================================================================
%                                                                   
%       ###                  #                    #       #          
%      #   #                 #                    #                  
%      #      #   #  # ##   ####    ###    ###   ####    ##     ###  
%       ###   #   #  ##  #   #         #  #   #   #       #    #   # 
%          #  #  ##  #   #   #      ####  #       #       #    #     
%      #   #   ## #  #   #   #  #  #   #  #   #   #  #    #    #   # 
%       ###       #  #   #    ##    ####   ###     ##    ###    ###  
%             #   #                                                  
%              ###                                                   
%
% ==================================================================================================

\section{Equational theory}
\label{sec:struct-syntax}

Similarly to the flat version, each concrete instance of the structural coeffect calculus has a 
different notion of context and thus a different operational interpretation. As before, the 
properties of the flat coeffect algebra guarantee that certain equational properties hold for 
all instances of the calculus. In this section, we look at these common properties that we get
``for free'' in all structural coeffect calculi.

We start the discussion by briefly considering the key aspects
that make the equational theory of flat and structural coeffects different.

\subsection{From flat coeffects to structural coeffects}
\label{sec:struct-syntax-intro}

When discussing equational theory for the flat calculus in Section~\ref{sec:flat-syntax}, we 
noted that no single technique of specifying syntactic reduction works universally for all 
flat coeffect calculi. We considered multiple different options (call-by-name, call-by-value, 
internalized substitution) that can be used as the basis for operational semantics for
different calculi that satisfy different additional properties. 

The structural coeffect calculus has more desirable equational properties. In particular, 
we can prove both $\beta$-reduction and $\eta$-expansion using just the properties of strucutral 
coeffect algebra. For this reason, we focus on these two reductions in this section.
Using the terminology of Pfenning and Davies \cite{logic-modal-reconstruction},
the structural coeffect calculus satisfies both the \emph{local soundness} and 
the \emph{local completeness} properties.

\paragraph{Substitution for flat coeffects.} 
The less obvious (\emph{top-pointed}) variant of the substitution lemma for flat coeffects 
(Lemma~\ref{thm:cbn-substitution-bot}) required all operations of the flat coeffect algebra
to coincide. This enables the substitution to preserve the type of expressions, because all
additional requirements arising as the result of the substitution can be associated with the
declaration context. For example, consider the following example where implicit parameter 
$\ident{?offset}$ is substituted for the variable $y$:
%
\begin{equation*}
\begin{array}{rclcll}
 \coctx{y\!:\!\ident{int}}{\cclrd{\emptyset}} &\narrow{\vdash}& \lambda x.y + \ident{?total} &\narrow{:}&
   \ident{int} \xrightarrow{\cclrd{ \{ \ident{?total} \} }} \ident{int} & \qquad(\textnormal{before}) \\
\coctx{()}{\cclrd{ \{ \ident{?offset} \} }} &\narrow{\vdash}& \lambda x.\ident{?offset} + \ident{?total} &\narrow{:}&
  \ident{int} \xrightarrow{\cclrd{ \{ \ident{?total} \} }} \ident{int} & \qquad(\textnormal{after})
\end{array}  
\end{equation*}
%
The typing judgement obtained in (\emph{after}) preserves the type of the expression
(function value) from the original typing (\emph{before}). This is possible thanks to the
non-determinism involved in lambda abstraction -- as all operators of the flat coeffect
algebra used here are $\cup$, we can place the additional requirement on the outer context.
Note that this is not the \emph{only} possible typing, but it is \emph{permissible} typing.

Here, the flat coeffect calculus gives us typing with limited \emph{precision}, but 
enough \emph{flexibility} to prove the substitution lemma.

\paragraph{Substitution for structural coeffects.}
In contrast, the substitution lemma for structural coeffects can be proven because 
structural coeffect systems provide enough \emph{precision} to identify exactly with 
which variable should a context requirement be associated.

The following example shows a situation similar to the previous one -- here, we use
structural data-flow calculus (writing $\kvd{prev}~e$ to obtain previous value of the 
expression $e$) and we substitute $w+z$ for $y$:
%
\begin{equation*}
\begin{array}{rclcll}
 \coctx{y\!:\!\ident{int}}{ \alift{\cclrd{2}} } 
  &\narrow{\vdash}& \lambda x.\kvd{prev}~(x + \kvd{prev}~y) &\narrow{:}&
   \ident{int} \xrightarrow{\cclrd{ 1 }} \ident{int} & \quad(\textnormal{before}) \\
\coctx{w\!:\!\ident{int}, z\!:\!\ident{int}}{\cclrd{2}\cclrd{\ast}\alift{\cclrd{1},\cclrd{1}}} 
  &\narrow{\vdash}& \lambda x.\kvd{prev}~(x + \kvd{prev}~(w+z))) &\narrow{:}&
   \ident{int} \xrightarrow{\cclrd{ 1 }} \ident{int} & \quad(\textnormal{after}) \\
\coctx{w\!:\!\ident{int}, z\!:\!\ident{int}}{\alift{\cclrd{2},\cclrd{2}}} 
  &\narrow{\vdash}& \lambda x.\kvd{prev}~(x + \kvd{prev}~(w+z))) &\narrow{:}&
   \ident{int} \xrightarrow{\cclrd{ 1 }} \ident{int} & \quad(\textnormal{final})
\end{array}  
\end{equation*}
%
The type of the function does not change, because the structural type system associates
the annotation $\cclrd{1}$ with the bound variable $x$ and the substitution does not 
affect how the variable $x$ is used.

The other aspect demonstrated in the example is how the coeffect of the substituted 
variable affects the free-variable context of the substituted expression. Here, the
original variable $y$ is annotated with $\cclrd{2}$ and we substitute it for an
expression $w+z$ with free variables $w,z$ annotated with $\alift{\cclrd{1}, \cclrd{1}}$.
The substitution applies the operation $\aseq$ (modelling sequential composition) to 
the annotation of the new context -- in the above example
$\cclrd{2}\cclrd{\ast}\alift{\cclrd{1}, \cclrd{1}}=\alift{\cclrd{2}, \cclrd{2}}$.

\subsection{Holes and substitution lemma}

As demonstrated in the previous section, reduction (and substitution) in the structural coeffect 
calculus may need to replace a \emph{single} variable with a \emph{vector} of variables. 
More importantly, because the system uses explicit contraction, we may also need to substitute 
for multiple variables in the variable context at the same time.

Consider the expression $\lambda x.x+x$. It is type-checked by type-checking $x_1 + x_2$,
contracting $x_1$ and $x_2$ and then applying lambda abstraction. During the reduction of 
$(\lambda x.x+x)~(y+z)$ we need to substitute $y_1+z_1$ for $x_1$ and $y_2+z_2$ for $x_2$.
This is similar to substitution lemma in other structural variants of $\lambda$-calculus,
such as the bunched typing system \cite{substruct-bunched}. To express the substitution 
lemma, we define the notion of a \emph{context with holes}:

\begin{definition}[Context with holes]
A \emph{context with holes} is a context such as $\coctx{x_1\!:\!\tau_1, \ldots, x_k\!:\!\tau_k}{\alift{\cclrd{r_1}, \ldots, \cclrd{r_k}}}$,
where some of the variable typings $x_i\!:\!\tau_i$ and corresponding coeffects $\cclrd{r_i}$ 
are replaced by \emph{holes} written as $-$.

\begin{equation*}
~\Delta[\,\coctx{-}{-}\,]_n = \Delta[\,\underbrace{\coctx{-}{-} \,|\, \ldots \,|\, \coctx{-}{-}}_{ n-\textit{times} } \,]
\end{equation*}
\begin{equation*}
\begin{array}{lcl}
 \Delta[\,\coctx{-}{-}\,]_n &\narrow{:=}&
   \coctx{-, \Gamma}{\alift{-} \atimes \aclrd{\textbf{s}} }
   \qquad \textnormal{where}~\coctx{\Gamma}{\aclrd{\textbf{s}}} \in \Delta[\,\coctx{-}{-}\,]_{n-1} \\
 \Delta[\,\coctx{-}{-}\,]_n &\narrow{:=}&
   \coctx{x\!:\!\tau, \Gamma}{\alift{\cclrd{r}} \atimes \aclrd{\textbf{s}} }
   \qquad \textnormal{where}~\coctx{\Gamma}{\aclrd{\textbf{s}}} \in \Delta[\,\coctx{-}{-}\,]_n \\
 \Delta[\,\coctx{-}{-}\,]_0 &\narrow{:=}&
   \coctx{()}{\alift{}}
\end{array} 
\end{equation*} 
\end{definition}

\noindent
A context with $n$ holes may either start with a hole, followed by a context with $n-1$ holes, or it may
start with a variable followed by a context with $n$ holes. Note that the definition ensures that
the locations of variable holes correspond to the locations of coeffect annotation holes. Given a context
with holes, we can fill the holes with other contexts using the \emph{hole filling} operation and
obtain an ordinary coeffect-annotated context.

\begin{definition}[Hole filling] Given a context with $n$ holes $\coctx{\Delta}{\textbf{s}} \in 
\Delta[\,\coctx{-}{-}\,]_n$, the hole filling operation written as 
$\coctx{\Delta}{\textbf{s}}[\,\coctx{\Gamma_1}{\aclrd{\mathbf{r_1}}} \,|\, \ldots \,|\, \coctx{\Gamma_n}{\aclrd{\mathbf{r_n}}} \,]$,
which replaces the holes by the specified variables and corresponding coeffect annotations, is defined as:
%
\begin{equation*}
\begin{array}{rcl}
 \coctx{-, \Delta}{\alift{-} \atimes \textbf{s} }
    ~[\,\coctx{\Gamma_1}{\aclrd{\textbf{r}_1}} \,|\, \coctx{\Gamma_2}{\aclrd{\textbf{r}_2}} \,|\, \ldots \,] &\narrow{=}&
      \coctx{\Gamma_1, \Gamma_2}{\aclrd{\textbf{r}_1} \atimes \aclrd{\textbf{r}_2} } \\
 && \qquad \hspace{-9.3em} \textnormal{where}~\coctx{\Gamma_2}{\aclrd{\textbf{r}_2}} =
     \coctx{\Delta}{\textbf{s}}[\, \coctx{\Gamma_2}{\aclrd{\textbf{r}_2}} \,|\, \ldots \,] 
\\[0.5em]
 \coctx{x_1\!:\!\tau, \Delta}{\alift{\cclrd{r_1}} \atimes \textbf{s} }
    ~[\,\coctx{\Gamma_1}{\aclrd{\textbf{r}_1}} \,|\, \coctx{\Gamma_2}{\aclrd{\textbf{r}_2}} \,|\, \ldots \,] &\narrow{=}&
      \coctx{x_1\!:\!\tau, \Gamma_2}{\alift{\cclrd{r_1}} \atimes \aclrd{\textbf{r}_2} } \\
 && \qquad \hspace{-9.3em} \textnormal{where}~\coctx{\Gamma_2}{\aclrd{\textbf{r}_2}} =
     \coctx{\Delta}{\textbf{s}}[\,\coctx{\Gamma_1}{\aclrd{\textbf{r}_1}} \,|\, \coctx{\Gamma_2}{\aclrd{\textbf{r}_2}} \,|\, \ldots \,] 
\\[0.5em]
 \coctx{()}{\alift{}}~[~] &\narrow{=}& \coctx{()}{\alift{}}
\end{array} 
\end{equation*} 
\end{definition}

\noindent
When we substitute an expression with coeffects $\aclrd{\textbf{t}}$ (associated with variables $\Gamma$)
for a variable that has coeffects $\cclrd{s}$, the resulting coeffects of $\Gamma$ need to 
combine $\aclrd{\textbf{t}}$ and $\cclrd{s}$. Unlike in the flat coeffect systems, the structural 
substitution does not require all coeffect algebra operations to coincide and so the combination
is more interesting than in the bottom-pointed substitution for flat coeffects, where it used
the only available operator (Lemma~\ref{thm:cbn-substitution-bot}).

Substitution can be seen as sequential composition. Informally -- we first need to obtain the 
value of the expression (requiring $\aclrd{\textbf{t}}$) and then use it in context with 
requirements $\cclrd{s}$. Thus the free variables of the expression \emph{after} substitution
are annotated with $\cclrd{s} \,\aseq\, \aclrd{\textbf{t}}$, using the (scalar-vector extension)
of the sequential composition operator $\cseq$. This suggests that, to evaluate each of the variables
annotated with coeffects in the vector $\aclrd{\textbf{t}}$, we first need to evaluate the substituted
expression with coeffects $\cclrd{s}$, followed by the rest of the expression with coeffects specified
by $\aclrd{\textbf{t}}$.

\begin{lemma}[Multi-nary substitution]
\label{thm:structural-substitution}
Given an expression with multiple holes filled by variables $x_i\!:\!\tau_i$ with coeffects $\cclrd{s_k}$:
%
\begin{equation*}
\coctx{\Gamma}{\aclrd{\textbf{r}}}~[\,\coctx{x_1\!:\!\tau_1}{\alift{\cclrd{s_1}}} \,|\, \ldots \,|\,
  \coctx{x_k\!:\!\tau_k}{\alift{\cclrd{s_k}}}\,] \vdash e_r : \tau_r
\end{equation*}
%
and a expressions $e_i$ with free-variable contexts $\Gamma_i$ annotated with $\aclrd{\mathbf{t_i}}$:
%
\begin{equation*}
\coctx{\Gamma_1}{\aclrd{\textbf{t}_1}} \vdash e_1 : \tau_1 
\quad \ldots \quad
\coctx{\Gamma_k}{\aclrd{\textbf{t}_k}} \vdash e_k : \tau_k
\end{equation*}
%
then substituting the expressions $e_i$ for variables $x_i$ results in an expression with a context
where the original holes are filled by contexts $\Gamma_i$ with coeffects $\cclrd{s_i} \aseq \aclrd{\mathbf{t_i}}$:
%
\begin{equation*}
\coctx{\Gamma}{\aclrd{\textbf{r}}}~[\,\coctx{\Gamma_s}{\cclrd{s_1}\aseq\,\aclrd{\textbf{t}_1}} \,|\, \ldots \,|\, 
  \coctx{\Gamma_s}{\cclrd{s_k}\aseq\,\aclrd{\textbf{t}_k}}\,] \vdash \subst{\subst{e_r}{x_1}{e_1}\ldots}{x_k}{e_k} : \tau_r
\end{equation*}
\end{lemma}
\begin{proof}
By induction over $\vdash$, using the multi-nary aspect of the substitution 
in the proof of the contraction case.
\end{proof}

\subsection{Reduction and expansion}

In the previous chapter, we discussed call-by-value separately from call-by-name, because the
proof of call-by-value substitution has fewer prerequisites. In this section, we consider full
$\beta$-reduction (local soundness), which encompasses both types of evaluation and 
$\eta$-expansion (local completeness). Both of the properties hold for a system with any
structural coeffect algebra.

\paragraph{Reduction theorem}
In a full $\beta$-reduction,
written as $\rightarrow_\beta$, we replace the redex $(\lambda x.e_2)~e_1$ by the
expression $\subst{e_r}{x}{e_s}$ anywhere inside a term. The subject reduction theorem
guarantees that this does not change the type of the term.

\begin{theorem}[$\beta$-reduction]
In a structural coeffect system with a structural coeffect algebra formed by 
$(\C, \cseq, \cpar, \cunit, \czero, \cleq)$ and operations $\alift{-}$ and $\aseq$,
if $\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e : \tau$ 
and $e \rightarrow_{\beta} e'$ using the full $\beta$-reduction then
$\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e' : \tau$.
\end{theorem}
\begin{proof}
Consider the typing derivation for the redex $(\lambda x.e_r)\,e_s$ before the reduction
(note that this is similar to the typing of let binding discussed in Remark~\ref{thm:structural-letbinding},
but we do not swap the two parts of the free-variable context):
%
\begin{equation*}
\inference
  { \begin{array}{l}\coctx{\Gamma_s}{\aclrd{\textbf{s}}} \vdash e_s : \tau_s\vspace{-2em}\end{array} &
    \inference
      { \coctx{\Gamma_r, x\!:\!\tau_s}{\aclrd{\textbf{r}}\;\atimes\,\alift{\cclrd{t}}} \vdash e_r : \tau_r }
      { \coctx{\Gamma_r}{\aclrd{\textbf{r}}} \vdash \lambda x.e_r : \tau_s \xrightarrow{\cclrd{t}} \tau_r} \vspace{0.2em} }
  { \coctx{\Gamma_r, \Gamma_s}{\aclrd{\textbf{r}} \;\atimes\; (\cclrd{t} \,\aseq\, \aclrd{\textbf{s}})} \vdash (\lambda x.e_r)~e_s : \tau_r }
\end{equation*}
%
For the substitution lemma, we first rewrite the typing judgement for $e_r$, \ie~
$\coctx{\Gamma_r, x\!:\!\tau_s}{\aclrd{\textbf{r}}\;\atimes\,\alift{\cclrd{t}}} \vdash e_r : \tau_r$
as a context with a single hole filled by the $x$ variable:
$\coctx{\Gamma_r, -}{\aclrd{\textbf{r}}\;\atimes\,-}~[\,\coctx{x\!:\!\tau_s}{\alift{\cclrd{t}}}\,] \vdash e_r : \tau_r$.
Now we can perform the substitution using Lemma~\ref{thm:structural-substitution}:
%
\begin{equation*}
\inference
  { \coctx{\Gamma_r, -}{\aclrd{\textbf{r}}\;\atimes-}~[\,\coctx{x\!:\!\tau_s}{\alift{\cclrd{t}}}\,] \vdash e_r : \tau_r & 
    \coctx{\Gamma_s}{\aclrd{\textbf{s}}} \vdash e_s : \tau_s }
  { \inference
      { \coctx{\Gamma_r, -}{\aclrd{\textbf{r}}\;\atimes-}~[\,\coctx{\Gamma_s}{\cclrd{t}\,\aseq\,\aclrd{\textbf{s}} }\,] \vdash \subst{e_r}{x}{e_s} : \tau_r }
      { \coctx{\Gamma_r, \Gamma_s}{\aclrd{\textbf{r}}\,\atimes\,(\cclrd{t}\,\aseq\,\aclrd{\textbf{s}})} \vdash \subst{e_r}{x}{e_s} : \tau_r } }
\end{equation*}
%
The last step applies the hole filling operation, showing that substitution preserves 
the type of the term.
\end{proof}

\noindent
Because of the vector (free monoid) structure, coeffect annotations $\aclrd{\textbf{r}}$, 
$\aclrd{\textbf{s}}$, and $\alift{\cclrd{t}}$ are uniquely associated with $\Gamma_r$, 
$\Gamma_s$, and $x$ respectively. Therefore, substituting $e_s$ (which has coeffects 
$\aclrd{\textbf{s}}$) for $x$ introduces the context dependencies specified by $\aclrd{\textbf{s}}$
which are composed with the existing requirements $\cclrd{t}$ on $x$. 

\paragraph{Expansion theorem}
Structural coeffect systems also exhibit $\eta$-equality, therefore satisfying both
\emph{local soundness} and \emph{local completeness}. Informally, this means that 
abstraction does not introduce too much, and application does not eliminate too much.

\begin{theorem}[$\eta$-expansion]
In a structural coeffect system with a structural coeffect algebra formed by 
$(\C, \cseq, \cpar, \cunit, \czero, \cleq)$ and operations $\alift{-}$ and $\aseq$,
if $\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e : \tau$ 
and $e \rightarrow_{\eta} e'$ using the full $\eta$-reduction then
$\coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash e' : \tau$.
\end{theorem}
\begin{proof}
The following derivation shows that $\lambda x.f~x$ has the same type as $f$:
\begin{equation*}
\inference
  { \inference
    { \coctx{\Gamma}{\aclrd{\textbf{r}}} \vdash f : \tau_1 \xrightarrow{\cclrd{s}} \tau_2 &
      \coctx{x:\tau_1}{\alift{\cunit}} \vdash x:\tau_1 }
    { \coctx{\Gamma, x:\tau_1}{\aclrd{\textbf{r}} \;\atimes\;(\cclrd{s}\,\aseq\,\alift{\cunit}) } \vdash f~x : \tau_2 } }
  { \inference
    { \coctx{\Gamma, x:\tau_1}{\aclrd{\textbf{r}} \;\atimes\,\alift{\cclrd{s}} } \vdash f~x : \tau_2 }
    { \coctx{\Gamma}{ \aclrd{\textbf{r}} } \vdash \lambda x.f~x : \tau_1 \xrightarrow{\cclrd{s}} \tau_2 } }
\end{equation*}
%
The second step uses the fact that 
$\cclrd{s} \,\aseq\, \alift{\cunit} = \alift{\cclrd{s} \,\cseq\, \cunit} = \alift{\cclrd{s}}$ 
arising from the monoid $(\C, \cseq, \cunit)$ of the scalar coeffect structure.
\end{proof}

\noindent
The $\eta$-expansion property discussed in this section highlights another difference 
between coeffects and effects. The $\eta$-equality property does not hold for many notions 
of effect. For example, in a language with output effects, $e = (\textsf{print \texttt{"hi"}}; (\lambda x . x))$ 
has different effects to its $\eta$-converted form $\lambda x . e x$ because the immediate 
effects of $e$ are hidden by the purity of $\lambda$-abstraction. In the coeffect calculus, 
the (\emph{abs}) rule allows immediate contextual requirements of $e$ to ``float outside'' 
of the enclosing $\lambda$. Furthermore, the free monoid nature of $\atimes$ in structural 
coeffect systems allows the exact immediate requirements of $\lambda x . e x$ to match 
those of $e$. 

                                                                          
% ==================================================================================================
%
%     ###                         ##                    #                 
%    #   #                         #                                      
%    #       ###   # ##    ###     #    #   #   ###    ##     ###   # ##  
%    #      #   #  ##  #  #   #    #    #   #  #        #    #   #  ##  # 
%    #      #   #  #   #  #        #    #   #   ###     #    #   #  #   # 
%    #   #  #   #  #   #  #   #    #    #  ##      #    #    #   #  #   # 
%     ###    ###   #   #   ###    ###    ## #  ####    ###    ###   #   # 
%
% ==================================================================================================
                                                                          

\section{Conclusions}

This chapter completes the key development of this thesis -- the presentation of unified calculi
for context-aware computations that capture the motivating examples introduced in 
Chapter~\ref{ch:applications}. In the previous chapter, we focused on the first category of 
contet-aware computations and we developed \emph{flat coeffect calculus} that captures
\emph{whole-context} properties. This chapter develops \emph{structural coeffect calculus},
capturing \emph{per-variable} contextual properties. The system provides a precise 
analysis of liveness and data-flow and allows other interesting uses such as tracking of variable
accesses based on bounded linear logic.

Following the structure of the previous chapter, the structural coeffect calculus is parameterized
by a \emph{structural coeffect algebra}. The two definitions are similar -- both require operations 
$\cseq$ and $\cpar$ that model sequential and pointwise composition, respectively. For flat 
coeffects, we further require $\czip$ to model context merging. For structural coeffects, we 
instead use a vector (free monoid) with the $\atimes$ operation -- which serves a similar purpose
as $\czip$.

In order to keep track of separate annotations for each variable, we use a system with 
explicit structural rules (contraction, weakening and exchange) that manipulate the structure
of variables and the structure of annotations at the same time.

The chapter presents two technical results. The first is the semantics of structural coeffect
calculus in terms of \emph{structural indexed comonads}. The semantics serves two purposes --
it unifies our three example calculi (bounded reuse, data-flow and liveness) and it demonstrates
suitability of the type system. The second technical result is equational theory for structural
coeffect calculi. In particular, we show that $\beta$-reduction and $\eta$-expansion preserve
the typing for any structural coeffect calculi. These two strong properties are desirable for
programming languages, but are often not satisfied (\eg~by effectful langauges).

Two questions remain opened for the upcoming chapter. Firstly, is there a way to present 
flat and structural coeffect calculi in a uniform way as a single system? Secondly, can we
simplify the definitions to make type inference easier and add other practical language
aspects such as recursion?