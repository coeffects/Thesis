% ==================================================================================================

\chapter{Semantics of flat coeffects}
\label{ch:semantics}

The \emph{flat coeffect calculus} introduced in the previous chapter uniformly captures a number
of context-aware systems discussed in Chapter~\ref{ch:applications}. The coeffect calculus 
can be seen as a \emph{language framework} that simplifies the construction of concrete 
\emph{domain-specific} coeffect lnguages. In the previous chapter, we discussed how it provides a  
type system that tracks the required context. In this chapter, we show that the langauge framework 
also provides a way for defining the semantics of concrete domain-specific coeffect languages,  
guides their implementation and simplifies safety proofs.

This is done using a \emph{comonadically-inspired translation}. We translate a program written 
using the coeffect calculus into a simple functional language with additional coeffect-specific 
comonadically-inspired primitives that implement the concrete notion of context-awareness. 

We use comonads in a syntactic way, following the example of Haskell's use of monads. The 
translation is the same for all coeffect languages, but the safety depends on the concrete
coeffect-specific comonadically-inspired primitives. We prove the soundness of two concrete
coeffect calculi (dataflow and implicit parameters). We note that the proof crucially relies on a 
relationship between coeffect annotations (provided by the type system) and the comonadically-inspired
primitives (defining the semantics), which makes it easy to extend it to other concrete 
context-aware langauges.

\paragraph{Chapter structure and contributions}

\begin{itemize}
\item We introduce \emph{indexed comonads}, a generalization of comonads, a category-theoretical 
  dual of monads (Section~\ref{sec:semantics-theory}) and we discuss how they provide semantics
  for coeffect calculus. This provides an insight into how (and why) the calculus works and shows 
  an intriguing link with effects and monads.
  
\item We use indexed comonads to guide our \emph{translational semantics} of coeffect calculus
  (Section~\ref{sec:semantics-translation}). We define a simple functional programming language
  (with type system and operational semantics) and prove that well-typed programs in the language
  do not get stuck. We extend it with uninterpreted comonadically-inspired primitives and
  define a translation that turns well-typed context-aware coeffect programs into programs of 
  our functional language.
  
\item For two of the coeffect calculi discussed earlier (dataflow and implicit parameters),
  we give reduction rules for the comonadically-inspired primitives and we extend the progress
  and preservation proofs, showing that well-typed programs produced by translation from two
  coeffect languages do not get stuck (Section~\ref{sec:semantics-proofs})

\item We leave the details to future work, but we note that the proof for concrete coeffect language 
  (dataflow and implicit parameters) can be generalized -- rather than reconsidering progress and 
  preservation of the whole target language, we rely just on the correctness of the coeffect-specific 
  comonadically-inspired primitives and abstraction mechanism provided by languages 
  such as ML and Haskell (Section~\ref{sec:semantics-related}).
\end{itemize}  


% ==================================================================================================
%
%    ###
%     #  #    # ##### #####   ####  #####  #    #  ####  ##### #  ####  #    #
%     #  ##   #   #   #    # #    # #    # #    # #    #   #   # #    # ##   #
%     #  # #  #   #   #    # #    # #    # #    # #        #   # #    # # #  #
%     #  #  # #   #   #####  #    # #    # #    # #        #   # #    # #  # #
%     #  #   ##   #   #   #  #    # #    # #    # #    #   #   # #    # #   ##
%    ### #    #   #   #    #  ####  #####   ####   ####    #   #  ####  #    #
%
% ==================================================================================================

\section{Introduction and safety}
\label{sec:semantics-intro}

This chapter links together all the different technical developments presented in this thesis.
We take the flat coeffect calculus introduced in Chatper~\ref{ch:flat}, define its \emph{abstract 
comonadic semantics} and use it to define a translation that gives a \emph{concrete operational
semantics} to a number of concrete context-aware languages. The type system is used to guarantee 
that the resulting programs are correct. Finally, the development in this chapter is closely 
mirrored by the implementation presented in Chapter~\ref{ch:impl}, which implements the 
translation together with an interpreter for the target language.

The key claim of this thesis is that writing context-aware programs using coeffects is easier and
safer. In this chapter, we substantiate the claim by showing that programs written in the coeffect
calculus and evaluated using the translation provided here do not ``go wrong''. 

To provide an intuition, consider two context-aware programs. The first calls a function that
adds two implicit parameters in a context where one of them is defined. The second calculates
the difference between the current and the previous value in a dataflow computation.
For comparison, we show the code written in a coeffect dataflow language (on the left) and 
using standard ML-like libraries (on the right):
%
\begin{equation*}
\begin{array}{lcl}
\begin{array}{l}
\kvd{let}~\ident{add}=\kvd{fun}~\ident{x}\rightarrow\\[-0.2em]
 \quad \ident{?one} + \ident{?two}~\kvd{in}\\[-0.2em]
\kvd{let}~\ident{?one} = 10~\kvd{in}\\[-0.2em] 
\ident{add}~0
\end{array} 
&\quad&
\begin{array}{l}
\kvd{let}~\ident{add}=\kvd{fun}~\ident{x}~\ident{params}\rightarrow\\[-0.2em]
 \quad \ident{lookup}~\str{one}~\ident{params}~+ \\[-0.2em]
 \quad\quad \ident{lookup}~\str{two}~\ident{params}~\kvd{in}\\[-0.2em]
\ident{add}~0~(\ident{add}~\str{one}~10~\ident{params})
\end{array} 
\\[3.5em]
\begin{array}{l}
\kvd{let}~\ident{diff}=\kvd{fun}~\ident{x}\rightarrow\\[-0.2em]
 \quad \ident{x}-\kvd{prev}~\ident{x}
\end{array} 
&&
\begin{array}{l}
\kvd{let}~\ident{diff}=\kvd{fun}~\ident{x}\rightarrow\\[-0.2em]
 \quad \ident{List.head}~\ident{x}-\ident{List.head}~(\ident{List.tail}~\ident{x})
\end{array} 
\end{array} 
\end{equation*}
%
The \ident{add} function (on the left) has a type $\ident{int}\xrightarrow{\cclrd{ \{ \ident{?one},\ident{?two} \} }}\ident{int}$.
We call it in a context containing $\cclrd{\ident{?one}}$ and so the coeffect of the program is
$\cclrd{ \{ \ident{?two} \} }$. The safety property for implicit parameters
(Theorem~\ref{thm:semantics-sound-impl}) guarantees that, when executed in a context that
provides a value for the implicit parameter $\cclrd{\ident{?one}}$, the program reduces to 
a value of an correct type (or never terminates).

If we wrote the code without coeffects (on the right), we could use a dynamic map to pass around
a dictionary of parameters (the \ident{lookup} function obtains a value and \ident{add} adds a new
assignment to the map). In that case, the type of \ident{add} is just $\ident{int}\rightarrow\ident{int}$
and so the user does not know which implicit parameters it will need. 

Similarly, the \ident{diff} function can be implemented in terms of lists (on the right) as
a function of type $\ident{num}~\ident{list}\rightarrow\ident{num}$. The function fails for input 
lists containing only zero or one elements and this is not reflected in the type and it is not 
enforced by the type checker.

Using coeffects (on the left), the function has a type $\ident{num}\xrightarrow{\cclrd{1}}\ident{num}$ 
meaning that it requires one past value (in addition to the current value). The safety property
for dataflow (Theorem~\ref{thm:semantics-sound-df}) shows that, when called with a context that
contains the required number of past values as captured by the coeffect type system, the function 
does not get stuck.

In summary, coeffect type system, captures certain runtime 
requirements of context-aware programs and (as we show in this chapter), eliminates common errors 
related to working with context.



% ==================================================================================================
%                
%    #######
%       #    #    # ######  ####  #####  #   #
%       #    #    # #      #    # #    #  # #
%       #    ###### #####  #    # #    #   #
%       #    #    # #      #    # #####    #
%       #    #    # #      #    # #   #    #
%       #    #    # ######  ####  #    #   #                              
%
% ==================================================================================================

\section{Categorical motivation}
\label{sec:semantics-theory}

The type system of flat coeffect calculus arises syntactically, as a generalization of the examples 
discussed in Chapter~\ref{ch:applications}, but we can also obtain it by looking at the categorical 
semantics of context-dependent computations. This is a direction that we explore in this section. 
Although the development presented here is interesting in its own, our main focus is \emph{using} 
categorical semantics to motivate and explain the translation discussed in 
Section~\ref{sec:semantics-translation}.

% --------------------------------------------------------------------------------------------------

\subsection{Comonads are to coeffects what monads are to effects}

The development in this chapter closely follows the example of effectful computations. 
Effect systems provide a type system for tracking effects and monadic translation can be used as 
a basis for implementing effectful domain-specific languages (e.g.~through the do-notation in 
Haskell). 

The correspondence between effect system and monads has been pointed out by Wadler and Thiemann 
\cite{monads-effects-marriage} and further explored by Atkey \cite{monads-parameterised-notions}
and Vazou and Leijen \cite{monads-effects-remarriage}). This line of work relates effectful 
functions $\tau_1 \xrightarrow{\sigma} \tau_2$ to monadic computations 
$\tau_1 \rightarrow \mtyp{\sigma} \tau_2$. In this chapter, we show a similar correspondence between 
\emph{coeffect systems} and \emph{comonads}. However, due to the asymmetry of $\lambda$-calculus, 
defining the semantics in terms of comonadic computations is not a simple mechanical dualisation
of the work on effect systems and monads.

Our approach is inspired by the work of Uustalu and Vene \cite{comonads-notions} who present the 
semantics of contextual computations (mainly for dataflow) in terms of comonadic functions 
$\ctyp{}\tau_1 \rightarrow \tau_2$. Our \emph{indexed comonads} annotate the structure with 
information about the required context, \ie~$\ctyp{\cclrd{r}} \tau_1 \rightarrow \tau_2$.
This is similar to the recent development on monads and effects by Katsumata \cite{monads-parametric}
who parameterizes monads in a similar way to our parameterization of comonads.

% --------------------------------------------------------------------------------------------------

\subsection{Categorical semantics}

As discussed in Section~\ref{sec:path-sem}, categorical semantics interprets terms as morphisms
in some category. For typed calculi, the semantics defined by $\sem{-}$ usually interprets typing 
judgements $x_1 \!:\! \tau_1 \ldots x_n \!:\! \tau_n \vdash e: \tau$ as morphisms 
$\sem{\tau_1 \times \ldots \times \tau_n} \rightarrow \sem{\tau}$.

As a best known example, Moggi \cite{monad-notions} showed that the semantics of various effectful 
computations can be captured uniformly using (\emph{strong}) \emph{monads}. In that 
approach, computations are interpreted as $\tau_1 \times \ldots \times \tau_n \rightarrow \mtyp{}{\tau}$
for some monad $\mtyp{}{}$. For example, $\mtyp{}{\alpha} = \alpha \cup \{ \bot \}$ models 
partiality (maybe monad), $\mtyp{}{\alpha} = \mathcal{P}(\alpha)$ models non-determinism (list 
monad) and side-effects can be modelled using $\mtyp{}{\alpha} = S \rightarrow (\alpha \times S)$ 
(state monad). Here, the structure of a strong monad provides necessary ``plumbing'' for composing 
monadic computations -- sequential composition and strength for lifting free variables into the
body of computation under a lambda abstraction.

Following similar approach to Moggi, Uustalu and Vene \cite{comonads-notions} showed that 
(\emph{monoidal}) \emph{comonads} uniformly capture the semantics of various kinds of context-dependent 
computations~\cite{comonads-notions}. For example, data-flow computations over non-empty lists
are modelled using the non-empty list comonad $\ident{NEList}\,\alpha = \alpha + (\alpha \times \ident{NEList}\,\alpha)$.

The monadic and comonadic model outlined here represents at most a binary analysis of effects or 
context-dependence. A function $\tau_1 \rightarrow \tau_2$ performs \emph{no} effects (requires no 
context) whereas $\tau_1 \rightarrow \mtyp{}{\tau_2}$ performs \emph{some} effects and
$\ctyp{}{\tau_1} \rightarrow \tau_2$ requires \emph{some} context\footnote{This is an 
over-simplification as we can use \eg~stacks of monad transformers and model functions with
two different effects using $\tau_1 \rightarrow M_1(M_2~\tau_2)$. However, monad transformers 
require defining complex system of lifting to be composable. Consequently, they are usually used
for capturing different kinds of impurities (exceptions, non-determinism, state), but not for
capturing fine-grained properties (\eg~a set of memory regions that may be accessed by a
stateful computation).}. 

In the next section, we introduce \emph{indexed comonads}, which provide a more precise analysis 
and let us model computations with context requirements $\cclrd{r}$ as functions 
$\ctyp{\cclrd{r}}{\tau_1} \rightarrow \tau_2$ using an \emph{indexed comonad} $\ctyp{\cclrd{r}}{}$.

% --------------------------------------------------------------------------------------------------

\subsection{Introducing comonads}

In category theory, \emph{comonad} is a dual of \emph{monad}. As already outlined in
Chapter~\ref{ch:pathways}, we obtain a definition of a comonad by taking a definition of a monad 
and ``reversing the arrows''. More formally, one of the equivalent definitions of comonad 
looks as follows (repeated from Section~\ref{sec:path-sem}):

\begin{definition}
A \emph{comonad} over a category $\catc$ is a triple $(C, \ident{counit}, \ident{cobind})$ where:
\begin{compactitem}
\item $C$ is a mapping on objects (types) $C : \catc \rightarrow \catc$
\item $\ident{counit}$ is a mapping $\ctyp{}{\alpha} \rightarrow \alpha$ 
\item $\ident{cobind}$ is a mapping $(\ctyp{}{\alpha} \rightarrow \beta) 
  \rightarrow (\ctyp{}{\alpha} \rightarrow \ctyp{}{\beta})$
\end{compactitem}
such that, for all $f:\ctyp{}{\alpha} \rightarrow \beta$ and $g:\ctyp{}{\beta} \rightarrow \gamma$:
\begin{align}
\tag{\emph{left identity}}
  \ident{cobind}~\ident{counit} &= \idf{}
  \\
\tag{\emph{right identity}}
  \ident{counit} \circ \ident{cobind}~f &= f
  \\
\tag{\emph{associativity}}
  \ident{cobind}~(g \circ \ident{cobind}~f) &= (\ident{cobind}~g) \circ (\ident{cobind}~f)
\end{align}
\end{definition}

\noindent
From the functional programming perspective, we can see $\ctyp{}{}$ as a parametric data type such as
\ident{NEList}. The $\ident{counit}$ operations extracts a value $\alpha$ from a value that carries 
additional context $\ctyp{}{\alpha}$. The $\ident{cobind}$ operation turns a context-dependent function 
$\ctyp{}{\alpha} \rightarrow \beta$ into a function that takes a value with context, applies
the context-dependent function to value(s) in the context and then propagates the context.

As mentioned earlier, Uustalu and Vene \cite{comonads-notions} use comonads to model data-flow
computations. They describe infinite (coinductive) streams and non-empty lists as example comonads.

\begin{example}[Non-empty list]
A non-empty list is a recursive data-type defined as $\ident{NEList}\,\alpha = \alpha + (\alpha \times \ident{NEList}\,\alpha)$.
We write \kvd{inl} and \kvd{inr} for constructors of the left and right cases, respectively. The 
type \ident{NEList} forms a comonad together with the following \ident{counit} and \ident{cobind} mappings:
%
\begin{equation*}
\begin{array}{rclll}
\ident{counit}~l &\narrow{=}& h &\quad&\textnormal{when}~l=\kvd{inl}~h\\[-0.25em]
\ident{counit}~l &\narrow{=}& h &&\textnormal{when}~l=\kvd{inr}~(h, t)\\[0.5em]
\ident{cobind}\,f~l &\narrow{=}& \kvd{inl}~(f\,l) &&\textnormal{when}~l=\kvd{inl}~h\\[-0.25em]
\ident{cobind}\,f~l &\narrow{=}& \kvd{inr}~(f\,l,\;\ident{cobind}~f~t) &&\textnormal{when}~l=\kvd{inr}~(h, t)
\end{array}
\end{equation*}
\end{example}

\noindent
The \ident{counit} operation returns the head of the non-empty list. Note that it is crucial that
the list is \emph{non-empty}, because we always need to be able to obtain a value. The \ident{cobind}
operation defined here returns a list of the same length as the original where, for each element, the 
function $f$ is applied on a \emph{suffix} list starting from the element. Using a simplified
notation for list, the result of applying \ident{cobind} to a function that sums elements of a
list gives the following behaviour:
%
\begin{equation*}
\ident{cobind}~\ident{sum}~(7,6,5,4,3,2,1,0) = (28,21,15,10,6,3,1,0)
\end{equation*}
%
The fact that the function $f$ is applied to a \emph{suffix} is important in order to satisfy the
\emph{left identity} law, which requires that $\ident{cobind}~\ident{counit}~l = l$.

It is also interesting to examine some data types that do \emph{not} form a comonad. As already
mentioned, list $\ident{List}~\alpha = 1 + (\alpha \times \ident{List}~\alpha)$ is not a comonad,
because the \ident{counit} operation is not defined for the value $\kvd{inl}~()$. The \ident{Maybe} 
data type defined as $1 + \alpha$ is not a comonad for the same reason. However, if we consider 
flat coeffect calculus for liveness, it appears natural to model computations as functions 
$\ident{Maybe}~\tau_1 \rightarrow \tau_2$. To use such a model, we need to generalise comonads 
to \emph{indexed comonads}.

% --------------------------------------------------------------------------------------------------

\subsection{Generalising to indexed comonads}
\label{sec:semantics-flat-idx}

The flat coeffect algebra includes a monoid $(\C, \cseq, \cunit)$, which defines the behaviour of
sequential composition, where the annotation $\cunit$ represents a variable access. An indexed 
comonad is formed by a data type (object mapping) $\ctyp{\cclrd{r}}{\alpha}$ where the annotation 
$\cclrd{r}$ determines what context is required. 

\begin{definition}
Given a monoid $(\C, \cseq, \cunit)$ with binary operator $\cseq$ and unit $\cunit$, an 
\emph{indexed comonad} over a category $\catc$ is a triple 
$(\ctyp{\cclrd{r}{}}, \ident{counit}_{\cunit}, \ident{cobind}_{\cclrd{r}, \cclrd{s}})$ where:

\begin{compactitem}
\item $\ctyp{\cclrd{r}}{}$ for all $\cclrd{r} \in \C$ is a family of object mappings 
\item $\ident{counit}_{\cunit}$ is a mapping $\ctyp{\cunit}{\alpha} \rightarrow \alpha$ 
\item $\ident{cobind}_{\cclrd{r}, \cclrd{s}}$ is a mapping $(\ctyp{\cclrd{r}}{\alpha} \rightarrow \beta) 
  \rightarrow (\ctyp{\cclrd{r}\cseq\cclrd{s}}{\alpha} \rightarrow \ctyp{\cclrd{s}}{\beta})$
\end{compactitem}
such that, for all $f:\ctyp{\cclrd{r}}{\alpha} \rightarrow \beta$ and $g:\ctyp{\cclrd{s}}{\beta} \rightarrow \gamma$:f
\begin{align}
\tag{\emph{left identity}}
  \ident{cobind}_{\cunit, \cclrd{s}}~\ident{counit}_{\cunit} &= \idf{}
  \\
\tag{\emph{right identity}}
  \ident{counit}_{\cunit} \circ \ident{cobind}_{\cclrd{r}, \cunit}~f &= f
  \\
\tag{\emph{associativity}}
\hspace{-10em}
  \ident{cobind}_{\cclrd{r}\cseq\cclrd{s},\cclrd{t}}~(g \circ \ident{cobind}_{\cclrd{r}, \cclrd{s}}~f) &= 
    (\ident{cobind}_{\cclrd{s}, \cclrd{t}}~g) \circ (\ident{cobind}_{\cclrd{r}, \cclrd{s}\cseq\cclrd{t}}~f)
\end{align}
\end{definition}

\noindent
Rather than defining a single mapping $\ctyp{}{}$, we are now defining a family of mappings 
$\ctyp{\cclrd{r}}{}$ indexed by a monoid structure. Similarly, the $\ident{cobind}_{\cclrd{r}, \cclrd{s}}$ 
operation is now formed by a \emph{family} of mappings for different pairs of indices 
$\cclrd{r}, \cclrd{s}$. To be fully precise, $\ident{cobind}$ is a family of natural transformations 
and we should include $\alpha, \beta$ as indices, writing $\ident{cobind}_{\cclrd{r},\cclrd{s}}^{\alpha, \beta}$.
For the purpose of this thesis, it is sufficient to omit the superscripts and treat $\ident{cobind}$ just 
as a family of mappings (rather than natural transformations). When this does not introduce ambiguity, 
we also occasionally omit the subscripts.

The $\ident{counit}$ operation is not defined for all $\cclrd{r} \in \C$, but only for 
the unit $\cunit$. We still include the unit as an index writing $\ident{counit}_{\cunit}$, 
but this is merely for symmetry and as a useful reminder to the reader. Crucially, this means that 
the operation is defined only for special contexts.

If we look at the indices in the laws, we can see that the left and right identity 
require $\cunit$ to be the unit of $\cseq$. Similarly, the associativity law implies the 
associativity of the $\cseq$ operator. 

\paragraph{Composition.}
The co-Kleisli category that models sequential composition is formed by the unit arrow (provided
by $\ident{counit}$) together with the (associative) composition operation that composes computations 
with contextual requirements as follows:
%
\begin{equation*}
\begin{array}{ccl}
\textnormal{--}\, \hat{\circ} \,\textnormal{--}&\narrow{:}& (\ctyp{\cclrd{r}}{\tau_1} \rightarrow \tau_2) 
  \rightarrow (\ctyp{\cclrd{s}}{\tau_2} \rightarrow \tau_3) 
  \rightarrow (\ctyp{\cclrd{r} \cseq \cclrd{s}}{\tau_1} \rightarrow \tau_3) \\
g \, \hat{\circ} \, f &\narrow{=}& g \circ (\ident{cobind}_{\cclrd{r}, \cclrd{s}} f)
\end{array}
\end{equation*}
%
The composition $\hat{\circ}$ best expresses the intention of indexed comonads. Given two functions
with contextual requirements $\cclrd{r}$ and $\cclrd{s}$, their composition is a function that 
requires $\cclrd{r}\,\cseq\,\cclrd{s}$. The contextual requirements propagate \emph{backwards} and
are attached to the input of the composed function.

% --------------------------------------------------------------------------------------------------

\paragraph{Examples.}

Any comonad can be turned into an indexed comonad using a trivial monoid. However, indexed comonads
are more general and can be used with other data types, including indexed \ident{Maybe}. 

\begin{example}[Comonads]
Any comonad $\ctyp{}{}$ is an indexed comonad with an index provided by a trivial monoid $(\{1\},\ast,1)$
where $1\ast 1 = 1$. The mapping $\ctyp{1}{}$ is the mapping $\ctyp{}{}$ of the underlying comonad. The
operations $\ident{counit}_1$ and $\ident{cobind}_{1,1}$ are defined by the operations $\ident{counit}$
and $\ident{cobind}$ of the comonad.
\end{example}

\begin{example}[Indexed option]
The \emph{indexed option comonad} is defined over a monoid $(\{ \ident{L},\ident{D} \}, \sqcup,\ident{L})$ 
where $\sqcup$ is defined as earlier, \ie~$\ident{L} = \cclrd{r} \sqcup \cclrd{s} \Longleftrightarrow \cclrd{r}=\cclrd{s}=\ident{L}$.
Assuming $1$ is the unit type inhabited by $()$, the mappings are defined as follows:
%
\begin{equation*}
\begin{array}{l}
\ctyp{\ident{L}}{\alpha} = \alpha\\
\ctyp{\ident{D}}{\alpha} = 1\\
\\
\ident{counit}_{\ident{L}} : \ctyp{\ident{L}}{\alpha} \rightarrow \alpha \\
\ident{counit}_{\ident{L}}~v = v\\
\end{array}
\qquad
\begin{array}{lcl}
\multicolumn{3}{l}{
  \ident{cobind}_{\cclrd{r},\cclrd{s}} ~:~ (\ctyp{\cclrd{r}}{\alpha} \rightarrow \beta) 
    \rightarrow (\ctyp{\cclrd{r}\sqcup\cclrd{s}}{\alpha} \rightarrow \ctyp{\cclrd{s}}{\beta}) }\\
\ident{cobind}_{\ident{L},\ident{L}}~f~x &\narrow{=}& f~x\\
\ident{cobind}_{\ident{L},\ident{D}}~f~() &\narrow{=}& ()\\
\ident{cobind}_{\ident{D},\ident{L}}~f~() &\narrow{=}& f~()\\
\ident{cobind}_{\ident{D},\ident{D}}~f~() &\narrow{=}& ()\\
\end{array}
\end{equation*}
\end{example}

\noindent
The \emph{indexed option comonad} models the semantics of the liveness coeffect system discussed in 
Section~\ref{sec:applications-flat-live}, where $\ctyp{\ident{L}}{\alpha} = \alpha$ models a live context 
and $\ctyp{\ident{D}}{\alpha}=1$ models a dead context which does not contain a value. The \ident{counit}
operation extracts a value from a live context. As in the direct model discussed in Chapter~\ref{ch:appendix},
the \ident{cobind} operation can be seen as an implementation of dead code elimination. The definition 
only evaluates $f$ when the result is marked as live and is thus required, and it only accesses $x$ if 
the function $f$ requires its input.

The indexed family $\ctyp{\cclrd{r}}{}$ in the above example is analogous to the \ident{Maybe}
(or option) data type $\ident{Maybe}\,\alpha = 1 + \alpha$. As mentioned earlier, this type does not 
permit (non-indexed) comonad structure, because $\ident{counit}~()$ is not defined. This is not a 
problem with indexed comonads, because live contexts are distinguished by the (type-level) coeffect 
annotation and \ident{counit} only needs to be defined on live contexts.

\begin{example}[Indexed product]
The semantics of implicit parameters is modelled by an indexed product comonad. We use a monoid
$(\mathcal{P}(\ident{Id}), \cup, \emptyset)$ where \ident{Id} is the set of (implicit parameter) names.
As previously, all parameters have the type $\rho$. The data type $\ctyp{\cclrd{r}}{\alpha}
= \alpha \times (\cclrd{r} \rightarrow \rho)$ represents a value $\alpha$ together with a function that
associates a parameter value $\rho$ with every implicit parameter name in $\cclrd{r} \subseteq \ident{Id}$.
The cobind and counit operations are defined as:
%
\begin{equation*}
\begin{array}{l}
\ident{counit}_{\emptyset} : \ctyp{\emptyset}{\alpha} \rightarrow \alpha \\[-0.25em]
\ident{counit}_{\emptyset}~(a, g) = a\\[0.5em]
\end{array}
\quad
\begin{array}{l}
\ident{cobind}_{\cclrd{r},\cclrd{s}} ~:~ (\ctyp{\cclrd{r}}{\alpha} \rightarrow \beta) 
    \rightarrow (\ctyp{\cclrd{r}\cup\cclrd{s}}{\alpha} \rightarrow \ctyp{\cclrd{s}}{\beta})\\[-0.25em]
\ident{cobind}_{\cclrd{r},\cclrd{s}}~f~(a,g) = (f(a,\restr{g}{\cclrd{r}}), \restr{g}{\cclrd{s}})\\[0.5em]
\end{array}
\end{equation*}
\end{example}

\noindent
In the definition, we use the notation $(a, g)$ for a pair containing the value of type $\alpha$
together with $g$, which is a function $\cclrd{r} \rightarrow \rho$. The \ident{counit} operation
takes a value and a function (with empty set as a domain), ignores the function and extracts the
value. The \ident{cobind} operation uses the restriction operation $\restr{g}{\cclrd{r}}$ to 
restrict the domain of $g$ to implicit parameters $\cclrd{r}$ and $\cclrd{s}$ in oder to get
implicit parameters required by the argument of $f$ and by the resulting computation, respectively
(\ie~semantically, it \emph{splits} the available context capabilities). The function $g$ passed 
to \ident{cobind} is initially defined on $\cclrd{r} \cup \cclrd{s}$ and so the restriction is 
valid in both cases.

The structure of \emph{indexed comonads} is sufficient to model sequential composition of 
computations that use a single variable (as discussed in Section~\ref{sec:path-sem}). To model 
full $\lambda$-calculus with lambda abstraction and multiple-variable contexts, we need 
additional operations introduced in the next section.

% --------------------------------------------------------------------------------------------------

\subsection{Flat indexed comonads}
\label{sec:semantics-flat-monoidal}

Because of the asymmetry of $\lambda$-calculus (discussed in Section~\ref{sec:applications-structure}),
the duality between monads and comonads can no longer help us with defining the additional structure
required to model full $\lambda$-calculus. In comonadic computations, additional information is attached
to the context. In application and lambda abstraction, the context is propagated differently than 
in effectful computations.

To model the effectful $\lambda$-calculus, Moggi~\cite{monad-notions} requires a \emph{strong} monad which
has an additional operation $\ident{strength} : \alpha\times\mtyp{}{\beta} \rightarrow \mtyp{}{(\alpha\times\beta)}$.
This allows lifting of free variables into an effectful computation. In Haskell, strength can be expressed
in the host language and so it is implicit.

To model $\lambda$-calculus with contextual properties, Uustalu and Vene \cite{comonads-notions} 
require \emph{lax semi-monoidal} comonad. This structure requires an additional monoidal operation:
%
\begin{equation*}
\ident{m} : \ctyp{}{\alpha} \times \ctyp{}{\beta} \rightarrow \ctyp{}{(\alpha \times \beta)}
\end{equation*}
%
The \ident{m} operation is needed in the semantics of lambda abstraction. It represents merging of 
contexts and is used to merge the context of the declaration site (containing free variables)
and the call site (containing bound variable). For example, for implicit parameters, this combines
the additional parameters defined in the two contexts.

The semantics of flat coeffect calculus requires operations for \emph{merging}, but also for
\emph{splitting} of contexts. 

\begin{definition}
Given a flat coeffect algebra $(\C, \cseq, \cpar, \czip, \cunit, \czero, \cleq)$,
a \emph{flat indexed comonad} is an indexed comonad over the monoid $(\C, \cseq, \cunit)$
equipped with families of operations $\ident{merge}_{\cclrd{r},\cclrd{s}}$, $\ident{split}_{\cclrd{r},\cclrd{s}}$ where:
%
\begin{compactitem}
\item $\ident{merge}_{\cclrd{r},\cclrd{s}}$ is a family of mappings
  $\ctyp{\cclrd{r}}{\alpha} \times \ctyp{\cclrd{s}}{\beta} \rightarrow \ctyp{\cclrd{r}\czip\cclrd{s}}{(\alpha \times \beta)}$
\item $\ident{split}_{\cclrd{r},\cclrd{s}}$ is a family of mappings
  $\ctyp{\cclrd{r}\cpar\cclrd{s}}{(\alpha \times \beta)} \rightarrow \ctyp{\cclrd{r}}{\alpha} \times \ctyp{\cclrd{s}}{\beta}$
\end{compactitem}
\end{definition}

\noindent
The $\ident{merge}_{\cclrd{r},\cclrd{s}}$ operation is the most interesting one. Given two comonadic
values with additional contexts specified by $\cclrd{r}$ and $\cclrd{s}$, it combines them into a 
single value with additional context $\cclrd{r}\,\czip\,\cclrd{s}$. The $\czip$ operation often represents
\emph{greatest lower bound}\footnote{The $\czip$ and $\cpar$ operations are the greatest and least upper 
bounds in the liveness and data-flow examples, but not for implicit parameters. However, they remain useful 
as an informal analogy.}, elucidating the fact that merging may result in the loss of some parts of 
the contexts $\cclrd{r}$ and $\cclrd{s}$. We look at examples of this operation in the next section.

The $\ident{split}_{\cclrd{r},\cclrd{s}}$ operation splits a single comonadic value (containing a tuple)
into two separate values. Note that this does not simply duplicate the value, because the additional
context is also split. To obtain coeffects $\cclrd{r}$ and $\cclrd{s}$, the input needs to provide 
\emph{at least} $\cclrd{r}$ and $\cclrd{s}$, so the tags are combined using the $\cpar$, which is often 
the \emph{least upper-bound}\footnotemark[1].

\paragraph{Semantics of sub-coeffecting.}
Although we do not include sub-coeffecting in the core flat coeffect calculus, it is an interesting 
extension to consider. Semantically, sub-coeffecting drops some of the available contextual 
capabilities (drops some of the implicit parameters or some of the past values). This can be
modelled by adding a (family of) lifting operation(s):
%
\begin{itemize}
 \item $\ident{lift}_{\cclrd{r'},\cclrd{r}}$ is a family of mappings
   $\ctyp{\cclrd{r'}}{\alpha} \rightarrow \ctyp{\cclrd{r}}{\alpha}$~ for all $\cclrd{r'}, \cclrd{r}$ such that $\cclrd{r}\,\cleq\,\cclrd{r'}$
\end{itemize}
%
Although we do not demand this as a general law, in all our systems, it is the case that
$\cclrd{r} \;\cleq\; \cclrd{r}\,\cpar\,\cclrd{s}$ and $\cclrd{s} \;\cleq\; \cclrd{r}\,\cpar\,\cclrd{s}$.
This special case allows a simpler definition of \emph{indexed flat comonad} by expressing the 
\ident{split} operation in terms of lifting (sub-coeffecting) as follows:
%
\begin{equation*}
\begin{array}{rcl}
\ident{map}_{\cclrd{r}}~f &\narrow{=}& \ident{cobind}_{\cclrd{r}, \cclrd{r}}~(f\circ\ident{counit}_{\cunit}) \\
\ident{split}_{\cclrd{r}, \cclrd{s}}~c &\narrow{=}&
  ( \ident{map}_{\cclrd{r}}~\ident{fst}~(\ident{lift}_{\cclrd{r}\cpar\cclrd{s}, \cclrd{r}}~c), 
    \ident{map}_{\cclrd{s}}~\ident{snd}~(\ident{lift}_{\cclrd{r}\cpar\cclrd{s}, \cclrd{s}}~c) )
\end{array}
\end{equation*}
%
The $\ident{map}_{\cclrd{r}}$ operation is the mapping on arrows that corresponds to the object 
mapping $\ctyp{\cclrd{r}}{}$. The definition is dual to the standard definition of \ident{map} 
for monads in terms of \ident{bind} and \ident{unit}. The functions \ident{fst} and \ident{snd}
are first and second projections from a two-element pair. To define the 
$\ident{split}_{\cclrd{r}, \cclrd{s}}$ operation, we use the argument $c$ twice, use lifting
to throw away additional parts of the context and then transform the values in the 
context.

This alternative is valid for our examples, but we do not use it for three reasons. First, it
requires making sub-coeffecting a part of the core definition. Second, this would be the only 
place where our semantics uses a variable \emph{twice} (in this case $c$). Thus using an explicit 
\ident{split} means that the structure required by our semantics does not need to provide variable 
duplication and our model could be embedded in linear or affine category. Finally, explicit 
\ident{split} is similar to the definition that is needed for structural coeffects in 
Chapter~\ref{ch:structural} and it makes the connection between the two easier to see.

\paragraph{Examples.}
All the examples of \emph{indexed comonads} discussed in Section~\ref{sec:semantics-flat-idx} can
be extended into \emph{flat indexed comonads}. Note that this is not true \emph{in general}, 
because each example requires us to define additional operations, specific for the example.

\begin{example}[Monoidal comonads]
Just like indexed comonads generalise co\-monads, the additional structure of
flat indexed comonads generalises symmetric semimonoidal comonads of Uustalu 
and Vene \cite{comonads-notions}. The flat coeffect algebra is defined as $(\{1\}, \ast, \ast, \ast, 1, 1, =)$
where $1\ast1=1$ and $1=1$. The additional operation $\ident{merge}_{1,1}$ is provided by the 
monoidal operation called \ident{m} by Uustalu and Vene. The $\ident{split}_{1,1}$ operation 
is defined by duplication.
\end{example}

\begin{example}[Indexed option]
Flat coeffect algebra for liveness defines $\cpar$ and $\czip$ as $\sqcup$ and $\sqcap$, respectively 
and specifies that $\ident{D} \sqsubseteq \ident{L}$. Recall also that the object mapping is defined 
as $\ctyp{\ident{L}}{\alpha} = \alpha$ and $\ctyp{\ident{D}}{\alpha} = 1$. The additional operations 
of a flat indexed comonad are defined as follows:
%
\begin{equation*}
\begin{array}{rcl}
\ident{merge}_{\ident{L}, \ident{L}}~(a, b) &\narrow{=}& (a, b)\\
\ident{merge}_{\ident{L}, \ident{D}}~(a, ()) &\narrow{=}& ()\\
\ident{merge}_{\ident{D}, \ident{L}}~((), b) &\narrow{=}& ()\\
\ident{merge}_{\ident{D}, \ident{D}}~((), ()) &\narrow{=}& ()\\
\end{array}
\qquad
\begin{array}{rcl}
\ident{split}_{\ident{L}, \ident{L}}~(a, b) &\narrow{=}& (a, b)\\
\ident{split}_{\ident{L}, \ident{D}}~(a, b) &\narrow{=}& (a, ())\\
\ident{split}_{\ident{D}, \ident{L}}~(a, b) &\narrow{=}& ((), b)\\
\ident{split}_{\ident{D}, \ident{D}}~() &\narrow{=}& ((), ()))\\
\end{array}
\end{equation*}
\end{example}

\noindent
Without the indexing, the \ident{merge} operations implements \emph{zip} on option values,
returning an option only when both values are present. The behaviour of the \ident{split} 
operation is partly determined by the indices. When the input is \emph{dead}, both values have 
to be dead (this is also the only solution of $\cclrd{\ident{D}} =\cclrd{r}\sqcap\cclrd{s}$), but when
the input is \emph{live}, the operation can perform implicit sub-coeffecting and drop one of
the values.

\begin{example}[Indexed product]
For implicit parameters, both $\czip$ and $\cpar$ are the $\cup$ operation and the relation
$\cleq$ is formed by the subset relation $\subseteq$. Recall that the data type $\ctyp{\cclrd{r}}{\alpha}$
is $\alpha \times (\cclrd{r} \rightarrow \rho)$ where $\rho$ is the type of implicit parameter values.
The additional operations are defined as:
%
\begin{equation*}
\begin{array}{rcl}
\ident{split}_{\cclrd{r}, \cclrd{s}}~((a,b), g) &\narrow{=}& ((a, \restr{g}{\cclrd{r}}), (b, \restr{g}{\cclrd{s}}))\\
\ident{merge}_{\cclrd{r}, \cclrd{s}}~((a, f), (b, g)) &\narrow{=}& ((a, b), f \uplus g)\\
\end{array}
\quad
\begin{array}{l}
\textnormal{where}~f \uplus g = \\[-0.25em]
\quad\restr{f}{\, \textit{dom}(f) \setminus \textit{dom}(g)} \cup g 
\end{array}
\end{equation*}
\end{example}

\noindent
The \ident{split} operation splits the tuple and restricts the function (representing available
implicit parameters) to the required sub-sets. The \ident{merge} operation is more 
interesting. It uses the $\uplus$ operation that we defined when introducing implicit parameters
in Section~\ref{sec:applications-flat-impl}. It merges the values, preferring the definitions from
the right-hand side (call site) over left-hand side (declaration site). Thus the operation is not
symmetric.

\begin{example}[Indexed list]
Our last example provides the semantics of data-flow computations. The flat coeffect algebra 
is formed by $(\mathbb{N}, +, \mathit{max}, \mathit{min}, 0, 0, \leq)$. In a 
non-indexed version, the semantics is provided by a non-empty list. In the indexed semantics,
the index represents the number of available past values. The data type is then a pair of 
the current value, followed by $n$ past values. The mappings that form the flat indexed comonad 
are defined as follows:
%
\begin{equation*}
\begin{array}{l}
\ident{counit}_{0}\langle a_0 \rangle = a_0
\\[0.45em]
\ident{cobind}_{m, n}~f \langle a_0, \ldots a_{m+n} \rangle = \\[-0.25em]
\quad \langle f \langle a_0, \ldots, a_m \rangle, \ldots, f \langle a_{n}, \ldots, a_{m+n} \rangle \rangle
\\[0.45em]
\ident{merge}_{m, n} (\langle a_0, \ldots, a_m \rangle, \langle b_0, \ldots, b_n\rangle) = \\[-0.25em]
\quad \langle (a_0, b_0), \ldots, (a_{\mathit{min}(m,n)}, b_{\mathit{min}(m,n)}) \rangle
\\[0.45em]
\ident{split}_{m, n} \langle (a_0, b_0), \ldots, (a_{\mathit{max}(m,n)}, b_{\mathit{max}(m,n)}) \rangle = \\[-0.25em]
\quad (\langle a_0, \ldots, a_m \rangle, \langle b_0, \ldots, b_n\rangle)
\end{array}
\begin{array}{l}
\hspace{-2em}\ctyp{n}{\alpha} = \underbrace{\alpha \times \ldots \times \alpha}_{(n+1)-\textnormal{times}}\\[11em]
~\\
\end{array}
\end{equation*}
\end{example}

\noindent
The reader is invited to check that the number of required past elements in each of the mappings
matches the number specified by the indices. The index specifies the number of \emph{past} elements
and so the list always contains at least one value. Thus \ident{counit} returns the element of a
singleton list.

The $\ident{cobind}_{m,n}$ operation requires $m + n$ elements in order to generate $n$ past results 
of the $f$ function, which itself requires $m$ past values. When combining two lists, 
$\ident{merge}_{m,n}$ behaves as \emph{zip} and produces a list that has the length of the shorter 
argument. When splitting a list, $\ident{split}_{m, n}$ needs the maximum of the required lengths. 
Finally, the lifting operation just drops some number of elements from a list.

~

~

~

% --------------------------------------------------------------------------------------------------

\begin{figure*}[t]
The semantics is defined over a typing derivation:
%  
\begin{equation*}
\hspace{-3em}
\begin{array}{ll}
\hspace{4.8em}\semdef
  {\coctx{\Gamma}{\cunit} \vdash x_i : \tau_i }
  {\pi_i \circ \ident{counit}_{\cunit}} 
& (\emph{var})
\\[1em]
\hspace{5.3em}\semdef
  {\coctx{\Gamma}{\czero} \vdash n : \ident{num} }
  {\ident{const}~n} 
& (\emph{const})
\\[1.5em]
\hspace{1.5em}\semdeff
  {\coctx{\Gamma, x:\tau_1}{\cclrd{r}\;\czip\;\cclrd{s}} \vdash e : \tau_2}
  {\coctx{\Gamma}{\cclrd{r}} \vdash \lambda x.e : \tau_1 \xrightarrow{\cclrd{s}} \tau_2 }
  {f}
  {f \circ \ident{curry}~\ident{merge}_{\cclrd{r}, \cclrd{s}} }
& (\emph{abs})
\\[2em]
\semdefff
  {\coctx{\Gamma}{\cclrd{r}} \vdash e_1 : \tau_1 \xrightarrow{\cclrd{t}} \tau_2}
  {\coctx{\Gamma}{\cclrd{s}} \vdash e_2 : \tau_1 }
  {\begin{array}\coctx{\Gamma}{\cclrd{r} \;\cpar\; (\cclrd{s} \,\cseq\, \cclrd{t})} \vdash e_1~e_2 : \tau_2\\[-0.3em]~\end{array}}
  {f}
  {g}
  {\begin{array}{l}  
  \ident{app}~\circ~f\hspace{-0.15em}\times\hspace{-0.15em}(\ident{cobind}_{\cclrd{s}, \cclrd{t}}~g)~\circ~\ident{split}_{\cclrd{r}, \cclrd{s} \,\cseq\, \cclrd{t}} \\[-0.3em]
  ~~\circ~\ident{map}_{\cclrd{r} \;\cpar\; (\cclrd{s} \,\cseq\, \cclrd{t})}~\ident{dup}\\[-0.3em]
  \end{array} }   
& (\emph{app})
\end{array}
\end{equation*}

~

Assuming the following auxiliary operations:
%
\begin{equation*}
\begin{array}{rcl}
  \ident{const}~v &=& \lambda x.v \\[-0.3em]
  \ident{curry}~f~x~y &=& \lambda f.\lambda x.\lambda y.f~(x, y)\\[-0.3em]
  \ident{dup}~x &=& (x, x)\\[-0.3em]
  f \times g &=& \lambda (x, y).(f~x, g~y)\\[-0.3em]
  \ident{app}~f~x &=& f~x
\end{array}
\end{equation*}
  

\figcaption{Categorical semantics of the flat coeffect calculus}
\label{fig:flat-semantics}
\end{figure*}

% --------------------------------------------------------------------------------------------------

\subsection{Semantics of flat calculus}
\label{sec:semantics-flat-calculus}

In Section~\ref{sec:applications-flat}, we defined the semantics of concrete (flat) context-dependent
computations including implicit parameters, liveness and data-flow. Using the \emph{flat indexed 
comonad} structure, we can now define a single uniform semantics that is capable of capturing all 
our examples, as well as other computations that can be modelled by the structure.

As discussed in Section~\ref{sec:flat-unique}, different typing derivations of coeffect programs 
may have different meaning (\eg~when working with implicit parameters) and so the semantics is
defined over a \emph{typing derivation} rather than over an \emph{term}. To assign a 
semantics to a term, we choose its unique coeffect-specific typing derivation as defined in 
Section~\ref{sec:flat-unique}.

\paragraph{Contexts and functions.}
The modelling of contexts and functions generalizes the earlier concrete examples. We use the 
family of mappings $\ctyp{\cclrd{r}}{}$ as an (indexed) data-type that wraps the product of 
free variables of the context and the arguments of functions:
%
\begin{equation*}
\begin{array}{rcl}
\sem{\coctx{x_1\!:\!\tau_1, \ldots, x_n\!:\!\tau_n}{ \cclrd{r} } \vdash e : \tau} 
  &:& \ctyp{\cclrd{r}}{(\tau_1 \times \ldots \times \tau_n)} \rightarrow \tau\\
\sem{\tau_1 \xrightarrow{\cclrd{r}} \tau_2} &=& \ctyp{\cclrd{r}}{\tau_1} \rightarrow \tau_2
\end{array}
\end{equation*}

\paragraph{Expressions.}
The definition of the semantics is shown in Figure~\ref{fig:flat-semantics}. For readability, we 
write the definitions in a simple programming language notation as opposed to the point-free 
categorical style. However, it can be equally written using just the operations of flat indexed 
comonad together with $i^{th}$ projection from a tuple represented by $\pi_i$, \emph{curry} and 
\emph{uncurry}, function composition, value duplication ($\Delta : A \rightarrow A \times A$) and 
function pairing (given $f:A\rightarrow B$ and $g:C\rightarrow D$ then $f\times g : A\times C \rightarrow B \times D$). 
These operations can be provided by \eg~a Cartesian-closed category.

The semantics of variable access and abstraction are the same as in the semantics of Uustalu and 
Vene \cite{comonads-notions}, modulo the indexing. The semantics of variable access (\emph{var}) uses 
$\ident{counit}_{\cunit}$ to extract product of free-variables from the context and then projection
$\pi_i$ to obtain the variable value. Abstraction (\emph{abs}) takes the context $\ctx$ and function argument 
$v$ and merges their additional contexts using $\ident{merge}_{\cclrd{r}, \cclrd{s}}$. Assuming
the context $\Gamma$ contains variables of types $\sigma_1, \ldots, \sigma_n$, this gives us a 
value $\ctyp{\cclrd{r}\czip\cclrd{s}}((\sigma_1 \times \ldots \times \sigma_n) \times \tau_1)$.
Assuming that $n$-element tuples are associated to the left, the wrapped context is equivalent to
$\sigma_1 \times \ldots \times \sigma_n \times \tau_1$, which can then be passed to the body of the
function.

The semantics of application is more complex. It first duplicates the free-variable product inside the 
context (using $\ident{map}_{\cclrd{r}}$ and duplication). Then it splits this context using 
$\ident{split}_{\cclrd{r}, \cclrd{s} \cpar \cclrd{t}}$. The two contexts contain the same variables
(as required by sub-expressions $e_1$ and $e_2$), but different coeffect annotations. The first
context (with index $\cclrd{r}$) is used to evaluate $e_1$, resulting in a function 
$\ctyp{\cclrd{t}}{\tau_1} \rightarrow \tau_2$. To obtain the result, we compose this with a function
created by applying $\ident{cobind}_{\cclrd{s}, \cclrd{t}}$ on the semantics of sub-expression
$e_2$, which is of type $\ctyp{\cclrd{s}\cseq\cclrd{t}}{\sigma_1 \times \ldots \times \sigma_n}
\rightarrow \ctyp{\cclrd{t}}{\tau_1}$.

Finally, constants (\emph{const}) are modelled by a global dictionary $\delta$ and sub-coeffecting
is interpreted by dropping additional context from the provided context $\ctx$ using 
$\ident{lift}_{\cclrd{r}, \cclrd{r'}}$ and providing it to the semantics of the assumption.

\paragraph{Properties.}

The categorical semantics can be used to embed context-dependent computations in functional 
programming languages, similarly to how monads provide a way of embedding effectful computations.
More importantly, it also provides validation for the design of the type system developed in 
Section~\ref{sec:flat-calculus-types}. As stated in the following theorem, the annotations in 
the type system match those of the semantic functions.

\vspace{2em}

\begin{theorem}[Correspondence]
\label{thm:flat-correspondence}
In all of the typing rules of the flat coeffect system, the context annotations $\cclrd{r}$ of typing 
judgements $\coctx{\Gamma}{\cclrd{r}} \vdash e : \tau$ and function types $\tau_1 \xrightarrow{\cclrd{r}} \tau_2$ 
correspond to the indices of mappings $\ctyp{\cclrd{r}}{}$ in the corresponding semantic function defined 
by $\sem{\coctx{\Gamma}{\cclrd{r}} \vdash e : \tau}$.
\end{theorem}
\begin{proof}
By analysis of the semantic rules in Figure~\ref{fig:flat-semantics}.
\end{proof}

\begin{theorem}[Generalization]
\label{thm:flat-generalization}
The semantics is the same as the concrete one from Chapter~\ref{ch:applications}
\end{theorem}
\begin{proof}
It is really boring.
\end{proof}

\noindent
Thanks to indexing, the statement of the theorem is significantly stronger than for a 
non-indexed system, because it provides the justification for our choice of indices in the typing
rules. In particular, we can see that the annotations follow from the annotations on primitive 
functions that define the semantics. Also, each function defining the semantics uses a distinct 
operation of the coeffect algebra and so the type system is the most general possible definition
(within the comonadic framework we use).

Although the notion of indexed comonads presented in this section is novel and interesting 
in its own, the main reason for introducing it is to motivate the flat coeffect type system.
This is captured by the Theorem~\ref{thm:flat-correspondence}. In the next section, we shift our
focus from (categorical) semantics to syntactic properties of the calculus.


% --------------------------------------------------------------------------------------------------

\subsection{Comonadic translation}

The previous chapter gives the semantics of coeffect calculus in terms of indexed comonads. In this
chapter, we follow the example of effects and monads and we use the semantics to define a 
\emph{translation}.

A context-aware \emph{source} program written using a concrete context-aware domain-specific 
language (capturing dataflow, implicit parameters or other kinds of context awareness) with
domain-specific language extensions (the \kvd{prev} keyword, or the \ident{?impl} syntax)
is translated to a \emph{target} langauge that is not context-aware. The target language is
a small functional language consisting of:
%
\begin{itemize}
  \item Simple functional subset formed by lambda calculus with tuples and numbers.
  \item Comonadically-inspired primitives corresponding to \emph{counit}, \emph{cobind} and
    other operations of flat indexed comonads.
  \item Additional primitives that model contextual operations of each concrete coeffect language
    (\emph{prev} for the \kvd{prev} keyword, \emph{lookup} for the \ident{?impl} syntax etc.)
\end{itemize}
%
The syntx, typing and reduction rules of the first part (simple functional language) are used by 
all concrete coeffect domain-specific langauges. The syntax and typing rules of the second part 
(comonadically-inspired) primitives are also shared by all coeffect DSLs, however the \emph{reduction
rules} for the comonadically-inspired primitives differ -- they capture the concrete notion of
context. Finally, the third part (domain-specific primitives) will differ for each coeffect DSL.


% --------------------------------------------------------------------------------------------------

\begin{figure}[t]
\paragraph{Language syntax}  
\begin{equation*}
\begin{array}{rcl}
  v &  = & n \sep \lambda x.e \sep (v_1, \ldots, v_n) \\
  e &  = & x \sep n \sep \pi_i~e \sep (e_1, \ldots, e_n) \sep e_1~e_2 \sep \lambda x.e \\
  \tau &  = & \ident{num} \sep \tau_1 \times \ldots \times \tau_n \sep \tau_1 \rightarrow \tau_2 \\
  C  & = & (v_1, \ldots, v_{i-1}, \_, e_{i+1}, \ldots e_n) \sep v~\_ \sep \_~e \sep \pi_i~\_ 
  
\end{array}
\end{equation*}

~
\paragraph{Reduction rules}
\begin{equation*}
\begin{array}{rll}
  \footnotesize{(\emph{fn})}  & (\lambda x.e)~v \rightarrow e[x\leftarrow v] \\[0.25em]
  \footnotesize{(\emph{prj})} & \pi_i (v_1, \ldots, v_n) \rightarrow v_i\\[0.25em]
  \footnotesize{(\emph{ctx})}  & C[e] \rightarrow C[e']  & (\textnormal{when}~e\rightarrow e')\\[0.25em]
\end{array}
\end{equation*}

\caption{Common syntax and reduction rules of the target langauge}
\label{fig:semantics-target}
\end{figure}

% --------------------------------------------------------------------------------------------------

\section{Translation}
\label{sec:semantics-translation}

\subsection{Target langauge}

The target langauge for the translation is a simply typed lambda calculus with numbers and tuples.
The translation uses tuples as it keeps a tuple with variable assignments (encoding those without 
tuples would be possible, but cumbersome) and we add numbers as a basic concrete data type.
In this section, we define the common parts of the language without the comonadically-inspired
primitives.

The syntax of the target programming langauge is shown in Figure~\ref{fig:transl-target}. 
The values include numbers $n$, tuples and function values.
The expressions include variables $x$, values, lambda abstraction and application and operations 
on tuples. We do not need recursion (although a realistic programming language would include it). 
In what follows, we also use the following syntactic sugar for let binding:
%
\begin{equation*}
\begin{array}{rcl}
  \kvd{let}~x=e_1~\kvd{in}~e_2 &=& (\lambda x.e_2) e_1
\end{array}
\end{equation*}
%
Finally, $C[e]$ defines the context in which sub-expressions are evaluated. Together with the
evaluation rules shown in  Figure~\ref{fig:transl-target}, this captures the standard call-by-name
semantics of the common parts of the target language.
The (standard) typing rules for the common expressions of the target langauge are shown in 
Figure~\ref{fig:transl-targetty}. The rules are standard. 

% --------------------------------------------------------------------------------------------------

\begin{figure}[t]
\paragraph{Typing rules}
\begin{equation*}
\begin{array}{ll}
\tyrule{var}
  { x:\tau \in \Gamma }
  { \Gamma \vdash x:\tau }
&
\tyrule{err}
  { ~ }
  { \Gamma \vdash \ident{error}:\tau }
\\[1em]
\tyrule{str}
  { ~ }
  { \Gamma \vdash s:\ident{str} }
&
\tyrule{num}
  { ~ }
  { \Gamma \vdash n:\ident{num} }
\\[1em]
\tyrule{nil}
  { ~ }
  { \Gamma \vdash []:[\tau] }
&
\tyrule{head}
  { \Gamma \vdash e :[\tau] }
  { \Gamma \vdash \ident{head}~e:\tau }
\\[1em]
\tyrule{tail}
  { \Gamma \vdash e :[\tau] }
  { \Gamma \vdash \ident{tail}~e:[\tau] }
\qquad~&
\tyrule{abs}
  { \Gamma, x\!:\!\tau_1 \vdash e : \tau_2 }
  { \Gamma \vdash \lambda x.e : \tau_1 \rightarrow \tau_2 }
\end{array}
\end{equation*}
\begin{equation*}
\begin{array}{l}
\tyrule{app}
  { \Gamma \vdash e_1 : \tau_1 \rightarrow \tau_2  & \Gamma \vdash e_2 : \tau_1 }
  { \Gamma \vdash e_1~e_2 : \tau_2 }
\\[1.25em]
\tyrule{cons}
  { \Gamma \vdash e_1 :\tau & \Gamma \vdash e_2 : [\tau] }
  { \Gamma \vdash e_1\!::\!e_2 : [\tau] }
\\[1.25em]
\tyrule{proj}
  { \Gamma \vdash e : \tau_1 \times \ldots \tau_i \times \ldots \times \tau_n }
  { \Gamma \vdash \pi_i~e:\tau_i }
\\[1.25em]
\tyrule{tup}
  { \forall i\in\{1 \ldots n\}.~ \Gamma \vdash e_i : \tau_i }
  { \Gamma \vdash (e_1, \ldots, e_n) : \tau_1 \times \ldots \times \tau_n }
\\[1.25em]
\tyrule{ifn}
  { \Gamma \vdash e_1 : \ident{num} & \Gamma \vdash e_2 : \ident{num} &
    \Gamma \vdash e_3 : \tau & \Gamma \vdash e_4 : \tau}
  { \Gamma \vdash \kvd{if}~e_1 = e_2~\kvd{then}~e_3~\kvd{else}~e_4 : \tau}
\\[1.25em]
\tyrule{ifs}
  { \Gamma \vdash e_1 : \ident{str} & \Gamma \vdash e_2 : \ident{str} &
    \Gamma \vdash e_3 : \tau & \Gamma \vdash e_4 : \tau}
  { \Gamma \vdash \kvd{if}~e_1 = e_2~\kvd{then}~e_3~\kvd{else}~e_4 : \tau}
\end{array}
\end{equation*}

\caption{Typing rules for the common syntax of the target language}
\label{fig:semantics-targetty}
\end{figure}

% --------------------------------------------------------------------------------------------------

\subsection{Properties}

The subset of the langauge described so far models a simple ML-like functional programming 
langauge (or, Haskell-like language, if we choose call-by-name evaluation). The subset of the
langauge introduced so far satisfies the property that ``well-typed programs do not get stuck'',
i.e.~both type preservation (reduction does not change the type of an expression) and the progress 
property (an well-typed expression is either a value or can be reduced).
We first show this for the subset of the language discussed so far and later extend the proof to 
also cover the comonadically-inspired primitives that will be added in the next section.

\begin{theorem}[Type preservation]
  If $\Gamma \vdash e : \tau$ and $e \rightarrow e'$ then $\Gamma \vdash e' : \tau$
\end{theorem}
\begin{proof}
  Rule induction over $\rightarrow$.
\end{proof}

\begin{theorem}[Progress]
  If $\Gamma \vdash e : \tau$ then either $e$ is a value or there exits $e'$ such that $e \rightarrow e'$
\end{theorem}
\begin{proof}
  By rule induction over $\vdash$.
\end{proof}

% --------------------------------------------------------------------------------------------------

\subsection{Coeffect-specific extnesions}

Given a flat coeffect algebra $(\C, \cseq, \cpar, \czip, \cunit, \czero, \cleq)$ of a concrete 
coeffect domain-specific langauge, we first extend the language syntax and typing rules with 
the terms that correspond to the comonadically-inspired operations. This is done in the same way
for all concrete coeffect DSLs and so we give the additional syntax, evaluation context and 
typing rules just once in Figure~\ref{fig:transl-ext}.

The figure defines the syntax and the typing rules, but it does not define the reduction rules.
Those -- together with the values for a concrete notion of context -- will be defined separately
for each individual coeffect DSL. We first consider the DSL for dataflow programming.

% --------------------------------------------------------------------------------------------------

\begin{figure}[t]
\paragraph{Language syntax}
Given $(\C, \cseq, \cpar, \czip, \cunit, \czero, \cleq)$, extend the syntax:

\begin{equation*}
\begin{array}{rcl}
  e &  =  &\ldots \sep\ident{cobind}_{\cclrd{s},\cclrd{r}}~e_1~e_2 \sep \ident{counit}_{\cunit}~e \sep \ident{merge}_{\cclrd{r},\cclrd{s}}~e 
         \sep \ident{split}_{\cclrd{r},\cclrd{s}}~e \sep \ident{lift}_{\cclrd{r},\cclrd{r'}}~e \\
  \tau &  = &\ldots \sep \ctyp{\cclrd{r}}{\tau} \\
  C  & = &\ldots \sep \ident{cobind}_{\cclrd{s},\cclrd{r}}~\_~e \sep \ident{cobind}_{\cclrd{s},\cclrd{r}}~v~\_ \sep \ident{counit}_{\cunit}~\_ \\
    &\sep& \ident{merge}_{\cclrd{r},\cclrd{s}}~\_
           \sep \ident{split}_{\cclrd{r},\cclrd{s}}~\_ \sep \ident{lift}_{\cclrd{r},\cclrd{r'}}~\_ \\
  
\end{array}
\end{equation*}

~

~

\paragraph{Typing rules}
Given $(\C, \cseq, \cpar, \czip, \cunit, \czero, \cleq)$, add the typing rules:

\begin{equation*}
\begin{array}{l}
\tyrule{counit}
  {\Gamma \vdash e : \ctyp{\cunit}{\tau}}
  {\Gamma \vdash \ident{counit}_{\cunit}~e : \tau} \\
\\
\tyrule{cobind}
  {\Gamma \vdash e_1 : \ctyp{\cclrd{r}}{\tau_1} \rightarrow \tau_2 & \Gamma \vdash e_2 : \ctyp{\cclrd{r}\cseq\cclrd{s}}{\tau_1} }
  {\Gamma \vdash \ident{cobind}_{\cclrd{r}, \cclrd{s}}~e_1~e_2 : \ctyp{\cclrd{s}}{\tau_2}} \\
  \\
\tyrule{merge}
  {\Gamma \vdash  e : \ctyp{\cclrd{r}}{\tau_1} \times \ctyp{\cclrd{s}}{\tau_2} } 
  {\Gamma \vdash  \ident{merge}_{\cclrd{r},\cclrd{s}}~e : \ctyp{\cclrd{r}\czip\cclrd{s}}{(\tau_1 \times \tau_2)} }\\
    \\
\tyrule{split}
  {\Gamma \vdash  e : \ctyp{\cclrd{r}\cpar\cclrd{s}}{(\tau_1 \times \tau_2)} }
  {\Gamma \vdash  \ident{split}_{\cclrd{r},\cclrd{s}}~e : \ctyp{\cclrd{r}}{\tau_1} \times \ctyp{\cclrd{s}}{\tau_2}} \\
\\
\tyrule{lift}
  {\Gamma \vdash  e : \ctyp{\cclrd{r'}}{\tau} }
  {\Gamma \vdash \ident{lift}_{\cclrd{r'},\cclrd{r}}~e : \ctyp{\cclrd{r}}{\tau} } \qquad\forall \cclrd{r'},\cclrd{r}, \cclrd{r}\,\cleq\,\cclrd{r'}
\\
\end{array}
\end{equation*}

\caption{Comonadically-inspired extensions for the target langauge}
\label{fig:semantics-ext}
\end{figure}

% --------------------------------------------------------------------------------------------------

\subsection{Comonadically-inspired translation}

In Chapter 4, we presented the semantics of the flat coeffect calculus in terms of indexed comonads.
We treated the semantics as denotational -- interpreting the meaning of a given typing derivation
of a program in terms of category theory.

In this chapter, we use the same structure in a different way. Rather than treating the rules as
\emph{denotation} in categorical sense, we treat them as \emph{translation} from a source 
domain-specific coeffect language into a target language with comonadically-inspired primitives
described in the previous section.

Similarly, the interpretation of contexts and types in the category now becomes a translation from types and
contexts in the source language into the types of the target language:

\begin{equation*}
\begin{array}{rcl}
\sem{\coctx{x_1\!:\!\tau_1, \ldots, x_n\!:\!\tau_n}{\cclrd{r}}} &=& \ctyp{\cclrd{r}}{(\sem{\tau_1} \times \ldots \times \sem{\tau_n})} \\[0.5em]
\sem{\tau_1 \xrightarrow{\cclrd{r}} \tau_2} & = & \ctyp{\cclrd{r}}{\sem{\tau_1}} \rightarrow \sem{\tau_2} \\[-0.2em]
\sem{\ident{num}} & = & \ident{num} \\
\end{array}
\end{equation*}

Here, a context becomes a comonadically-inspired data type wrapping a tuple of variable values 
and a coeffectful function is translated into an ordinary function in the target language
with a comonadically-inspired data type wrapping the input type.

The rules shown in Figure~\ref{fig:transl-translation} are very similar to those shown earlier
Figure~X in Chapter~3. Thanks to the equivalence between $\lambda$-calculus and category theory,
we now interpret them as denoting a translation. Furthermore, the program produced by the above
rules is well-typed.

\begin{lemma}[Well-typedness of the translation]
Given a well-typed coeffect program $\coctx{\Gamma}{\cclrd{r}} \vdash e : \tau$ with a 
typing derivation such that:
%  
\begin{equation*}  
  \semdeff
    {(\ldots)\qquad~}
    {\coctx{\Gamma}{\cclrd{r}} \vdash e : \tau }
    {(\ldots)}
    { ~~f }
\end{equation*}  
%
Then $e$ is a valid expression in the target langauge and $\vdash f : \sem{\coctx{\Gamma}{\cclrd{r}}} \rightarrow \sem{\tau}$.
\end{lemma}
\begin{proof}
  By rule induction over the translation rules.
\end{proof}


\begin{figure*}[t]

\begin{equation*}
\hspace{-3em}
\begin{array}{ll}
\hspace{4.8em}\semdef
  {\coctx{\Gamma}{\cunit} \vdash x_i : \tau_i }
  {\lambda\ctx.\pi_i~(\ident{counit}_{\cunit}~\ctx)} 
& (\emph{var})
\\[1em]
\hspace{5.3em}\semdef
  {\coctx{\Gamma}{\czero} \vdash n : \ident{num} }
  {\lambda\ctx.n} 
& (\emph{const})
\\[1.5em]
\hspace{1.5em}\semdeff
  {\coctx{\Gamma, x:\tau_1}{\cclrd{r}\;\czip\;\cclrd{s}} \vdash e : \tau_2}
  {\coctx{\Gamma}{\cclrd{r}} \vdash \lambda x.e : \tau_1 \xrightarrow{\cclrd{s}} \tau_2 }
  {f}
  {\lambda \ctx.\lambda v.f~(\ident{merge}_{\cclrd{r}, \cclrd{s}}~(\ctx, v)) }
& (\emph{abs})
\\[2em]
\semdefff
  {\coctx{\Gamma}{\cclrd{r}} \vdash e_1 : \tau_1 \xrightarrow{\cclrd{t}} \tau_2}
  {\coctx{\Gamma}{\cclrd{s}} \vdash e_2 : \tau_1 }
  {\begin{array}\coctx{\Gamma}{\cclrd{r} \;\cpar\; (\cclrd{s} \,\cseq\, \cclrd{t})} \vdash e_1~e_2 : \tau_2\\[-0.3em]~\\[-0.3em]~\\[-0.3em]~\end{array}}
  {f}
  {g}
  {\begin{array}{l}  
  \lambda\ctx.~~\\[-0.3em]
    \quad \kvd{let}~\ctx_0 = \ident{map}_{\cclrd{r} \;\cpar\; (\cclrd{s} \,\cseq\, \cclrd{t})}~(\lambda x.(x,x))~\ctx\\[-0.3em]
    \quad \kvd{let}~(\ctx_1, \ctx_2) = \ident{split}_{\cclrd{r}, \cclrd{s} \,\cseq\, \cclrd{t}}~\ctx_0\\[-0.3em]
    \quad f~\ctx_1~
      (\ident{cobind}_{\cclrd{s}, \cclrd{t}}~g~\ctx_2)
  \end{array} }   
& (\emph{app})
\\[4em]
\hspace{6em}\semdeff
  {\coctx{\Gamma}{\cclrd{r'}} \vdash e : \tau}
  {\coctx{\Gamma}{\cclrd{r}} \vdash e : \tau } 
  {f}
  {\lambda\ctx f~(\ident{lift}_{\cclrd{r}, \cclrd{r'}}~\ctx}
\quad(\hspace{-0.7em}\textnormal{\footnotesize when}~\cclrd{r'} \leq \cclrd{r})
& (\emph{sub})\\[-0.25em]
\end{array}
\end{equation*}

\figcaption{Translation from a flat DSL to a comonadically-inspired target language}
\label{fig:semantics-translation}
\end{figure*}

% --------------------------------------------------------------------------------------------------

\section{Proofs}
\label{sec:semantics-proofs}

\subsection{Coeffect langauge for dataflow}

The types of the comonadically-inspired operations are the same for each concrete coeffect DSL, but
each DSL introduces its own \emph{values} of type $\ctyp{\cclrd{r}}\tau$ and also its own reduction
rules that define how comonadically-inspired operations evaluate.

We first consider the extensions needed for dataflow computations. As discussed earlier in the
semantics of dataflow, the indexed comonad for a context with $n$ past values carries $n+1$ 
values.

When evaluating translated programs, the comonadic values will not be directly manipulated by the
user code and so we introduce a new class of values written as $\ident{Df}\langle v_0, \ldots, v_n\rangle$. 
Furthermore, the \ident{Df} values will only appear as fully evaluated inputs and they will be manipulated 
using the comonadically-inspired operations. Thus, the typing rule (\emph{df}) only needs to 
check values. We do not need a similar rule for expressions. Construct such as $\ident{Df}\langle(\kvd{fun}~x.x)~1\rangle$ 
are not allowed in the target language. The (\emph{df}) rule also guarantees that the number of 
elements in the list matches the number in the coeffect:

\begin{equation*}
\begin{array}{l}
v = \ldots \sep \ident{Df}\langle v_0, \ldots, v_n\rangle \\
e = \ldots \sep \ident{Df}\langle v_0, \ldots, v_n\rangle \\
\end{array}  
\begin{array}{l}
\tyrule{df}
  { \forall i\in\{ 0 \ldots n \}. ~ \vdash v : \tau}
  { \Gamma \vdash \ident{Df}\langle v_0, \ldots, v_n \rangle : \ctyp{\cclrd{n}}{\tau} }
\end{array}  
\end{equation*}
~

\noindent
The additional reduction rules mirror the semantics that we discussed earlier when talking about
indexed dataflow comonad.

\begin{equation*}
\begin{array}{rl}
{\footnotesize(\emph{counit})} & \begin{array}{l}
\ident{counit}_{\cclrd{0}}(\ident{Df} \langle v_0 \rangle)   \rightarrow v_0
\end{array}
\\[0.5em]
{\footnotesize(\emph{cobind})} & \begin{array}{l}
\ident{cobind}_{\cclrd{m}, \cclrd{n}}~f (\ident{Df}\langle v_0, \ldots v_{m+n} \rangle) \rightarrow
\\[-0.25em]
\quad (\ident{Df}\langle f (\ident{Df}\langle v_0, \ldots, v_m \rangle), \ldots, f (\ident{Df}\langle v_{n}, \ldots, v_{m+n} \rangle) \rangle)
\end{array}
\\[0.5em]
{\footnotesize(\emph{merge})} & \begin{array}{l}
\ident{merge}_{\cclrd{m}, \cclrd{n}} ((\ident{Df}\langle v_0, \ldots, v_m \rangle), (\ident{Df}\langle b_0, \ldots, b_n\rangle)) \rightarrow
\\[-0.25em]
\quad (\ident{Df}\langle (v_0, b_0), \ldots, (v_{\mathit{min}(m,n)}, b_{\mathit{min}(m,n)}) \rangle)
\end{array}
\\[0.5em]
{\footnotesize(\emph{split})} & \begin{array}{l}
\ident{split}_{\cclrd{m}, \cclrd{n}} (\ident{Df}\langle (v_0, b_0), \ldots, (v_{\mathit{max}(m,n)}, b_{\mathit{max}(m,n)}) \rangle)  \rightarrow
\\[-0.25em]
\quad \ident{Df}\langle v_0, \ldots, v_m \rangle, (\ident{Df}\langle b_0, \ldots, b_n\rangle
\end{array}
\\[0.5em]
{\footnotesize(\emph{lift})} & \begin{array}{l}
\ident{lift}_{\cclrd{n'}, \cclrd{n}} (\ident{Df}\langle v_0, \ldots, v_{n'} \rangle) \rightarrow
\qquad(\textnormal{when}~n\leq n') \\[-0.25em]
\quad \ident{Df}\langle v_0, \ldots, v_n \rangle
\end{array}
\end{array}
\end{equation*}

~

\noindent
Now consider a target langauge consisting of the core (ML-subset) defined in Figure~\ref{fig:transl-target}
with typing rules defined in Figure~\ref{fig:transl-targetty} and comonadically-inspired primtiives
defined in Figure~\ref{fig:transl-ext} and also concrete notion of comonadically-inspired value
and reduction rules for data flow as defined above.


\begin{theorem}[Type preservation]
  If $\Gamma \vdash e : \tau$ and $e \rightarrow e'$ then $\Gamma \vdash e' : \tau$
\end{theorem}
\begin{proof}
As before, using rule induction over $\rightarrow$.

Interesting new cases are the reduction rules (\emph{counit}), (\emph{cobind}), (\emph{merge}),
(\emph{split}) and (\emph{lift}). We need to show that, given a well typed input value, the resulting
value is a \ident{Df} value with the right number of elements (for (\emph{cobind}), (\emph{lift}) and (\emph{merge}),
a tuple of \ident{Df} values with the right number of elements (for (\emph{split})) and a value
of correct type (for (\emph{unit})).

From the fact that the reduction occurred, we know that the input was a \ident{Df} value with the
required number of inputs and from the typing rule (\emph{df}) we know that the values in the input
were all of correct types.  
\end{proof}

\begin{theorem}[Progress]
  If $\Gamma \vdash e : \tau$ then either $e$ is a value or there exits $e'$ such that $e \rightarrow e'$
\end{theorem}
\begin{proof}
  As before, using rule induction over $\vdash$.

Interesting new cases are those arising from the typing rules for the comonadically-inspired
primitives in Figure~\ref{fig:transl-ext}, that is (\emph{counit}), (\emph{cobind}), (\emph{merge}),
(\emph{split}) and (\emph{lift}).  
In all of the cases, $e$ is not a value and so it needs to reduce and the only reduction rules
are the ones for dataflow computations (above). 

If the argument is a value, one of the reduction rules (above) can be used (the typing guarantees
that the list has the required number of elements). If the argument is an expressions, we use 
the induction hypothesis.
\end{proof}

\begin{theorem}[Soundness]
\label{thm:semantics-sound-df}  
Yo
\end{theorem}

\newpage
\section{Coeffect language for implicit parameters}

\begin{equation*}
v = \ident{Impl}(v)
\end{equation*}

a

\begin{equation*}
\tyrule{impl}
  { \Gamma \vdash v : \ident{string} \rightarrow \ident{num}}
  { a }
\end{equation*}

b



% Simple for normal parts of the language
% We have to check this for dataflow reductions  
%
% Interesting case is $e_1 e_2$ where $e_1 = v$ is one of the primitives. Then we have to go through
% them and make sure they can progress.  

% And also syntactic sugar \ident{map} 


%    &\sep& \ident{cobind}_{\cclrd{s},\cclrd{r}}~e_1~e_2 \sep \ident{counit}_{\cunit}~e \sep \ident{merge}_{\cclrd{r},\cclrd{s}}~e 
%       \sep \ident{split}_{\cclrd{r},\cclrd{s}}~e \sep \ident{lift}_{\cclrd{r},\cclrd{r'}}~e \\

%
% &\sep& \ident{cobind}_{\cclrd{s},\aclrd{\textbf{r}}}~e_1~e_2 \sep \ident{counit}_{\cunit}~e \sep \ident{merge}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}~e 
%   \sep \ident{split}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}~e \sep \ident{lift}_{\cclrd{r},\cclrd{r'}}~e \sep \ident{dup}_{\cclrd{r},\cclrd{s}}~e \\

\section{Dataflow}
Domain specific coeffect annotations are non-negative integers, type is a tuple and new kinds
of values are lists:
\begin{equation*}
\begin{array}{rcl}
  v_c &  = &  \langle v_1, \ldots, v_n \rangle
\end{array}
\end{equation*}
%
With the following typing:
%
\begin{equation*}  
\tyrule{val}
  { \forall v_i . \vdash v_i : \tau }
  { \vdash \langle v_1, \ldots, v_n \rangle : \ctyp{n}{\tau} }
\end{equation*}
%


We could define those in terms of head/tail functions and then prove that they work (and translated
program does not contain head/tail), but perhaps that's unnecessary overkill. Or perhaps it would
be useful in order to show how we avoid errors... But doing it directly looks just simpler (we
also do not need a ``list'' type).

\begin{theorem}[Type preservation]
  If $\Gamma \vdash e : \tau$ and $e \rightarrow e'$ then $\Gamma \vdash e' : \tau$
\end{theorem}
\begin{proof}
  Rule induction over $\rightarrow$
  
Simple for normal parts of the language

We have to check this for dataflow reductions  
\end{proof}

\begin{theorem}[Progress]
  If $\Gamma \vdash e : \tau$ then either $e$ is a value or there exits $e'$ such that $e \rightarrow e'$
\end{theorem}
\begin{proof}
  By rule induction over $\vdash$.
  
Interesting case is $e_1 e_2$ where $e_1 = v$ is one of the primitives. Then we have to go through
them and make sure they can progress.  
\end{proof}


\begin{theorem}[Soundness]
\label{thm:semantics-sound-impl}  
Yo
\end{theorem}


















\newpage
\newpage


% ==================================================================================================
%                                                 
%      ####           ##            #                # 
%      #   #           #            #                # 
%      #   #   ###     #     ###   ####    ###    ## # 
%      ####   #   #    #        #   #     #   #  #  ## 
%      # #    #####    #     ####   #     #####  #   # 
%      #  #   #        #    #   #   #  #  #      #  ## 
%      #   #   ###    ###    ####    ##    ###    ## # 
%
% ==================================================================================================

\section{Related and futrue work}
\label{sec:semantics-related}

Most of the related work leading to coeffects has already been discussed in Chapter~\ref{ch:pathways} 
and we covered work related to individual concepts throughout the chapter. In this section, we
do not repeat the discussion present elsewhere. Instead, we discuss one specific question that often 
arises when discussing coeffects and that is \emph{when is a coeffect (not) an effect?}

We start with a quick overview of the ways in which effects and coeffects differ and then
we briefly look at one (but illustrative) example where the two concepts overlap. We focus 
mainly on the equivalence between the \emph{categorical semantics}, which reveals the nature
of the computations -- rather than considering just the syntactic aspects of the type system.

\subsection{Generalising}
... works for any good comonad...


\subsection{Properties and related notions}

The flat indexed comonad structure is all we need to give the semantics of the flat coeffect 
calculus. Before doing so in Section~\ref{sec:flat-semantics-calculus}, we briefly consider 
additional properties and other categorical structures that have been proposed mainly in the 
context of monads and effects and we look how they relate to indexed comonads.

\paragraph{Shape preservation.}
Ordinary comonads have the \emph{shape preservation} property \cite{comonads-codo}. Intuitively, 
this means that the core comonad structure does not provide a way of modeling computations where
the additional context changes during the computation. For example, in the \ident{NEList} comonad, 
the length of the list stays the same after applying \ident{cobind}.

~

Indexed comonads are not restricted by this property of comonads. For example, given the indexed
product comonad, in the computation $\ident{cobind}_{\cclrd{r}, \cclrd{s}} f$, the shape of
the context changes from providing implicit parameters $\cclrd{r} \cup \cclrd{s}$  to providing
just implicit parameters $\cclrd{s}$.

\paragraph{Families of monads.}
When linking effect systems and monads, Wadler and Thiemann \cite{monad-notions} propose a
\emph{family of monads} as the categorical structure. The dual structure, \emph{family of
comonads}, is defined as follows.

\begin{definition}
\label{def:flat-family}
A \emph{family of comonads} is formed by triples $(\ctyp{\cclrd{r}}{}, \ident{cobind}_{\cclrd{r}}, 
  \ident{counit}_{\cclrd{r}})$ for all $\cclrd{r}$ such that each triple forms a comonad. Given 
$\cclrd{r}, \cclrd{r'}$ such that $\cclrd{r} \leq \cclrd{r'}$, there is also a mapping 
$\iota_{\cclrd{r'}, \cclrd{r}} : \ctyp{\cclrd{r'}}{} \rightarrow \ctyp{\cclrd{r}}{}$ satisfying
certain coherence conditions.
\end{definition}

\noindent
A \emph{family of comonads} is more restrictive than an \emph{indexed comonad}, because each of the data 
types needs to form a comonad separately. For example, our indexed option does not form a family of 
comonads (again, because \ident{counit} is not defined on $\ctyp{\ident{D}}{\alpha}=1$). However, given 
a family of comonads and indices such that $\cclrd{r} \leq \cclrd{r}\cseq\cclrd{s}$, we can define 
an indexed comonad. Briefly, to define $\ident{cobind}_{\cclrd{r},\cclrd{s}}$ of an indexed comonad, 
we use $\ident{cobind}_{\cclrd{r}\cseq\cclrd{s}}$ from the family, together with two lifting operations:
$\iota_{\cclrd{r}\cseq\cclrd{s}, \cclrd{r}}$ and $\iota_{\cclrd{r}\cseq\cclrd{s}, \cclrd{s}}$.

\paragraph{Parameteric effect monads.}
Parametric effect monads introduced by Katsumata \cite{monads-parametric} (independently to our 
indexed comonads) are closely related to our definition.  Although presented in a more general 
categorical framework (and using monads), the model defines the \ident{unit} operation only on the 
unit of a monoid and the \ident{bind} operation composes effect annotations using the provided monoidal 
structure.

\subsection{When is coeffect not a monad}
Coeffect systems differ from effect systems in three important ways:

\begin{itemize}
\item Semantically, coeffects capture different notions of computation. As demonstrated in 
  Chapter~\ref{ch:pathways}, coeffects track additional contextual properties required by a
  computation, many of which cannot be captured by a monad (\eg~liveness or data-flow).

\item Syntactically, coeffect calculi use a richer algebraic structure with pointwise composition,
  sequential composition and context merging ($\cpar, \cseq$, and $\czip$) while most effect systems
  only use a single operation for sequential composition (used by monadic bind).

\item Syntactically, the second difference is in the lambda abstraction (\emph{abs}). In 
  coeffect systems, the context requirements of the body can be split between (or duplicated
  at) declaration site and call site, while monadic effect systems always defer all effects.
\end{itemize}

\noindent
Despite the differences, our implicit parameters example can be also represented by a monad.
Semantically, the \emph{reader} monad is equivalent to the \emph{product} comonad. Syntactically,
we use the $\cup$ operation for all three operations of the coeffect algebra. However, to enable
splitting of implicit parameter requirements using the reader monad, we need to extend the 
monad structure and change the translation of monadic lambda abstraction.

% -------------------------------------------------------------------------------------------------

\subsection{When is coeffect a monad}
\label{sec:semantics-related-monads}

Implicit parameters can be captured by a monad, but \emph{just} a monad is not enough.
Lambda abstraction in effect systems does not provide a way of splitting the context
requirements between declaration site and call site (or, semantically, combining the implicit 
parameters available in the scope where the function is defined and those specified by the caller).

\paragraph{Categorical relationship.}
Before looking at the necessary extensions, consider the two ways of modelling implicit 
parameters. We assume that the function $\cclrd{r} \rightarrow \sigma$ is a lookup function
for reading implicit parameter values that is defined on a set $\cclrd{r}$. The two definitions
are:
%
\begin{equation*}
\begin{array}{lll}
 \ctyp{\cclrd{r}}\tau = \tau \times (\cclrd{r} \rightarrow \sigma) &~\hspace{10em}~& (\emph{product comonad}) \\
 \mtyp{\cclrd{r}}\tau = (\cclrd{r} \rightarrow \sigma) \rightarrow \tau && (\emph{reader monad})
\end{array} 
\end{equation*}
%
The \emph{product comonad} simply pairs the value $\tau$ with the lookup function, while
the \emph{reader monad} is a function that, given a lookup function, produces a $\tau$ value.
As noted by Orchard \cite{comonads-vs-monads}, when used to model computation semantics, the 
two representations are equivalent:
%
\begin{remark}
Computations modelled as $\ctyp{\cclrd{r}}{\tau_1}\rightarrow\tau_2$ using the product comonad
are isomorphic to computations modelled as $\tau_1\rightarrow\mtyp{\cclrd{r}}{\tau_2}$ using the
reader monad via currying/uncurrying isomorphism.
\end{remark}
\begin{proof}
The isomorphism is demonstrated by the following equation:
\begin{equation*}
\begin{array}{lll}
 \ctyp{\cclrd{r}}{\tau_1} \rightarrow \tau_2 &\narrow{=}&
 (\tau_1 \times (\cclrd{r} \rightarrow \sigma)) \rightarrow \tau_2 \\
 &\narrow{=}& \tau_1 \rightarrow ((\cclrd{r} \rightarrow \sigma) \rightarrow \tau_2) =
 \tau_1 \rightarrow \mtyp{\cclrd{r}}{\tau_2} \hspace{23em}\qedhere \\
\end{array}
\end{equation*}
\end{proof}

\noindent
This equivalence holds for monads and comonads (as well as \emph{indexed} monads
and comonads), but it does not extend to \emph{flat} indexed comonads which also provide
the $\ident{merge}_{\cclrd{r}, \cclrd{s}}$ operation to model context merging.

\paragraph{Delaying effects in monads.} 
In the syntax of the language, the above difference is manifested by the (\emph{abs}) rules for 
monadic effect systems and comonadic coeffect systems. The following listing shows the two rules 
side-by-side, using the effect system notation for both of them:
%
\begin{equation*}
\tyrule{cabs}
  { \Gamma, x\!:\!\tau_1 \vdash e : \tau_2 \;\&\; \cclrd{r}\,\cclrd{\cup}\,\cclrd{s} }
  { \Gamma \vdash \lambda x.e : \tau_1 \xrightarrow{\cclrd{s}} \tau_2 \;\&\; \cclrd{r}}
\quad
\tyrule{mabs}
  { \Gamma, x\!:\!\tau_1 \vdash e : \tau_2 \;\&\; \cclrd{r}\,\cclrd{\cup}\,\cclrd{s}}
  { \Gamma \vdash \lambda x.e : \tau_1 \xrightarrow{\cclrd{r}\,\cclrd{\cup}\,\cclrd{s}} \tau_2 \;\&\; \cclrd{\emptyset} }
\qquad
\end{equation*}
%
In the comonadic (\emph{cabs}) rule, the implicit parameters of the body are split. However,
the monadic rule (\emph{mabs}) places all requirements on the call site. This follows from the
fact that monadic semantics uses the \ident{unit} operation in the interpretation of lambda abstraction:
%
\begin{equation*}
\sem{\lambda x.e} \;=\; \ident{unit}~(\lambda x. \sem{e})
\end{equation*}
%
The type of $\ident{unit}$ is $\alpha\rightarrow\mtyp{\alpha}{\cclrd{\emptyset}}$, but in this specific
case, the $\alpha$ is instantiated to be $\tau_1\rightarrow\mtyp{\cclrd{r \cup s}}{\tau_2}$ and so this
use of \ident{unit} has a type:
%
\begin{equation*}
\ident{unit}~:~(\tau_1\rightarrow\mtyp{\cclrd{r \cup s}}{\tau_2}) \rightarrow \mtyp{\cclrd{\emptyset}}(\tau_1\rightarrow\mtyp{\cclrd{r \cup s}}{\tau_2})
\end{equation*}
%
In order to split the implicit parameters of the body ($\cclrd{r \cup s}$ on the left-hand side) between 
the declaration site ($\cclrd{\emptyset}$ on the outer $\mtyp{}$ on the right-hand side) and the 
call site ($\cclrd{r \cup s}$ on the inner $\mtyp{}$ on the right-hand side), we need an operation
(which we call \ident{delay}) with the following signature:
%
\begin{equation*}
\ident{delay}_{\cclrd{r}, \cclrd{s}}~:~(\tau_1\rightarrow\mtyp{\cclrd{r \cup s}}{\tau_2}) \rightarrow \mtyp{\cclrd{r}}(\tau_1\rightarrow\mtyp{\cclrd{s}}{\tau_2})
\end{equation*}
%
The operation reveals the difference between effects and coeffects -- intuitively, given a function
with effects $\cclrd{r \cup s}$, it should execute the effects $\cclrd{r}$ when wrapping the 
function, \emph{before} the function actually performs the effectful operation with the effects.
The remaining effects $\cclrd{s}$ are delayed as usual, while effects $\cclrd{r}$ are removed
from the effect annotation of the body.

Another important aspect of the signature is that the function needs to be indexed by the coeffect
annotations $\cclrd{r}, \cclrd{s}$. The indices determine how the input context requirements
$\cclrd{r \cup s}$ are split -- and thus guarantee determinism of the function at run-time.

The operation cannot be implemented in a useful way for most standard monads, but the 
reader monad is, indeed, an exception. It is not difficult to see how it can be implemented
when we expand the definitions of $\mtyp{\cclrd{r}}\tau$:
%
\begin{equation*}
\ident{delay}_{\cclrd{r}, \cclrd{s}}~:~
(\tau_1\rightarrow(\cclrd{r \cup s} \rightarrow \sigma) \rightarrow \tau_2) \rightarrow 
((\cclrd{r} \rightarrow \sigma) \rightarrow \tau_1\rightarrow(\cclrd{s} \rightarrow \sigma) \rightarrow \tau_2)
\end{equation*}

\paragraph{Restricting coeffects in comonads.} 
As just demonstrated, we can extend monads so that the reader monad is capable of capturing
the semantics of implicit parameters, including the splitting of implicit parameter requirements
in lambda abstraction. Can we also go the other way round and \emph{restrict} the comonadic
semantics so that all requirements are delayed as in the (\emph{mabs}) rule, thus modelling 
fully dynamically scoped parameters?

This is, indeed, possible. Recall that the semantics of lambda abstraction in the flat
coeffect calculus is modelled using $\ident{merge}_{\cclrd{r}, \cclrd{s}}$. The operation takes
two contexts (wrapped in an indexed comonad $\ctyp{\cclrd{r}}\alpha$), combines their carried 
values and additional contextual information (implicit parameters). To obtain the (\emph{mabs}) 
rule, we can restrict the first parameter, which corresponds to the declaration site context:
%
\begin{equation*}
\begin{array}{rcll}
 \ident{merge}_{\cclrd{r}, \cclrd{s}} &\narrow{:}& \ctyp{\cclrd{r}}\alpha \times \ctyp{\cclrd{s}}\beta \rightarrow \ctyp{\cclrd{r \cup s}}(\alpha \times \beta)
 &\hspace{4em}(\textit{normal}) \\
 \ident{merge}_{\cclrd{r}, \cclrd{s}} &\narrow{:}& \ctyp{\cclrd{\emptyset}}\alpha \times \ctyp{\cclrd{s}}\beta \rightarrow \ctyp{\cclrd{s}}(\alpha \times \beta)
 &\hspace{4em}(\textit{restricted})
\end{array} 
\end{equation*}
%
In the (\emph{restricted}) version of the operation, the declaration site context requires
no implicit parameters and so all implicit parameters have to be satisfied by the call site.
The semantics using the restricted version corresponds to the (\emph{mabs}) rule shown above.

The idea of restricting the operations of the coeffect calculus semantics could be used more
generally. We could allow any of the coeffect algebra operations $\cseq, \czip, \cpar$ to be
\emph{partial} and thus the restricted (fully dynamically-scoped) version of implicit parameters
could be obtained just by changing the definition of $\czip$. Similarly, we could obtain \eg~a
fully lexically-scoped version of the system. The ability to restrict operations to partial 
functions has been used in the semantics of effectful computations by Tate~\cite{effects-producer-semantics}.












\section{SUmmary}

Next, we introduced the notion of \emph{flat indexed comonad}, which generalizes of comonads
and adds additional operations needed to provide categorical semantics of the flat coeffect 
calculus. The indices of the flat indexed comonad operations correspond to the
coeffect annotations in the type system and provide a foundation for the design of the 
calculus. 


In the upcoming chapter, we move from \emph{flat} coeffect calculi, tracking whole-context
properties to \emph{structural} coeffect calculi, tracking per-variable information, thus
covering systems from the second half of Chapter~\ref{ch:applications}.