% ==================================================================================================
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
% ==================================================================================================

\documentclass[
		twoside,openright,titlepage,numbers=noenddot,headinclude,%1headlines,
                footinclude=true,cleardoublepage=empty,
                BCOR=10mm,paper=a4,fontsize=10pt, % Binding correction, paper type and font size
                ngerman,american, % Languages
                ]{scrreprt}

\input{classicthesis-config}
\usepackage{semantic}
\usepackage{paralist}
\usepackage{etoolbox}
\usepackage{stmaryrd}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}

\newcounter{mythmcounter}
\newcounter{mydefcounter}
\newcounter{myexpcounter}
\newtheorem{example}[myexpcounter]{Example}
\newtheorem{remark}[mythmcounter]{Remark}
\newtheorem{definition}[mydefcounter]{Definition}
\newtheorem{theorem}[mythmcounter]{Theorem}
\newtheorem{lemma}[mythmcounter]{Lemma}
\newtheorem{proposition}[mythmcounter]{Proposition}
\newtheorem*{lemma*}{Lemma}

% Formatting for source code & types
\definecolor{cmtclr}{rgb}{0.0,0.6,0.0}
\definecolor{kvdclr}{rgb}{0.0,0.0,0.6}
\definecolor{strclr}{rgb}{0.25,0.1,0.0}
\definecolor{prepclr}{rgb}{0.0,0.0,0.0}

\newcommand{\sep}[0]{\; | \;}
\newcommand{\kvd}[1]{\textnormal{\textcolor{kvdclr}{\ttfamily #1}}}
\newcommand{\str}[1]{\textnormal{\textcolor{strclr}{\ttfamily "#1"}}}
\newcommand{\prepk}[1]{\textnormal{\textcolor{prepclr}{\bfseries\sffamily #1}}}
\newcommand{\prepi}[1]{\textnormal{\textcolor{prepclr}{\ttfamily #1}}}
\newcommand{\ident}[1]{\textnormal{\sffamily #1}}
\newcommand{\cmt}[1]{\textit{\sffamily\textcolor{cmtclr}{#1}}}

\newcommand{\ctyp}[2]{C^{#1}#2}
\newcommand{\mtyp}[2]{M^{#1}#2}
\newcommand{\subst}[3]{#1[#2 \leftarrow #3]}

% Typing rule and typing statement (single line)
\newcommand{\tyrule}[3]{ \inference[\footnotesize{(\emph{#1})}~~]{#2}{#3} }
\newcommand{\tyruler}[3]{ \inference{#2}{#3}~~\footnotesize{(\emph{#1})} }

% Coeffect algebra
\definecolor{aclr}{rgb}{0.6,0.3,0.0}
\newcommand{\aclrd}[1]{\textcolor{aclr}{#1}}

% Coeffect algebra
\definecolor{cclr}{rgb}{0.0,0.5,0.0}
\newcommand{\cclrd}[1]{\textcolor{cclr}{#1}}

\newcommand{\czero}{ \textcolor{cclr}{ \mathsf{ign} } }
\newcommand{\cunit}{ \textcolor{cclr}{ \mathsf{use} } }
\newcommand{\cseq}{ \textcolor{cclr}{ \circledast }}
\newcommand{\cpar}{ \textcolor{cclr}{\oplus} }
\newcommand{\czip}{ \textcolor{cclr}{\wedge} } % only used by flat coeffects
\newcommand{\cleq}{ \textcolor{cclr}{\leq} }
\newcommand{\cgeq}{ \textcolor{cclr}{\geq} }

\newcommand{\atimes}{ \textcolor{aclr}{\times} }
\newcommand{\aseq}{ \textcolor{aclr}{\circledast}} % Should be the same as \cseq
\newcommand{\aparstr}{ \textcolor{aclr}{\oplus}} % Should be the same as \cseq

% Unified

\newcommand{\SH}{ {\textcolor{sclr}{S}} }
\newcommand{\SP}{ {\textcolor{sclr}{P}} }
\newcommand{\SHP}{ {\textcolor{sclr}{S\triangleleft P}} }
\newcommand{\sempty}{ {\textcolor{sclr}{ \hat{0}}} }
\newcommand{\sunit}{ {\textcolor{sclr}{\hat{1}}} }
\newcommand{\stimes}{ {\textcolor{sclr}{\diamond}} }
\newcommand{\sflat}{\star}

\newcommand{\azero}{ \textcolor{aclr}{\bot} }
\newcommand{\aunit}{ \alift{\cunit} }
\newcommand{\aweak}{ \alift{\czero} }

\newcommand{\azip}{ \textcolor{aclr}{ \mathbin{\rotatebox[origin=c]{-90}{$\ltimes$}} } }
\newcommand{\apar}{ \textcolor{aclr}{ \mathbin{\rotatebox[origin=c]{90}{$\ltimes$}} } }


\newcommand{\xtimes}{\hat{\times}}

\newcommand{\ctx}{\textit{ctx}}


% Ordinary context where colouring is done by hand
\newcommand{\coctx}[2]{ #1 \,\text{\scriptsize @}\, {{\text{$#2$}}}  }

% Simple coeffect systems in the introduction
\newcommand{\cons}{\hspace{-0.15em}\times\hspace{-0.25em}} %\sctxclrd{+\hspace{-0.55em}+}}

\newcommand{\alift}[1]{ \textcolor{aclr}{\langle} #1 \textcolor{aclr}{\rangle}}

\definecolor{sclr}{rgb}{0.2,0,0.8}
\newcommand{\sclrd}[1]{ \textcolor{sclr}{#1} }

\newcommand{\C}{ {\textcolor{cclr}{\mathcal{C}}} }
\newcommand{\M}{ {\textcolor{cclr}{\mathcal{M}}} }

\newcommand{\alen}[1]{{\aclrd{\textit{len}(}#1\aclrd{)}}}
\newcommand{\slen}[1]{{\sclrd{\textit{len}(}#1\sclrd{)}}}
\newcommand{\xlen}[1]{{\textit{len}(#1)}}

\newcommand{\reduce}{\longrightarrow}


\newcommand{\restr}[2]{#1|_{#2}}
\newcommand{\narrow}[1]{\hspace{-0.5em} #1 \hspace{-0.65em}~}


\definecolor{todoclr}{rgb}{0.8,0,0.5}
\newcommand{\todo}[1]{\textcolor{todoclr}{ \begin{quotation} \noindent\textbf{TODO:} #1 \end{quotation} }}

\newcommand{\sem}[1]{\llbracket #1 \rrbracket}
\newcommand{\catc}{\mathcal{C}}
\newcommand{\idf}[1]{ {\textnormal{\sffamily id}}_{#1} }


\newcommand{\figcaption}[1]{
  \vspace{0.5em}
  \noindent\makebox[\linewidth]{\rule{\textwidth}{0.5pt}}
  \vspace{-2em}
  \caption{#1}
}
% Half line spacing around align
\newcommand{\zerodisplayskips}{%
  \setlength{\abovedisplayskip}{0.5em}
  \setlength{\belowdisplayskip}{0.5em}
  \setlength{\abovedisplayshortskip}{0.5em}
  \setlength{\belowdisplayshortskip}{0.5em}}
\appto{\normalsize}{\zerodisplayskips}
\appto{\small}{\zerodisplayskips}
\appto{\footnotesize}{\zerodisplayskips}

% half line spacing around compactitem
\setlength{\pltopsep}{0.5em}
\setlength{\plitemsep}{0.3em}

\patchcmd{\thebibliography}{\chapter*}{\section*}{}{}

\begin{document}

\frenchspacing % Reduces space after periods to make text more compact
\raggedbottom % Makes all pages the height of the text on that page
\selectlanguage{american} % Select your default language - e.g. american or ngerman
\pagenumbering{arabic} % Roman page numbering prior to the start of the thesis content (i, ii, iii, etc)
\pagestyle{plain} % Suppress headers for the pre-content pages




\newcommand{\semdeff}[4]{
\begin{array}{rcl}
  #1 & = & #3 \\ \cline{1-1}\cline{3-3}
  #2 & = & #4 \\
\end{array}  
}
\newcommand{\semdefff}[6]{
\begin{array}{rcl}
  #1 & = & #4 \\
  #2 & = & #5 \\ \cline{1-1}\cline{3-3}
  #3 & = & #6 \\
\end{array}  
}
\newcommand{\semdef}[2]{
\begin{array}{rcl}
  ~ & ~ & ~ \\ \cline{1-1}\cline{3-3}
  #1 & = & #2 \\
\end{array}  
}
% ==================================================================================================

\chapter{Translation semantics}
\renewcommand*\thesection{\arabic{section}}

The \emph{flat coeffect calculus} introduced in the previous chapter uniformly captures a number
of context-aware systems discussed earlier in Chapter~X. The coeffect calculus can be seen
as a \emph{language framework} that simplifies the construction of concrete \emph{domain-specific}
coeffect lnguages. First, it provides a parameterized type system that tracks the required context.
Second, the comonadic semantics provides a way for implementing the langauge by translating
it into a non-context-aware functional programming language with additional comonadically-inspired
coeffect-specific primitives that implement the concrete notion of context-awareness.

In this chapter, we give three concrete examples of how the coeffect \emph{language framework}
gives rise to concrete \emph{context-aware domain-specific} languages and we discuss the safety
guarantees provided by the coeffect type system.

For each concrete context-aware langauge, the safety depends on the coeffect-specific 
comonadically-inspired primitives, but the coeffect framework makes it easier to prove such safety.
We only need to define the meaning of the comonadically-inspired coeffect-specific primitives
and then show that those do not ``go wrong''. In doing so, we can use the coeffect annotations
provided by the type system. 

\paragraph{Chapter structure and contributions}

\begin{itemize}
\item 
  We define the common subset of the target functional programming language. This includes the
  syntax of the language, reduction rules and typing rules, but it does \emph{not} include 
  coeffect-specific definitions. Well-typed programs written using the common subset of the 
  target language do not get stuck (via progress and preservation), but they may reduce to 
  \ident{error}, e.g. when accessing the head of an empty list.
  
\item We then extend the language with coeffect-specific comonadically-inspired
  data types and primtiives for dataflow and for implicit parameters. We show that the extension
  preserves the progress and preservation properties. 
  
\item Next, we consider only programs in the target language that were produced by a
  translation from the coeffect domain-specific language and we show that such programs not only
  do not get stuck, but they also do not reduce to the \ident{error} value. In other words,
  ``well-typed coeffect programs do not get hungry'' requiring more context than guaranteed
  by the coeffect type system.

\item We show how the approach extends to structural coeffect systems and we argue that our
  proof can be generalized -- rather than reconsidering progress and preservation of the 
  whole language, we can rely just on the correctness of the coeffect-specific comonadically-inspired
  primitives and abstraction mechanism provided by languages such as ML and Haskell.  
\end{itemize}  

% --------------------------------------------------------------------------------------------------

\section{Introduction}

The development in this chapter closely follows the example of effectful computations. 
Effect systems provide a type system for tracking effects and monadic translation can be used as 
a basis for implementing effectful domain-specific languages (e.g.~through the do-notation in 
Haskell). 

This chapter also links together all the different technical developments presented in this thesis.
The abstract comonadic semantics is used as a \emph{translation} that gives a concrete semantics
to a number of concrete context-aware languages. The type system is used to guarantee that the
resulting programs are correct. Finally, the development in this chapter is closely mirrored by 
the implementation presented in Chapter~X.

\subsection{Safety properties}
The key claim of this thesis is that writing context-aware programs using coeffects is easier and
safer. For example, consider the simple problem of writing a dataflow function that calculates the 
difference between the current and the previous value. 

The following shows the code written in a coeffect dataflow language (left) and using lists to
represent past values in a ML-like language (right):
%
\begin{equation*}
\begin{array}{l}
\kvd{let}~\ident{diff}=\kvd{fun}~\ident{x}\rightarrow\\[-0.2em]
 \quad \ident{x}-\kvd{prev}~\ident{x}
\end{array} 
\qquad
\begin{array}{l}
\kvd{let}~\ident{diff}=\kvd{fun}~\ident{x}\rightarrow\\[-0.2em]
 \quad \ident{List.head}~\ident{x}-\ident{List.head}~(\ident{List.tail}~\ident{x})
\end{array} 
\end{equation*}
%
The function on the right has a type $\ident{num}~\ident{list}\rightarrow\ident{num}$. The function
fails for input lists containing only zero or one elements. However, this is not reflected in the
type and it is not enforced by the type checker.

The function on the left has a type $\ctyp{\cclrd{1}}\ident{num}\rightarrow\ident{num}$ meaning 
that it requires one past value (in addition to the current value). The information about required
context is now reflected in the type. In this chapter, we show that well-typed (and well-coeffected!) 
programs do not ``get stuck''. That is, the coeffect annotation in the type system is a safe
over-approximation of the actual contextual information that will be accessed when a program runs.

% --------------------------------------------------------------------------------------------------

\subsection{Comonadic translation}

The previous chapter gives the semantics of coeffect calculus in terms of indexed comonads. In this
chapter, we follow the example of effects and monads and we use the semantics to define a 
\emph{translation}.

A context-aware \emph{source} program written using a concrete context-aware domain-specific 
language (capturing dataflow, implicit parameters or other kinds of context awareness) with
domain-specific language extensions (the \kvd{prev} keyword, or the \ident{?impl} syntax)
is translated to a \emph{target} langauge that is not context-aware. The target language is
a small functional language consisting of:
%
\begin{itemize}
  \item Simple functional subset formed by lambda calculus with tuples and numbers.
  \item Comonadically-inspired primitives corresponding to \emph{counit}, \emph{cobind} and
    other operations of flat indexed comonads.
  \item Additional primitives that model contextual operations of each concrete coeffect language
    (\emph{prev} for the \kvd{prev} keyword, \emph{lookup} for the \ident{?impl} syntax etc.)
\end{itemize}
%
The syntx, typing and reduction rules of the first part (simple functional language) are used by 
all concrete coeffect domain-specific langauges. The syntax and typing rules of the second part 
(comonadically-inspired) primitives are also shared by all coeffect DSLs, however the \emph{reduction
rules} for the comonadically-inspired primitives differ -- they capture the concrete notion of
context. Finally, the third part (domain-specific primitives) will differ for each coeffect DSL.


% --------------------------------------------------------------------------------------------------

\begin{figure}[t]
\paragraph{Language syntax}  
\begin{equation*}
\begin{array}{rcl}
  v &  = & n \sep \lambda x.e \sep (v_1, \ldots, v_n) \\
  e &  = & x \sep n \sep \pi_i~e \sep (e_1, \ldots, e_n) \sep e_1~e_2 \sep \lambda x.e \\
  \tau &  = & \ident{num} \sep \tau_1 \times \ldots \times \tau_n \sep \tau_1 \rightarrow \tau_2 \\
  C  & = & (v_1, \ldots, v_{i-1}, \_, e_{i+1}, \ldots e_n) \sep v~\_ \sep \_~e \sep \pi_i~\_ 
  
\end{array}
\end{equation*}

~
\paragraph{Reduction rules}
\begin{equation*}
\begin{array}{rll}
  \footnotesize{(\emph{fn})}  & (\lambda x.e)~v \rightarrow e[x\leftarrow v] \\[0.25em]
  \footnotesize{(\emph{prj})} & \pi_i (v_1, \ldots, v_n) \rightarrow v_i\\[0.25em]
  \footnotesize{(\emph{ctx})}  & C[e] \rightarrow C[e']  & (\textnormal{when}~e\rightarrow e')\\[0.25em]
\end{array}
\end{equation*}

\caption{Common syntax and reduction rules of the target langauge}
\label{fig:transl-target}
\end{figure}

% --------------------------------------------------------------------------------------------------

\section{Target langauge}

The target langauge for the translation is a simply typed lambda calculus with numbers and tuples.
The translation uses tuples as it keeps a tuple with variable assignments (encoding those without 
tuples would be possible, but cumbersome) and we add numbers as a basic concrete data type.
In this section, we define the common parts of the language without the comonadically-inspired
primitives.

The syntax of the target programming langauge is shown in Figure~\ref{fig:transl-target}. 
The values include numbers $n$, tuples and function values.
The expressions include variables $x$, values, lambda abstraction and application and operations 
on tuples. We do not need recursion (although a realistic programming language would include it). 
In what follows, we also use the following syntactic sugar for let binding:
%
\begin{equation*}
\begin{array}{rcl}
  \kvd{let}~x=e_1~\kvd{in}~e_2 &=& (\lambda x.e_2) e_1
\end{array}
\end{equation*}
%
Finally, $C[e]$ defines the context in which sub-expressions are evaluated. Together with the
evaluation rules shown in  Figure~\ref{fig:transl-target}, this captures the standard call-by-name
semantics of the common parts of the target language.
The (standard) typing rules for the common expressions of the target langauge are shown in 
Figure~\ref{fig:transl-targetty}. The rules are standard. 

% --------------------------------------------------------------------------------------------------

\begin{figure}[t]
\paragraph{Typing rules}
\begin{equation*}
\begin{array}{ll}
\tyrule{var}
  { x:\tau \in \Gamma }
  { \Gamma \vdash x:\tau }
&
\tyrule{err}
  { ~ }
  { \Gamma \vdash \ident{error}:\tau }
\\[1em]
\tyrule{str}
  { ~ }
  { \Gamma \vdash s:\ident{str} }
&
\tyrule{num}
  { ~ }
  { \Gamma \vdash n:\ident{num} }
\\[1em]
\tyrule{nil}
  { ~ }
  { \Gamma \vdash []:[\tau] }
&
\tyrule{head}
  { \Gamma \vdash e :[\tau] }
  { \Gamma \vdash \ident{head}~e:\tau }
\\[1em]
\tyrule{tail}
  { \Gamma \vdash e :[\tau] }
  { \Gamma \vdash \ident{tail}~e:[\tau] }
\qquad~&
\tyrule{abs}
  { \Gamma, x\!:\!\tau_1 \vdash e : \tau_2 }
  { \Gamma \vdash \lambda x.e : \tau_1 \rightarrow \tau_2 }
\end{array}
\end{equation*}
\begin{equation*}
\begin{array}{l}
\tyrule{app}
  { \Gamma \vdash e_1 : \tau_1 \rightarrow \tau_2  & \Gamma \vdash e_2 : \tau_1 }
  { \Gamma \vdash e_1~e_2 : \tau_2 }
\\[1.25em]
\tyrule{cons}
  { \Gamma \vdash e_1 :\tau & \Gamma \vdash e_2 : [\tau] }
  { \Gamma \vdash e_1\!::\!e_2 : [\tau] }
\\[1.25em]
\tyrule{proj}
  { \Gamma \vdash e : \tau_1 \times \ldots \tau_i \times \ldots \times \tau_n }
  { \Gamma \vdash \pi_i~e:\tau_i }
\\[1.25em]
\tyrule{tup}
  { \forall i\in\{1 \ldots n\}.~ \Gamma \vdash e_i : \tau_i }
  { \Gamma \vdash (e_1, \ldots, e_n) : \tau_1 \times \ldots \times \tau_n }
\\[1.25em]
\tyrule{ifn}
  { \Gamma \vdash e_1 : \ident{num} & \Gamma \vdash e_2 : \ident{num} &
    \Gamma \vdash e_3 : \tau & \Gamma \vdash e_4 : \tau}
  { \Gamma \vdash \kvd{if}~e_1 = e_2~\kvd{then}~e_3~\kvd{else}~e_4 : \tau}
\\[1.25em]
\tyrule{ifs}
  { \Gamma \vdash e_1 : \ident{str} & \Gamma \vdash e_2 : \ident{str} &
    \Gamma \vdash e_3 : \tau & \Gamma \vdash e_4 : \tau}
  { \Gamma \vdash \kvd{if}~e_1 = e_2~\kvd{then}~e_3~\kvd{else}~e_4 : \tau}
\end{array}
\end{equation*}

\caption{Typing rules for the common syntax of the target language}
\label{fig:transl-targetty}
\end{figure}

% --------------------------------------------------------------------------------------------------

\subsection{Properties}

The subset of the langauge described so far models a simple ML-like functional programming 
langauge (or, Haskell-like language, if we choose call-by-name evaluation). The subset of the
langauge introduced so far satisfies the property that ``well-typed programs do not get stuck'',
i.e.~both type preservation (reduction does not change the type of an expression) and the progress 
property (an well-typed expression is either a value or can be reduced).
We first show this for the subset of the language discussed so far and later extend the proof to 
also cover the comonadically-inspired primitives that will be added in the next section.

\begin{theorem}[Type preservation]
  If $\Gamma \vdash e : \tau$ and $e \rightarrow e'$ then $\Gamma \vdash e' : \tau$
\end{theorem}
\begin{proof}
  Rule induction over $\rightarrow$.
\end{proof}

\begin{theorem}[Progress]
  If $\Gamma \vdash e : \tau$ then either $e$ is a value or there exits $e'$ such that $e \rightarrow e'$
\end{theorem}
\begin{proof}
  By rule induction over $\vdash$.
\end{proof}

% --------------------------------------------------------------------------------------------------

\subsection{Coeffect-specific extnesions}

Given a flat coeffect algebra $(\C, \cseq, \cpar, \czip, \cunit, \czero, \cleq)$ of a concrete 
coeffect domain-specific langauge, we first extend the language syntax and typing rules with 
the terms that correspond to the comonadically-inspired operations. This is done in the same way
for all concrete coeffect DSLs and so we give the additional syntax, evaluation context and 
typing rules just once in Figure~\ref{fig:transl-ext}.

The figure defines the syntax and the typing rules, but it does not define the reduction rules.
Those -- together with the values for a concrete notion of context -- will be defined separately
for each individual coeffect DSL. We first consider the DSL for dataflow programming.

% --------------------------------------------------------------------------------------------------

\begin{figure}[t]
\paragraph{Language syntax}
Given $(\C, \cseq, \cpar, \czip, \cunit, \czero, \cleq)$, extend the syntax:

\begin{equation*}
\begin{array}{rcl}
  e &  =  &\ldots \sep\ident{cobind}_{\cclrd{s},\cclrd{r}}~e_1~e_2 \sep \ident{counit}_{\cunit}~e \sep \ident{merge}_{\cclrd{r},\cclrd{s}}~e 
         \sep \ident{split}_{\cclrd{r},\cclrd{s}}~e \sep \ident{lift}_{\cclrd{r},\cclrd{r'}}~e \\
  \tau &  = &\ldots \sep \ctyp{\cclrd{r}}{\tau} \\
  C  & = &\ldots \sep \ident{cobind}_{\cclrd{s},\cclrd{r}}~\_~e \sep \ident{cobind}_{\cclrd{s},\cclrd{r}}~v~\_ \sep \ident{counit}_{\cunit}~\_ \\
    &\sep& \ident{merge}_{\cclrd{r},\cclrd{s}}~\_
           \sep \ident{split}_{\cclrd{r},\cclrd{s}}~\_ \sep \ident{lift}_{\cclrd{r},\cclrd{r'}}~\_ \\
  
\end{array}
\end{equation*}

~

~

\paragraph{Typing rules}
Given $(\C, \cseq, \cpar, \czip, \cunit, \czero, \cleq)$, add the typing rules:

\begin{equation*}
\begin{array}{l}
\tyrule{counit}
  {\Gamma \vdash e : \ctyp{\cunit}{\tau}}
  {\Gamma \vdash \ident{counit}_{\cunit}~e : \tau} \\
\\
\tyrule{cobind}
  {\Gamma \vdash e_1 : \ctyp{\cclrd{r}}{\tau_1} \rightarrow \tau_2 & \Gamma \vdash e_2 : \ctyp{\cclrd{r}\cseq\cclrd{s}}{\tau_1} }
  {\Gamma \vdash \ident{cobind}_{\cclrd{r}, \cclrd{s}}~e_1~e_2 : \ctyp{\cclrd{s}}{\tau_2}} \\
  \\
\tyrule{merge}
  {\Gamma \vdash  e : \ctyp{\cclrd{r}}{\tau_1} \times \ctyp{\cclrd{s}}{\tau_2} } 
  {\Gamma \vdash  \ident{merge}_{\cclrd{r},\cclrd{s}}~e : \ctyp{\cclrd{r}\czip\cclrd{s}}{(\tau_1 \times \tau_2)} }\\
    \\
\tyrule{split}
  {\Gamma \vdash  e : \ctyp{\cclrd{r}\cpar\cclrd{s}}{(\tau_1 \times \tau_2)} }
  {\Gamma \vdash  \ident{split}_{\cclrd{r},\cclrd{s}}~e : \ctyp{\cclrd{r}}{\tau_1} \times \ctyp{\cclrd{s}}{\tau_2}} \\
\\
\tyrule{lift}
  {\Gamma \vdash  e : \ctyp{\cclrd{r'}}{\tau} }
  {\Gamma \vdash \ident{lift}_{\cclrd{r'},\cclrd{r}}~e : \ctyp{\cclrd{r}}{\tau} } \qquad\forall \cclrd{r'},\cclrd{r}, \cclrd{r}\,\cleq\,\cclrd{r'}
\\
\end{array}
\end{equation*}

\caption{Comonadically-inspired extensions for the target langauge}
\label{fig:transl-ext}
\end{figure}

% --------------------------------------------------------------------------------------------------

\subsection{Comonadically-inspired translation}

In Chapter 4, we presented the semantics of the flat coeffect calculus in terms of indexed comonads.
We treated the semantics as denotational -- interpreting the meaning of a given typing derivation
of a program in terms of category theory.

In this chapter, we use the same structure in a different way. Rather than treating the rules as
\emph{denotation} in categorical sense, we treat them as \emph{translation} from a source 
domain-specific coeffect language into a target language with comonadically-inspired primitives
described in the previous section.

Similarly, the interpretation of contexts and types in the category now becomes a translation from types and
contexts in the source language into the types of the target language:

\begin{equation*}
\begin{array}{rcl}
\sem{\coctx{x_1\!:\!\tau_1, \ldots, x_n\!:\!\tau_n}{\cclrd{r}}} &=& \ctyp{\cclrd{r}}{(\sem{\tau_1} \times \ldots \times \sem{\tau_n})} \\[0.5em]
\sem{\tau_1 \xrightarrow{\cclrd{r}} \tau_2} & = & \ctyp{\cclrd{r}}{\sem{\tau_1}} \rightarrow \sem{\tau_2} \\[-0.2em]
\sem{\ident{num}} & = & \ident{num} \\
\end{array}
\end{equation*}

Here, a context becomes a comonadically-inspired data type wrapping a tuple of variable values 
and a coeffectful function is translated into an ordinary function in the target language
with a comonadically-inspired data type wrapping the input type.

The rules shown in Figure~\ref{fig:transl-translation} are very similar to those shown earlier
Figure~X in Chapter~3. Thanks to the equivalence between $\lambda$-calculus and category theory,
we now interpret them as denoting a translation. Furthermore, the program produced by the above
rules is well-typed.

\begin{lemma}[Well-typedness of the translation]
Given a well-typed coeffect program $\coctx{\Gamma}{\cclrd{r}} \vdash e : \tau$ with a 
typing derivation such that:
%  
\begin{equation*}  
  \semdeff
    {(\ldots)\qquad~}
    {\coctx{\Gamma}{\cclrd{r}} \vdash e : \tau }
    {(\ldots)}
    { ~~f }
\end{equation*}  
%
Then $e$ is a valid expression in the target langauge and $\vdash f : \sem{\coctx{\Gamma}{\cclrd{r}}} \rightarrow \sem{\tau}$.
\end{lemma}
\begin{proof}
  By rule induction over the translation rules.
\end{proof}


\begin{figure*}[t]

\begin{equation*}
\hspace{-3em}
\begin{array}{ll}
\hspace{4.8em}\semdef
  {\coctx{\Gamma}{\cunit} \vdash x_i : \tau_i }
  {\lambda\ctx.\pi_i~(\ident{counit}_{\cunit}~\ctx)} 
& (\emph{var})
\\[1em]
\hspace{5.3em}\semdef
  {\coctx{\Gamma}{\czero} \vdash n : \ident{num} }
  {\lambda\ctx.n} 
& (\emph{const})
\\[1.5em]
\hspace{1.5em}\semdeff
  {\coctx{\Gamma, x:\tau_1}{\cclrd{r}\;\czip\;\cclrd{s}} \vdash e : \tau_2}
  {\coctx{\Gamma}{\cclrd{r}} \vdash \lambda x.e : \tau_1 \xrightarrow{\cclrd{s}} \tau_2 }
  {f}
  {\lambda \ctx.\lambda v.f~(\ident{merge}_{\cclrd{r}, \cclrd{s}}~(\ctx, v)) }
& (\emph{abs})
\\[2em]
\semdefff
  {\coctx{\Gamma}{\cclrd{r}} \vdash e_1 : \tau_1 \xrightarrow{\cclrd{t}} \tau_2}
  {\coctx{\Gamma}{\cclrd{s}} \vdash e_2 : \tau_1 }
  {\begin{array}\coctx{\Gamma}{\cclrd{r} \;\cpar\; (\cclrd{s} \,\cseq\, \cclrd{t})} \vdash e_1~e_2 : \tau_2\\[-0.3em]~\\[-0.3em]~\\[-0.3em]~\end{array}}
  {f}
  {g}
  {\begin{array}{l}  
  \lambda\ctx.~~\\[-0.3em]
    \quad \kvd{let}~\ctx_0 = \ident{map}_{\cclrd{r} \;\cpar\; (\cclrd{s} \,\cseq\, \cclrd{t})}~(\lambda x.(x,x))~\ctx\\[-0.3em]
    \quad \kvd{let}~(\ctx_1, \ctx_2) = \ident{split}_{\cclrd{r}, \cclrd{s} \,\cseq\, \cclrd{t}}~\ctx_0\\[-0.3em]
    \quad f~\ctx_1~
      (\ident{cobind}_{\cclrd{s}, \cclrd{t}}~g~\ctx_2)
  \end{array} }   
& (\emph{app})
\\[4em]
\hspace{6em}\semdeff
  {\coctx{\Gamma}{\cclrd{r'}} \vdash e : \tau}
  {\coctx{\Gamma}{\cclrd{r}} \vdash e : \tau } 
  {f}
  {\lambda\ctx f~(\ident{lift}_{\cclrd{r}, \cclrd{r'}}~\ctx}
\quad(\hspace{-0.7em}\textnormal{\footnotesize when}~\cclrd{r'} \leq \cclrd{r})
& (\emph{sub})\\[-0.25em]
\end{array}
\end{equation*}

\figcaption{Translation from a flat DSL to a comonadically-inspired target language}
\label{fig:transl-translation}
\end{figure*}

% --------------------------------------------------------------------------------------------------

\section{Coeffect langauge for dataflow}

The types of the comonadically-inspired operations are the same for each concrete coeffect DSL, but
each DSL introduces its own \emph{values} of type $\ctyp{\cclrd{r}}\tau$ and also its own reduction
rules that define how comonadically-inspired operations evaluate.

We first consider the extensions needed for dataflow computations. As discussed earlier in the
semantics of dataflow, the indexed comonad for a context with $n$ past values carries $n+1$ 
values.

When evaluating translated programs, the comonadic values will not be directly manipulated by the
user code and so we introduce a new class of values written as $\ident{Df}\langle v_0, \ldots, v_n\rangle$. 
Furthermore, the \ident{Df} values will only appear as fully evaluated inputs and they will be manipulated 
using the comonadically-inspired operations. Thus, the typing rule (\emph{df}) only needs to 
check values. We do not need a similar rule for expressions. Construct such as $\ident{Df}\langle(\kvd{fun}~x.x)~1\rangle$ 
are not allowed in the target language. The (\emph{df}) rule also guarantees that the number of 
elements in the list matches the number in the coeffect:

\begin{equation*}
\begin{array}{l}
v = \ldots \sep \ident{Df}\langle v_0, \ldots, v_n\rangle \\
e = \ldots \sep \ident{Df}\langle v_0, \ldots, v_n\rangle \\
\end{array}  
\begin{array}{l}
\tyrule{df}
  { \forall i\in\{ 0 \ldots n \}. ~ \vdash v : \tau}
  { \Gamma \vdash \ident{Df}\langle v_0, \ldots, v_n \rangle : \ctyp{\cclrd{n}}{\tau} }
\end{array}  
\end{equation*}
~

\noindent
The additional reduction rules mirror the semantics that we discussed earlier when talking about
indexed dataflow comonad.

\begin{equation*}
\begin{array}{rl}
{\footnotesize(\emph{counit})} & \begin{array}{l}
\ident{counit}_{\cclrd{0}}(\ident{Df} \langle v_0 \rangle)   \rightarrow v_0
\end{array}
\\[0.5em]
{\footnotesize(\emph{cobind})} & \begin{array}{l}
\ident{cobind}_{\cclrd{m}, \cclrd{n}}~f (\ident{Df}\langle v_0, \ldots v_{m+n} \rangle) \rightarrow
\\[-0.25em]
\quad (\ident{Df}\langle f (\ident{Df}\langle v_0, \ldots, v_m \rangle), \ldots, f (\ident{Df}\langle v_{n}, \ldots, v_{m+n} \rangle) \rangle)
\end{array}
\\[0.5em]
{\footnotesize(\emph{merge})} & \begin{array}{l}
\ident{merge}_{\cclrd{m}, \cclrd{n}} ((\ident{Df}\langle v_0, \ldots, v_m \rangle), (\ident{Df}\langle b_0, \ldots, b_n\rangle)) \rightarrow
\\[-0.25em]
\quad (\ident{Df}\langle (v_0, b_0), \ldots, (v_{\mathit{min}(m,n)}, b_{\mathit{min}(m,n)}) \rangle)
\end{array}
\\[0.5em]
{\footnotesize(\emph{split})} & \begin{array}{l}
\ident{split}_{\cclrd{m}, \cclrd{n}} (\ident{Df}\langle (v_0, b_0), \ldots, (v_{\mathit{max}(m,n)}, b_{\mathit{max}(m,n)}) \rangle)  \rightarrow
\\[-0.25em]
\quad \ident{Df}\langle v_0, \ldots, v_m \rangle, (\ident{Df}\langle b_0, \ldots, b_n\rangle
\end{array}
\\[0.5em]
{\footnotesize(\emph{lift})} & \begin{array}{l}
\ident{lift}_{\cclrd{n'}, \cclrd{n}} (\ident{Df}\langle v_0, \ldots, v_{n'} \rangle) \rightarrow
\qquad(\textnormal{when}~n\leq n') \\[-0.25em]
\quad \ident{Df}\langle v_0, \ldots, v_n \rangle
\end{array}
\end{array}
\end{equation*}

~

\noindent
Now consider a target langauge consisting of the core (ML-subset) defined in Figure~\ref{fig:transl-target}
with typing rules defined in Figure~\ref{fig:transl-targetty} and comonadically-inspired primtiives
defined in Figure~\ref{fig:transl-ext} and also concrete notion of comonadically-inspired value
and reduction rules for data flow as defined above.


\begin{theorem}[Type preservation]
  If $\Gamma \vdash e : \tau$ and $e \rightarrow e'$ then $\Gamma \vdash e' : \tau$
\end{theorem}
\begin{proof}
As before, using rule induction over $\rightarrow$.

Interesting new cases are the reduction rules (\emph{counit}), (\emph{cobind}), (\emph{merge}),
(\emph{split}) and (\emph{lift}). We need to show that, given a well typed input value, the resulting
value is a \ident{Df} value with the right number of elements (for (\emph{cobind}), (\emph{lift}) and (\emph{merge}),
a tuple of \ident{Df} values with the right number of elements (for (\emph{split})) and a value
of correct type (for (\emph{unit})).

From the fact that the reduction occurred, we know that the input was a \ident{Df} value with the
required number of inputs and from the typing rule (\emph{df}) we know that the values in the input
were all of correct types.  
\end{proof}

\begin{theorem}[Progress]
  If $\Gamma \vdash e : \tau$ then either $e$ is a value or there exits $e'$ such that $e \rightarrow e'$
\end{theorem}
\begin{proof}
  As before, using rule induction over $\vdash$.

Interesting new cases are those arising from the typing rules for the comonadically-inspired
primitives in Figure~\ref{fig:transl-ext}, that is (\emph{counit}), (\emph{cobind}), (\emph{merge}),
(\emph{split}) and (\emph{lift}).  
In all of the cases, $e$ is not a value and so it needs to reduce and the only reduction rules
are the ones for dataflow computations (above). 

If the argument is a value, one of the reduction rules (above) can be used (the typing guarantees
that the list has the required number of elements). If the argument is an expressions, we use 
the induction hypothesis.
\end{proof}

\newpage
\section{Coeffect language for implicit parameters}

\begin{equation*}
v = \ident{Impl}(v)
\end{equation*}

a

\begin{equation*}
\tyrule{impl}
  { \Gamma \vdash v : \ident{string} \rightarrow \ident{num}}
  { a }
\end{equation*}

b



% Simple for normal parts of the language
% We have to check this for dataflow reductions  
%
% Interesting case is $e_1 e_2$ where $e_1 = v$ is one of the primitives. Then we have to go through
% them and make sure they can progress.  

% And also syntactic sugar \ident{map} 


%    &\sep& \ident{cobind}_{\cclrd{s},\cclrd{r}}~e_1~e_2 \sep \ident{counit}_{\cunit}~e \sep \ident{merge}_{\cclrd{r},\cclrd{s}}~e 
%       \sep \ident{split}_{\cclrd{r},\cclrd{s}}~e \sep \ident{lift}_{\cclrd{r},\cclrd{r'}}~e \\

%
% &\sep& \ident{cobind}_{\cclrd{s},\aclrd{\textbf{r}}}~e_1~e_2 \sep \ident{counit}_{\cunit}~e \sep \ident{merge}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}~e 
%   \sep \ident{split}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}~e \sep \ident{lift}_{\cclrd{r},\cclrd{r'}}~e \sep \ident{dup}_{\cclrd{r},\cclrd{s}}~e \\

\section{Dataflow}
Domain specific coeffect annotations are non-negative integers, type is a tuple and new kinds
of values are lists:
\begin{equation*}
\begin{array}{rcl}
  v_c &  = &  \langle v_1, \ldots, v_n \rangle
\end{array}
\end{equation*}
%
With the following typing:
%
\begin{equation*}  
\tyrule{val}
  { \forall v_i . \vdash v_i : \tau }
  { \vdash \langle v_1, \ldots, v_n \rangle : \ctyp{n}{\tau} }
\end{equation*}
%


We could define those in terms of head/tail functions and then prove that they work (and translated
program does not contain head/tail), but perhaps that's unnecessary overkill. Or perhaps it would
be useful in order to show how we avoid errors... But doing it directly looks just simpler (we
also do not need a ``list'' type).

\begin{theorem}[Type preservation]
  If $\Gamma \vdash e : \tau$ and $e \rightarrow e'$ then $\Gamma \vdash e' : \tau$
\end{theorem}
\begin{proof}
  Rule induction over $\rightarrow$
  
Simple for normal parts of the language

We have to check this for dataflow reductions  
\end{proof}

\begin{theorem}[Progress]
  If $\Gamma \vdash e : \tau$ then either $e$ is a value or there exits $e'$ such that $e \rightarrow e'$
\end{theorem}
\begin{proof}
  By rule induction over $\vdash$.
  
Interesting case is $e_1 e_2$ where $e_1 = v$ is one of the primitives. Then we have to go through
them and make sure they can progress.  
\end{proof}





























\end{document}
