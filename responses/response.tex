% ==================================================================================================
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
% ==================================================================================================

\documentclass[
		twoside,openright,titlepage,numbers=noenddot,headinclude,%1headlines,
                footinclude=true,cleardoublepage=empty,
                BCOR=10mm,paper=a4,fontsize=10pt, % Binding correction, paper type and font size
                ngerman,american, % Languages
                ]{scrreprt}

\input{classicthesis-config}
\usepackage{semantic}
\usepackage{paralist}
\usepackage{etoolbox}
\usepackage{stmaryrd}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}

\newcounter{mythmcounter}
\newcounter{mydefcounter}
\newcounter{myexpcounter}
\newtheorem{example}[myexpcounter]{Example}
\newtheorem{remark}[mythmcounter]{Remark}
\newtheorem{definition}[mydefcounter]{Definition}
\newtheorem{theorem}[mythmcounter]{Theorem}
\newtheorem{lemma}[mythmcounter]{Lemma}
\newtheorem{proposition}[mythmcounter]{Proposition}
\newtheorem*{lemma*}{Lemma}

% Formatting for source code & types
\definecolor{cmtclr}{rgb}{0.0,0.6,0.0}
\definecolor{kvdclr}{rgb}{0.0,0.0,0.6}
\definecolor{strclr}{rgb}{0.5,0.1,0.0}
\definecolor{prepclr}{rgb}{0.0,0.0,0.0}

\newcommand{\sep}[0]{\; | \;}
\newcommand{\kvd}[1]{\textnormal{\textcolor{kvdclr}{\ttfamily #1}}}
\newcommand{\str}[1]{\textnormal{\textcolor{strclr}{\ttfamily "#1"}}}
\newcommand{\prepk}[1]{\textnormal{\textcolor{prepclr}{\bfseries\sffamily #1}}}
\newcommand{\prepi}[1]{\textnormal{\textcolor{prepclr}{\ttfamily #1}}}
\newcommand{\ident}[1]{\textnormal{\sffamily #1}}
\newcommand{\cmt}[1]{\textit{\sffamily\textcolor{cmtclr}{#1}}}

\newcommand{\ctyp}[2]{C^{#1}#2}
\newcommand{\mtyp}[2]{M^{#1}#2}
\newcommand{\subst}[3]{#1[#2 \leftarrow #3]}

% Typing rule and typing statement (single line)
\newcommand{\tyrule}[3]{ \inference[\footnotesize{(\emph{#1})}~~]{#2}{#3} }
\newcommand{\tyruler}[3]{ \inference{#2}{#3}~~\footnotesize{(\emph{#1})} }

% Coeffect algebra
\definecolor{aclr}{rgb}{0.6,0.3,0.0}
\newcommand{\aclrd}[1]{\textcolor{aclr}{#1}}

% Coeffect algebra
\definecolor{cclr}{rgb}{0.0,0.5,0.0}
\newcommand{\cclrd}[1]{\textcolor{cclr}{#1}}

\newcommand{\czero}{ \textcolor{cclr}{ \mathsf{ign} } }
\newcommand{\cunit}{ \textcolor{cclr}{ \mathsf{use} } }
\newcommand{\cseq}{ \textcolor{cclr}{ \circledast }}
\newcommand{\cpar}{ \textcolor{cclr}{\oplus} }
\newcommand{\czip}{ \textcolor{cclr}{\wedge} } % only used by flat coeffects
\newcommand{\cleq}{ \textcolor{cclr}{\leq} }
\newcommand{\cgeq}{ \textcolor{cclr}{\geq} }

\newcommand{\atimes}{ \textcolor{aclr}{\times} }
\newcommand{\aseq}{ \textcolor{aclr}{\circledast}} % Should be the same as \cseq
\newcommand{\aparstr}{ \textcolor{aclr}{\oplus}} % Should be the same as \cseq

% Unified

\newcommand{\SH}{ {\textcolor{sclr}{S}} }
\newcommand{\SP}{ {\textcolor{sclr}{P}} }
\newcommand{\SHP}{ {\textcolor{sclr}{S\triangleleft P}} }
\newcommand{\sempty}{ {\textcolor{sclr}{ \hat{0}}} }
\newcommand{\sunit}{ {\textcolor{sclr}{\hat{1}}} }
\newcommand{\stimes}{ {\textcolor{sclr}{\diamond}} }
\newcommand{\sflat}{\star}

\newcommand{\azero}{ \textcolor{aclr}{\bot} }
\newcommand{\aunit}{ \alift{\cunit} }
\newcommand{\aweak}{ \alift{\czero} }

\newcommand{\azip}{ \textcolor{aclr}{ \mathbin{\rotatebox[origin=c]{-90}{$\ltimes$}} } }
\newcommand{\apar}{ \textcolor{aclr}{ \mathbin{\rotatebox[origin=c]{90}{$\ltimes$}} } }


\newcommand{\xtimes}{\hat{\times}}

\newcommand{\ctx}{\textit{ctx}}


% Ordinary context where colouring is done by hand
\newcommand{\coctx}[2]{ #1 \,\text{\scriptsize @}\, {{\text{$#2$}}}  }

% Simple coeffect systems in the introduction
\newcommand{\cons}{\hspace{-0.15em}\times\hspace{-0.25em}} %\sctxclrd{+\hspace{-0.55em}+}}

\newcommand{\alift}[1]{ \textcolor{aclr}{\langle} #1 \textcolor{aclr}{\rangle}}

\definecolor{sclr}{rgb}{0.2,0,0.8}
\newcommand{\sclrd}[1]{ \textcolor{sclr}{#1} }

\newcommand{\C}{ {\textcolor{cclr}{\mathcal{C}}} }
\newcommand{\M}{ {\textcolor{cclr}{\mathcal{M}}} }

\newcommand{\alen}[1]{{\aclrd{\textit{len}(}#1\aclrd{)}}}
\newcommand{\slen}[1]{{\sclrd{\textit{len}(}#1\sclrd{)}}}
\newcommand{\xlen}[1]{{\textit{len}(#1)}}

\newcommand{\reduce}{\longrightarrow}


\newcommand{\restr}[2]{#1|_{#2}}
\newcommand{\narrow}[1]{\hspace{-0.5em} #1 \hspace{-0.65em}~}


\definecolor{todoclr}{rgb}{0.8,0,0.5}
\newcommand{\todo}[1]{\textcolor{todoclr}{ \begin{quotation} \noindent\textbf{TODO:} #1 \end{quotation} }}

\newcommand{\sem}[1]{\llbracket #1 \rrbracket}
\newcommand{\catc}{\mathcal{C}}
\newcommand{\idf}[1]{ {\textnormal{\sffamily id}}_{#1} }


\newcommand{\figcaption}[1]{
  \vspace{0.5em}
  \noindent\makebox[\linewidth]{\rule{\textwidth}{0.5pt}}
  \vspace{-2em}
  \caption{#1}
}
% Half line spacing around align
\newcommand{\zerodisplayskips}{%
  \setlength{\abovedisplayskip}{0.5em}
  \setlength{\belowdisplayskip}{0.5em}
  \setlength{\abovedisplayshortskip}{0.5em}
  \setlength{\belowdisplayshortskip}{0.5em}}
\appto{\normalsize}{\zerodisplayskips}
\appto{\small}{\zerodisplayskips}
\appto{\footnotesize}{\zerodisplayskips}

% half line spacing around compactitem
\setlength{\pltopsep}{0.5em}
\setlength{\plitemsep}{0.3em}

\patchcmd{\thebibliography}{\chapter*}{\section*}{}{}

\begin{document}

\frenchspacing % Reduces space after periods to make text more compact
\raggedbottom % Makes all pages the height of the text on that page
\selectlanguage{american} % Select your default language - e.g. american or ngerman
\pagenumbering{arabic} % Roman page numbering prior to the start of the thesis content (i, ii, iii, etc)
\pagestyle{plain} % Suppress headers for the pre-content pages


% ==================================================================================================

\chapter*{Proposal for thesis corrections}
\renewcommand*\thesection{\arabic{section}}

The starting point for addressing the reviewers concerns is observing that in many practical
programming languages, the value of an expression depends on the type derivation
(Section~\ref{sec:background-practice}). Often, the choice is hidden behind a mechanism that
selects one type as primary\footnote{An F\# example is discussed in Section~\ref{sec:background-practice}
and Haskell example is discussed in Section~\ref{sec:ambiguity}.}. 

The same is the case for the coeffect calculi presented in the thesis, but 
our approach makes the dependence on the typing explicit and we resolve it by
defining the semantics as a function of a typing derivation\footnote{The thesis does not explicitly
state this and it will be clarified in the final version.}. 
this approach does not diverge from, but rather extends Moggi's work \cite{monad-notions}
(Section~\ref{sec:background-theory}).

In the following two sections, we argue that specifying program semantics based on a type derivation
is not unusual in practice (Section~\ref{sec:background-practice}) and theory
(Section~\ref{sec:background-theory})\footnote{This background will be added in the final version of the thesis.}.
Finally, Section~\ref{sec:proposal} concludes with a concrete correction proposal.

\section{Type-directed semantics in practice}
\label{sec:background-practice}
\vspace{-1em}

The aim of the thesis is to provide foundations for extending practical functional-first
programming languages such as F\# \cite{app-fsharp-spec} and Scala \cite{app-scala-spec} with
support for context-aware programming, so we consider two F\# examples. In both, the meaning of
a term depends on the typing:
%
\begin{equation*}
\begin{array}{l}
  \kvd{let}~\ident{nextTwo}~\ident{rnd}~=~(\ident{rnd.Next}(), \ident{rnd.Next}()) \\[-0.2em]
  \kvd{let}~\ident{add}~\ident{a}~\ident{b}~=~\ident{a}+\ident{b}
\end{array}
\end{equation*}
%
The two examples demonstrate two ways of resolving ambiguities in typing derivations and
corresponding semantics:

\begin{itemize}
\item The first example illustrates an ordinary .NET method invocation. In this case,
  the meaning of $\ident{rnd.Next}()$ depends on the type of \ident{rnd}. This could be any
  class with the \ident{Next} method. The F\# compiler can emit .NET bytecode only if it knows the
  concrete type and so the developer has to resolve the ambiguity through a \emph{type annotation}.

\item Operators are treated differently. The meaning of $+$ depends on the types of the
  operands\footnote{F\# differs from OCaml, which uses $+$ for integers, $+.$ for floats and
  $\hat{}$ for string concatenation.}, but F\# can compile it without additional information thanks
  to a \emph{defaulting mechanism}, which chooses \ident{int} if there are no other constraints.
  If the program contains $\ident{add}~\str{hi}~\str{there}$, F\# will use string concatenation
  instead of the default (integer addition).
\end{itemize}

\noindent
In both examples, the meaning of the term depends on a typing derivation, but the compiler includes
a mechanism for finding a unique typing.

\section{Type-directed semantics in theory}
\label{sec:background-theory}
\vspace{-1em}

In the thesis, we give the semantics of terms based on a typing derivation (both for concrete
languages and for coeffect calculi). Using the notation used in the thesis, the semantics of
a (plain) let-binding is written as:
%
\begin{equation*}
\begin{array}{l}
 \sem{x:\tau \vdash \kvd{let}~x_1=e_2~\kvd{in}~e_2 : \tau_2} = \\ \qquad
 \sem{x_1:\tau_1 \vdash e_2 : \tau_2} \circ
 \sem{x:\tau \vdash e_1 : \tau_1}
\end{array}
\end{equation*}
%
The reader might incorrectly see the equation as defining a function from typing \emph{judgements},
as opposed to typing \emph{derivations}. The correct reading is the latter. In fact,
the same approach has been used by Moggi in his seminal paper on monads, who writes
\cite[p7]{monad-notions} (emphasis mine):

\vspace{-0.5em}
\begin{quotation}
\noindent
An interpretation $\sem{-}$ of the language in a category $C$ is parametric in an interpretation
of the symbols in the signature and is defined by \emph{induction on the derivation} of
well-formedness for (types,) terms and equations.
\end{quotation}
\vspace{-0.5em}

\noindent
The notation used by Moggi is unambiguous (and we intend to adopt the same clear notation in the
revised version of the thesis):
%
\begin{equation*}
  \begin{array}{r}
    \sem{x:\tau \vdash e_1 : \tau_1} \\
    \sem{x_1:\tau_1 \vdash e_2 : \tau_2} \\ \hline
    \sem{x:\tau \vdash \kvd{let}~x_1=e_2~\kvd{in}~e_2 : \tau_2}
  \end{array}
  \begin{array}{l}
    = g_1 \\
    = g_2 \\
    = g_2 \circ g_1
  \end{array}
\end{equation*}
%
In systems that have a unique typing (including Moggi's), the fact that
the semantics is defined by induction \emph{over a typing derivation} means merely that we only
define semantics for well-typed programs. Languages with non-syntax-driven rules
(and no unique typing derivation) have two options:

\begin{itemize}
\item \textsc{Coherent semantics.} For certain systems \cite{semantics-bltres}, the semantics of
  a term is the same regardless of a typing derivation. In that case, we can define the semantics
  over a typing derivation, but show that all derviations yield the same semantics.

\item \textsc{Type-directed semantics.} Systems where the meaning of a term \emph{does depend}
  on a typing derivation (cf.~Section~\ref{sec:background-practice}) do not have the coherence
  property and thus require \emph{type-directed} semantics. This is the case for example,
  for the flat coeffect system for implicit parameters (Section~\ref{sec:ambiguity}).
\end{itemize}

\noindent
Contextual dependencies can often be satisfied in multiple ways\footnote{For example, see the
discussion about distributed programming in Section~3.2.2 of the thesis.}. By capturing the
contextual properties in the type-and-coeffect system, we are making the existing
run-time ambiguities \emph{more explicit}. Thus the proposal is to focus on systems with
\emph{coeffect-directed semantics} rather than modifying the calculi that inspired the work
in the thesis in order to force coherence.

\section{Resolving ambiguity}
\label{sec:ambiguity}
\vspace{-1em}

The case where the semantics of a context-aware program depends on the typing derivation is best
demonstrated using the system for implicit parameters (Section~3.2.1 of the thesis). Consider the
following example:
%
\begin{equation*}
\begin{array}{l}
\kvd{let}~\ident{f} = (~\kvd{let}~\ident{?x} = 10~\kvd{in}~
  \lambda \ident{v} \rightarrow \ident{?x})~\kvd{in}\\[-0.2em]
\kvd{let}~\ident{?x} = 15~\kvd{in}~\ident{f}~0
\end{array}
\end{equation*}
%
Here, a function value $\lambda \ident{v} \rightarrow \ident{?x}$ is created in a context where the
implicit parameter $\ident{?x}$ has a value 10. The function is then called in a context where
$\ident{?x}$ has a value 15. Is the result of the expression $10$ or $15$? The choice of the
run-time semantics needs to be reflected in the type system.

\paragraph{Resolution in Haskell.}
In Haskell, the implicit parameters from the \emph{declaration-site} are preferred and so the result
is 10. Correspondingly, the type system only permits one typing -- with the parameter \ident{?x}
required on the declaration-side (allowing no rebinding at the call site). However, if the function
value was defined in a context not containing \ident{?x}, the value from the call site would be used.
Thus, Haskell uses a \emph{defaulting mechanism} for implicit parameters, similar to that of F\#
operators discussed in Section~\ref{sec:background-practice}.

\paragraph{Resolution for exceptions.}
In case of implicit parameters, the choice is between \emph{lexical} and \emph{dynamic} scoping.
The same choice appears for other language constructs, such as exception handling. Exception
handlers in most modern languages are dynamically scoped, but Beta and original version of Smalltalk
support lexical scoping \cite{app-exceptions}. A language that supports both dynamic and lexical
exception handlers would expose the same problem.

\paragraph{Resolution in coeffect systems.}
Coeffect systems presented in the thesis explore the most general approach. For example, the
calculi for implicit parameters permits both lexical and dynamic scoping without a built-in ad-hoc
defaulting mechanism.

Our design choice means that semantics of a term depends on the typing. In other words, the
inherent choice in the semantics is reflected in the fact that a term can have multiple types.
We argue that a \emph{coeffect-directed semantics} (as used in the thesis) provides more insight
into the problem of context-aware programming as it lets us explore a range of design
possibilities.

\section{Correction proposal}
\label{sec:proposal}
\vspace{-1em}

In the preceding sections, we argued that \emph{coeffect-directed semantics} is the right approach
for discussing context-aware programming languages. This clarifies the confusion arising from the
fact that coeffect systems (like implicit parameters and others) do not satisfy categorical
\emph{coherence}. This section outlines four specific improvements to address the reviewers concerns.

\vspace{-0.5em}
\paragraph{4.1 Type erasure.}
The coeffect-directed semantics in the thesis is presented in the style of a categorical semantics
(as it was, indeed, inspired by categorical structures). However, it does not follow the full rigour
of category theory and so it is better seen as \emph{translational semantics} or as \emph{type
erasure}. Given a typing derivation we produce a new term that unambiguously defines the meaning of
the original term (Chapter 3 uses direct denotational style; Chapters 4 and 5 use a common
abstract structure).

The main value of the semantics is guiding the definition of the type system, because the structure
of the coeffect annotations in the typing rules follows from the structure of this coeffect-directed
translation.

In the revised thesis, we intend to make this more explicit and treat the formalism as a
``coeffect-directed translation'', as well as explicitly define the target term language
for the translation.

\vspace{-0.5em}
\paragraph{4.2 Unique typing derivation.}

As argued above, the fact the that semantics depends on the typing derivation is an important
aspect of our work. This lets us better explore the design space, but it does not guide
concrete language implementations that need a unique typing (cf. Haskell's implicit parameters).

In the final version of the thesis, we intend to follow the example of Haskell and include an
algorithmic formulation of the type system that produces a single default typing
derivation\footnote{There are three sources of typing ambiguity (and hence semantic ambiguity) --
subtyping, lambda abstraction and structural rules. We intend to make subtyping explicit in the
language, add externally provided function for resolving ambiguities in lambda abstraction and
have algorithmic typing rules instead of contraction, weakening and exchange rules.} and
resolves the ambiguity.

\vspace{-0.5em}
\paragraph{4.3. Equational structure.}

One specific concern raised in the referees report is the lack of equational structure for the
categorically-inspired structures. This arises from the fact that our usage of categorical
structures (indexed comonads) is mainly to inspire the abstractions that can be used to structure
context-aware computations (as opposed to focusing on using category theory to prove properties
of context-aware programs).

Our work should be seen as a coeffect-directed translation to a target language with structures
inspired by indexed comonads. Preserving this link is important in order to relate coeffect calculi with
previous work \cite{comonads-notions}, however our structure need not be seen as categorical
semantics.

\vspace{-0.5em}
\paragraph{4.4. Generalization.}

One of the key claims of the thesis is that the comonad-inspired structure of the target
language appropriately captures the structure of concrete examples of context-aware computations
(presented in Chapter 3) and as a result, it provides an appropriate type system.

This claim is left implicit and we intend to address this in the final version 
(by proving that the three concrete examples spelled out in Chapter 3 do, indeed, fit
the common patterns identified later in Chapters 4 and 5).

\vspace{-0.5em}
\paragraph{4.5. Universal type systems.}

The thesis does not clearly explain the benefit of introducing the universal type systems
based on the coeffect calculi, as we do not prove the usual type-safety property for the concrete systems.
This becomes clearer when we consider the system as \emph{type erasure}.

The type systems guarantee that \emph{coeffect indices} will match in the resulting 
translation. The relationship from indices to values is injective in the general case, but 
we can also show a number of important properties (which will be clarified in the revised
version) for the concrete systems, \eg~an upper bound on the number of required
past values in causal dataflow.


% ==================================================================================================

\section{Summary}

An interesting aspect of many context-aware computations is that they require access to some
context, but do not explicitly specify where the context comes from. In case of implicit parameters,
the values can be provided either by the call site or by the declaration-site.

In some systems like Haskell's implicit parameters, this aspect is hidden through a mechanism that
chooses a \emph{default typing} (and a \emph{default semantics}) and thus hides the ambiguity. Our approach is
to make the ambiguity explicit in the type system. We follow F\# and accept the fact that this
makes the semantics of a term dependent on the typing and we extend Moggi's \emph{type-directed
semantics} into a \emph{coeffect-directed semantics}.

Our use of categorical structures (namely \emph{indexed comonads}) is similar to practical Haskell
use of monads in that we use them to \emph{capture a common structure}. This is in contrast with
use of category theory for \emph{proving program properties}. Correspondingly, our focus is on
finding the right structure and showing that it captures our motivating examples and gives a type
system with desirable properties.

This document explains an additional background and motivation that is missing in the submitted
version of the thesis (Section~\ref{sec:background-practice} and \ref{sec:background-theory}) as
well as additional clarification showing how the semantics of implicit parameters depends on the
typing (Section~\ref{sec:ambiguity}). Finally, we list four specific improvements that will be
made in the final version of the thesis to better reflect our approach and the methodology
clarified in this document (Section~\ref{sec:proposal}).

\bibliographystyle{abbrv}
\bibliography{Bibliography}

\end{document}
