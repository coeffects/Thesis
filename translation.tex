% ==================================================================================================
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
% ==================================================================================================

\documentclass[
		twoside,openright,titlepage,numbers=noenddot,headinclude,%1headlines,
                footinclude=true,cleardoublepage=empty,
                BCOR=10mm,paper=a4,fontsize=10pt, % Binding correction, paper type and font size
                ngerman,american, % Languages
                ]{scrreprt}

\input{classicthesis-config}
\usepackage{semantic}
\usepackage{paralist}
\usepackage{etoolbox}
\usepackage{stmaryrd}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}

\newcounter{mythmcounter}
\newcounter{mydefcounter}
\newcounter{myexpcounter}
\newtheorem{example}[myexpcounter]{Example}
\newtheorem{remark}[mythmcounter]{Remark}
\newtheorem{definition}[mydefcounter]{Definition}
\newtheorem{theorem}[mythmcounter]{Theorem}
\newtheorem{lemma}[mythmcounter]{Lemma}
\newtheorem{proposition}[mythmcounter]{Proposition}
\newtheorem*{lemma*}{Lemma}

% Formatting for source code & types
\definecolor{cmtclr}{rgb}{0.0,0.6,0.0}
\definecolor{kvdclr}{rgb}{0.0,0.0,0.6}
\definecolor{strclr}{rgb}{0.5,0.1,0.0}
\definecolor{prepclr}{rgb}{0.0,0.0,0.0}

\newcommand{\sep}[0]{\; | \;}
\newcommand{\kvd}[1]{\textnormal{\textcolor{kvdclr}{\ttfamily #1}}}
\newcommand{\str}[1]{\textnormal{\textcolor{strclr}{\ttfamily "#1"}}}
\newcommand{\prepk}[1]{\textnormal{\textcolor{prepclr}{\bfseries\sffamily #1}}}
\newcommand{\prepi}[1]{\textnormal{\textcolor{prepclr}{\ttfamily #1}}}
\newcommand{\ident}[1]{\textnormal{\sffamily #1}}
\newcommand{\cmt}[1]{\textit{\sffamily\textcolor{cmtclr}{#1}}}

\newcommand{\ctyp}[2]{C^{#1}#2}
\newcommand{\mtyp}[2]{M^{#1}#2}
\newcommand{\subst}[3]{#1[#2 \leftarrow #3]}

% Typing rule and typing statement (single line)
\newcommand{\tyrule}[3]{ \inference[\footnotesize{(\emph{#1})}~~]{#2}{#3} }
\newcommand{\tyruler}[3]{ \inference{#2}{#3}~~\footnotesize{(\emph{#1})} }

% Coeffect algebra
\definecolor{aclr}{rgb}{0.6,0.3,0.0}
\newcommand{\aclrd}[1]{\textcolor{aclr}{#1}}

% Coeffect algebra
\definecolor{cclr}{rgb}{0.0,0.5,0.0}
\newcommand{\cclrd}[1]{\textcolor{cclr}{#1}}

\newcommand{\czero}{ \textcolor{cclr}{ \mathsf{ign} } }
\newcommand{\cunit}{ \textcolor{cclr}{ \mathsf{use} } }
\newcommand{\cseq}{ \textcolor{cclr}{ \circledast }}
\newcommand{\cpar}{ \textcolor{cclr}{\oplus} }
\newcommand{\czip}{ \textcolor{cclr}{\wedge} } % only used by flat coeffects
\newcommand{\cleq}{ \textcolor{cclr}{\leq} }
\newcommand{\cgeq}{ \textcolor{cclr}{\geq} }

\newcommand{\atimes}{ \textcolor{aclr}{\times} }
\newcommand{\aseq}{ \textcolor{aclr}{\circledast}} % Should be the same as \cseq
\newcommand{\aparstr}{ \textcolor{aclr}{\oplus}} % Should be the same as \cseq

% Unified

\newcommand{\SH}{ {\textcolor{sclr}{S}} }
\newcommand{\SP}{ {\textcolor{sclr}{P}} }
\newcommand{\SHP}{ {\textcolor{sclr}{S\triangleleft P}} }
\newcommand{\sempty}{ {\textcolor{sclr}{ \hat{0}}} }
\newcommand{\sunit}{ {\textcolor{sclr}{\hat{1}}} }
\newcommand{\stimes}{ {\textcolor{sclr}{\diamond}} }
\newcommand{\sflat}{\star}

\newcommand{\azero}{ \textcolor{aclr}{\bot} }
\newcommand{\aunit}{ \alift{\cunit} }
\newcommand{\aweak}{ \alift{\czero} }

\newcommand{\azip}{ \textcolor{aclr}{ \mathbin{\rotatebox[origin=c]{-90}{$\ltimes$}} } }
\newcommand{\apar}{ \textcolor{aclr}{ \mathbin{\rotatebox[origin=c]{90}{$\ltimes$}} } }


\newcommand{\xtimes}{\hat{\times}}

\newcommand{\ctx}{\textit{ctx}}


% Ordinary context where colouring is done by hand
\newcommand{\coctx}[2]{ #1 \,\text{\scriptsize @}\, {{\text{$#2$}}}  }

% Simple coeffect systems in the introduction
\newcommand{\cons}{\hspace{-0.15em}\times\hspace{-0.25em}} %\sctxclrd{+\hspace{-0.55em}+}}

\newcommand{\alift}[1]{ \textcolor{aclr}{\langle} #1 \textcolor{aclr}{\rangle}}

\definecolor{sclr}{rgb}{0.2,0,0.8}
\newcommand{\sclrd}[1]{ \textcolor{sclr}{#1} }

\newcommand{\C}{ {\textcolor{cclr}{\mathcal{C}}} }
\newcommand{\M}{ {\textcolor{cclr}{\mathcal{M}}} }

\newcommand{\alen}[1]{{\aclrd{\textit{len}(}#1\aclrd{)}}}
\newcommand{\slen}[1]{{\sclrd{\textit{len}(}#1\sclrd{)}}}
\newcommand{\xlen}[1]{{\textit{len}(#1)}}

\newcommand{\reduce}{\longrightarrow}


\newcommand{\restr}[2]{#1|_{#2}}
\newcommand{\narrow}[1]{\hspace{-0.5em} #1 \hspace{-0.65em}~}


\definecolor{todoclr}{rgb}{0.8,0,0.5}
\newcommand{\todo}[1]{\textcolor{todoclr}{ \begin{quotation} \noindent\textbf{TODO:} #1 \end{quotation} }}

\newcommand{\sem}[1]{\llbracket #1 \rrbracket}
\newcommand{\catc}{\mathcal{C}}
\newcommand{\idf}[1]{ {\textnormal{\sffamily id}}_{#1} }


\newcommand{\figcaption}[1]{
  \vspace{0.5em}
  \noindent\makebox[\linewidth]{\rule{\textwidth}{0.5pt}}
  \vspace{-2em}
  \caption{#1}
}
% Half line spacing around align
\newcommand{\zerodisplayskips}{%
  \setlength{\abovedisplayskip}{0.5em}
  \setlength{\belowdisplayskip}{0.5em}
  \setlength{\abovedisplayshortskip}{0.5em}
  \setlength{\belowdisplayshortskip}{0.5em}}
\appto{\normalsize}{\zerodisplayskips}
\appto{\small}{\zerodisplayskips}
\appto{\footnotesize}{\zerodisplayskips}

% half line spacing around compactitem
\setlength{\pltopsep}{0.5em}
\setlength{\plitemsep}{0.3em}

\patchcmd{\thebibliography}{\chapter*}{\section*}{}{}

\begin{document}

\frenchspacing % Reduces space after periods to make text more compact
\raggedbottom % Makes all pages the height of the text on that page
\selectlanguage{american} % Select your default language - e.g. american or ngerman
\pagenumbering{arabic} % Roman page numbering prior to the start of the thesis content (i, ii, iii, etc)
\pagestyle{plain} % Suppress headers for the pre-content pages


% ==================================================================================================

\chapter*{Translation semantics}
\renewcommand*\thesection{\arabic{section}}

Coeffects let us easily construct context-aware domain-specific languages. The general coeffect
language framework provides a parameterized type system (flat or structural) and a translation
that turns a program written in a context-aware DSL into a program in a simple (non-context-aware)
functional programming langauge with additional comonadically-inspired coeffect-specific primitives.

In this section, we discuss the safety that is guaranteed by the coeffect language framework.
The general coeffect language framework itself does not automatically guarantee safety of a 
concrete context-aware DSL. This depends on the additional coeffect-specific primitives.

However, the framework makes it easier to prove such safety -- we only need to define the
meaning of the comonadically-inspired coeffect-specific data type and its associated operations and 
then show that those do not ``go wrong''. In doing so, we can use the coeffect annotations
provided by the type system. In this section, we:

\begin{itemize}
\item Define the common subset of the target functional programming language. This includes the
  syntax of the language, reduction rules and typing rules, but it does \emph{not} include 
  coeffect-specific definitions. Well-typed programs written using the common subset of the 
  target language do not get stuck (via progress and preservation), but they may reduce to 
  \ident{error}, e.g. when accessing the head of an empty list.
  
\item We then extend the language with coeffect-specific comonadically-inspired
  data types and primtiives for dataflow and for implicit parameters. We show that the extension
  preserves the progress and preservation properties. 
  
\item Next, we consider only programs in the target language that were produced by a
  translation from the coeffect domain-specific language and we show that such programs not only
  do not get stuck, but they also do not reduce to the \ident{error} value. In other words,
  ``well-typed coeffect programs do not get hungry'' requiring more context than guaranteed
  by the coeffect type system.

\item We show how the approach extends to structural coeffect systems and we argue that our
  proof can be generalized -- rather than reconsidering progress and preservation of the 
  whole language, we can rely just on the correctness of the coeffect-specific comonadically-inspired
  primitives and abstraction mechanism provided by languages such as ML and Haskell.  
\end{itemize}  

% --------------------------------------------------------------------------------------------------

\begin{figure}[t]
\paragraph{Language syntax}  
\begin{equation*}
\begin{array}{rcl}
  v &  = & \ident{error} \sep s \sep n \sep \lambda x.e \sep (v_1, \ldots, v_n) \sep v_1::v_2 \sep []\\
\\[-0.5em]
  e &  = & x \sep \ident{error} \sep s \sep n \sep \pi_i~e \sep (e_1, \ldots, e_n)  \\
    &\sep& e_1~e_2 \sep \lambda x.e \sep \ident{head}~e \sep \ident{tail}~e \sep e_1 :: e_2 \sep [] \\
    &\sep& \kvd{if}~e_1 = e_2~\kvd{then}~e_3~\kvd{else}~e_4\\
\\[-0.5em]
  \tau &  = & \ident{str} \sep \ident{num} \sep [\tau] \sep \tau_1 \times \ldots \times \tau_n \sep \tau_1 \rightarrow \tau_2 \\
\\[-0.5em]
  C  & = & (v_1, \ldots, v_{i-1}, \_, e_{i+1}, \ldots e_n) \\
    &\sep& v~\_ \sep \_~e \sep \pi_i~\_ \sep \ident{head}~\_ \sep \ident{tail}~\_ \sep \_::e \sep v::\_  \\
    &\sep& \kvd{if}~\_ = e~\kvd{then}~e_1~\kvd{else}~e_2 \sep \kvd{if}~v = \_~\kvd{then}~e_1~\kvd{else}~e_2
  
\end{array}
\end{equation*}

~
\paragraph{Reduction rules}
\begin{equation*}
\begin{array}{rll}
  \footnotesize{(\emph{fn})}  & (\lambda x.e)~v \rightarrow e[x\leftarrow v] \\[0.5em]
  \footnotesize{(\emph{prj})} & \pi_i (v_1, \ldots, v_n) \rightarrow v_i\\[0.5em]
  \footnotesize{(\emph{hd})}  & \ident{head}~(v_1::v_2) \rightarrow v_1\\[0.5em]
  \footnotesize{(\emph{tl})}  & \ident{tail}~(v_1::v_2) \rightarrow v_2\\[0.5em]
  \footnotesize{(\emph{hde})}  & \ident{head}~[] \rightarrow \ident{error}\\[0.5em]
  \footnotesize{(\emph{tle})}  & \ident{tail}~[] \rightarrow \ident{error}\\[0.5em]
  \footnotesize{(\emph{err})}  & C[\ident{error}] \rightarrow \ident{error}\\[0.5em]
  \footnotesize{(\emph{ifnt})}  & \kvd{if}~n_1 = n_2~\kvd{then}~e_1~\kvd{else}~e_2 \rightarrow e_1 & (\textnormal{when}~n_1 = n_2)\\[0.5em]
  \footnotesize{(\emph{ifnt})}  & \kvd{if}~n_1 = n_2~\kvd{then}~e_1~\kvd{else}~e_2 \rightarrow e_2 & (\textnormal{when}~n_1 \neq n_2)\\[0.5em]
  \footnotesize{(\emph{ifst})}  & \kvd{if}~s_1 = s_2~\kvd{then}~e_1~\kvd{else}~e_2 \rightarrow e_1 & (\textnormal{when}~s_1 = s_2)\\[0.5em]
  \footnotesize{(\emph{ifst})}  & \kvd{if}~s_1 = s_2~\kvd{then}~e_1~\kvd{else}~e_2 \rightarrow e_2 & (\textnormal{when}~s_1 \neq s_2)\\[0.5em]
  \footnotesize{(\emph{ctx})}  & C[e] \rightarrow C[e']  & (\textnormal{when}~e\rightarrow e')\\[0.5em]
\end{array}
\end{equation*}

\caption{Common syntax and reduction rules of the target langauge}
\label{fig:transl-target}
\end{figure}

% --------------------------------------------------------------------------------------------------

\section{Target langauge}

The target langauge for the translation is a simply typed lambda calculus with strings, numbers,
tuples and lists. For each concrete coeffect domain-specific language, we then add additional
primitives -- a comonadically-inspired data type and its associated primitive operations. In this
section, we define the common parts of the language.

The syntax of the target programming langauge is shown in Figure~\ref{fig:transl-target}. 
The values include primitive strings $s$ and numbers $n$, tuples and list values. The value
\ident{error} represents the result of a failed computation.

The expressions include variables $x$, values lambda abstraction and application, conditionals
(limited to equality check) and operations on tuples and lists. We do not need pattern matching
on lists and recursion (although a realistic programming language would include both). In what
follows, we also use the following syntactic sugar for lists and let binding:
%
\begin{equation*}
\begin{array}{rcl}
  \langle e_1, \ldots, e_n \rangle &=& e_1 :: \ldots :: e_n :: [] \\
  \kvd{let}~x=e_1~\kvd{in}~e_2 &=& (\lambda x.e_2) e_1 \\
\end{array}
\end{equation*}
%
Finally, $C[e]$ defines the context in which sub-expressions are evaluated. Together with the
evaluation rules shown in  Figure~\ref{fig:transl-target}, this captures the standard call-by-name
semantics of the common parts of the target language.

The (\emph{hde}) and (\emph{tle}) reduction rules describe the situation when we attempt to access
the head or the tail of an empty list. In that case, the expression reduces to \ident{error} value.
An \ident{error} value appearing in any context then propagates to the top-level as defined by 
(\emph{err}).

The typing rules for the common expressions of the target langauge are shown in 
Figure~\ref{fig:transl-targetty}. The rules are standard. As usual, the 
\ident{error} term is allowed to have any type (\emph{err}).

% --------------------------------------------------------------------------------------------------

\begin{figure}[t]
\paragraph{Typing rules}
\begin{equation*}
\begin{array}{ll}
\tyrule{var}
  { x:\tau \in \Gamma }
  { \Gamma \vdash x:\tau }
&
\tyrule{err}
  { ~ }
  { \Gamma \vdash \ident{error}:\tau }
\\[1em]
\tyrule{str}
  { ~ }
  { \Gamma \vdash s:\ident{str} }
&
\tyrule{num}
  { ~ }
  { \Gamma \vdash n:\ident{num} }
\\[1em]
\tyrule{nil}
  { ~ }
  { \Gamma \vdash []:[\tau] }
&
\tyrule{head}
  { \Gamma \vdash e :[\tau] }
  { \Gamma \vdash \ident{head}~e:\tau }
\\[1em]
\tyrule{tail}
  { \Gamma \vdash e :[\tau] }
  { \Gamma \vdash \ident{tail}~e:[\tau] }
\qquad~&
\tyrule{abs}
  { \Gamma, x\!:\!\tau_1 \vdash e : \tau_2 }
  { \Gamma \vdash \lambda x.e : \tau_1 \rightarrow \tau_2 }
\end{array}
\end{equation*}
\begin{equation*}
\begin{array}{l}
\tyrule{app}
  { \Gamma \vdash e_1 : \tau_1 \rightarrow \tau_2  & \Gamma \vdash e_2 : \tau_1 }
  { \Gamma \vdash e_1~e_2 : \tau_2 }
\\[1.25em]
\tyrule{cons}
  { \Gamma \vdash e_1 :\tau & \Gamma \vdash e_2 : [\tau] }
  { \Gamma \vdash e_1\!::\!e_2 : [\tau] }
\\[1.25em]
\tyrule{proj}
  { \Gamma \vdash e : \tau_1 \times \ldots \tau_i \times \ldots \times \tau_n }
  { \Gamma \vdash \pi_i~e:\tau_i }
\\[1.25em]
\tyrule{tup}
  { \forall i\in\{1 \ldots n\}.~ \Gamma \vdash e_i : \tau_i }
  { \Gamma \vdash (e_1, \ldots, e_n) : \tau_1 \times \ldots \times \tau_n }
\\[1.25em]
\tyrule{ifn}
  { \Gamma \vdash e_1 : \ident{num} & \Gamma \vdash e_2 : \ident{num} &
    \Gamma \vdash e_3 : \tau & \Gamma \vdash e_4 : \tau}
  { \Gamma \vdash \kvd{if}~e_1 = e_2~\kvd{then}~e_3~\kvd{else}~e_4 : \tau}
\\[1.25em]
\tyrule{ifs}
  { \Gamma \vdash e_1 : \ident{str} & \Gamma \vdash e_2 : \ident{str} &
    \Gamma \vdash e_3 : \tau & \Gamma \vdash e_4 : \tau}
  { \Gamma \vdash \kvd{if}~e_1 = e_2~\kvd{then}~e_3~\kvd{else}~e_4 : \tau}
\end{array}
\end{equation*}

\caption{Typing rules for the common syntax of the target language}
\label{fig:transl-targetty}
\end{figure}

% --------------------------------------------------------------------------------------------------

\section{Properties}

The subset of the langauge described so far models a simple ML-like functional programming 
langauge (or, Haskell-like language, if we choose call-by-name evaluation). We discuss the properties
of the language after introducing coeffect-specific primitives. As will be seen, ``well-typed
programs do not get stuck'' in our language, although they may produce the \ident{error} value.
For example, $\ident{head}~42$ is a stuck expression ruled out by the common rules of the type
system, however, $\ident{head}~[]$ is a well typed expression that produces \ident{error}.




% And also syntactic sugar \ident{map} 


%    &\sep& \ident{cobind}_{\cclrd{s},\cclrd{r}}~e_1~e_2 \sep \ident{counit}_{\cunit}~e \sep \ident{merge}_{\cclrd{r},\cclrd{s}}~e 
%       \sep \ident{split}_{\cclrd{r},\cclrd{s}}~e \sep \ident{lift}_{\cclrd{r},\cclrd{r'}}~e \\

%
% &\sep& \ident{cobind}_{\cclrd{s},\aclrd{\textbf{r}}}~e_1~e_2 \sep \ident{counit}_{\cunit}~e \sep \ident{merge}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}~e 
%   \sep \ident{split}_{\aclrd{\textbf{r}},\aclrd{\textbf{s}}}~e \sep \ident{lift}_{\cclrd{r},\cclrd{r'}}~e \sep \ident{dup}_{\cclrd{r},\cclrd{s}}~e \\

\section{Dataflow}
Domain specific coeffect annotations are non-negative integers, type is a tuple and new kinds
of values are lists:
\begin{equation*}
\begin{array}{rcl}
  v_c &  = &  \langle v_1, \ldots, v_n \rangle
\end{array}
\end{equation*}
%
With the following typing:
%
\begin{equation*}  
\tyrule{val}
  { \forall v_i . \vdash v_i : \tau }
  { \vdash \langle v_1, \ldots, v_n \rangle : \ctyp{n}{\tau} }
\end{equation*}
%
And domain specific operations are defined as:
%
\begin{equation*}
\begin{array}{l}
\ident{counit}_{0}\langle a_0 \rangle \rightarrow a_0
\\[0.45em]
\ident{cobind}_{m, n}~f \langle a_0, \ldots a_{m+n} \rangle \rightarrow
\\[-0.25em]
\quad \langle f \langle a_0, \ldots, a_m \rangle, \ldots, f \langle a_{n}, \ldots, a_{m+n} \rangle \rangle
\\[0.45em]
\ident{merge}_{m, n} (\langle a_0, \ldots, a_m \rangle, \langle b_0, \ldots, b_n\rangle) \rightarrow
\\[-0.25em]
\quad \langle (a_0, b_0), \ldots, (a_{\mathit{min}(m,n)}, b_{\mathit{min}(m,n)}) \rangle
\\[0.45em]
\ident{split}_{m, n} \langle (a_0, b_0), \ldots, (a_{\mathit{max}(m,n)}, b_{\mathit{max}(m,n)}) \rangle  \rightarrow
\\[-0.25em]
\quad (\langle a_0, \ldots, a_m \rangle, \langle b_0, \ldots, b_n\rangle)
\\[0.45em]
\ident{lift}_{n', n} \langle a_0, \ldots, a_{n'} \rangle \rightarrow
\qquad(\hspace{-0.75em}\textnormal{\footnotesize when}~n\leq n') \\[-0.25em]
\quad \langle a_0, \ldots, a_n \rangle
\end{array}
\end{equation*}

We could define those in terms of head/tail functions and then prove that they work (and translated
program does not contain head/tail), but perhaps that's unnecessary overkill. Or perhaps it would
be useful in order to show how we avoid errors... But doing it directly looks just simpler (we
also do not need a ``list'' type).

\begin{theorem}[Type preservation]
  If $\Gamma \vdash e : \tau$ and $e \rightarrow e'$ then $\Gamma \vdash e' : \tau$
\end{theorem}
\begin{proof}
  Rule induction over $\rightarrow$
  
Simple for normal parts of the language

We have to check this for dataflow reductions  
\end{proof}

\begin{theorem}[Progress]
  If $\Gamma \vdash e : \tau$ then either $e$ is a value or there exits $e'$ such that $e \rightarrow e'$
\end{theorem}
\begin{proof}
  By rule induction over $\vdash$.
  
Interesting case is $e_1 e_2$ where $e_1 = v$ is one of the primitives. Then we have to go through
them and make sure they can progress.  
\end{proof}





























\end{document}
